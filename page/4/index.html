<!DOCTYPE html><html lang="null"><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description"><title>KANMARS的博客 | helloword 2046。趁着，我会喜怒你会哀乐，唱几分钟情歌。</title><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/normalize/5.0.0/normalize.min.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/pure/0.6.0/pure-min.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/pure/0.6.0/grids-responsive-min.css"><link rel="stylesheet" type="text/css" href="/css/style.css?v=0.0.0"><link rel="stylesheet" href="//cdn.bootcss.com/font-awesome/4.7.0/css/font-awesome.min.css"><script type="text/javascript" src="//cdn.bootcss.com/jquery/3.1.1/jquery.min.js"></script><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">KANMARS的博客</h1><a id="logo" href="/.">KANMARS的博客</a><p class="description">helloword 2046。趁着，我会喜怒你会哀乐，唱几分钟情歌。</p></div><div id="nav-menu"><a href="/." class="current"><i class="fa fa-home"> Start</i></a><a href="/archives/"><i class="fa fa-archive"> Archiv</i></a><a href="/2016/04/23/2016-04-23-mysongs/"><i class="fa fa-user"> Über</i></a></div></div><div id="layout" class="pure-g"><div class="pure-u-1 pure-u-md-3-4"><div class="content_container"><div class="post"><h2 class="post-title"><a href="/2016/01/16/2016-01-16-systemctl_ALL/">systemctl 命令不完全指南</a></h2><div class="post-meta">2016-01-16</div><a data-thread-key="2016/01/16/2016-01-16-systemctl_ALL/" href="/2016/01/16/2016-01-16-systemctl_ALL/#comments" class="ds-thread-count"></a><div class="post-content"><html xmlns:v="urn:schemas-microsoft-com:vml" xmlns:o="urn:schemas-microsoft-com:office:office" xmlns:w="urn:schemas-microsoft-com:office:word" xmlns:m="http://schemas.microsoft.com/office/2004/12/omml" xmlns="http://www.w3.org/TR/REC-html40"><br><br><head><br><meta http-equiv="Content-Type" content="text/html; charset=gb2312"><br><meta name="ProgId" content="Word.Document"><br><meta name="Generator" content="Microsoft Word 14"><br><meta name="Originator" content="Microsoft Word 14"><br><link rel="File-List" href="2016-01-16-systemctl_ALL.files/filelist.xml"><br><!--[if gte mso 9]><xml></div><p class="readmore"><a href="/2016/01/16/2016-01-16-systemctl_ALL/">Mehr lesen</a></p></div><div class="post"><h2 class="post-title"><a href="/2015/12/01/2015-12-01-Global_unique_key_plus/">[KANMARS原创] - 分布式系统一致性hash中的key-全局唯一ID生成器-加强版</a></h2><div class="post-meta">2015-12-01</div><a data-thread-key="2015/12/01/2015-12-01-Global_unique_key_plus/" href="/2015/12/01/2015-12-01-Global_unique_key_plus/#comments" class="ds-thread-count"></a><div class="post-content"><p></p><p><br>    上次写了个IDCreateUtils，有点累赘，这次更新了一下，这个是通用版，直接给一个数字设置第start到第end位的值<br></p><p></p>
<p></p><p><br>    <br><br></p><p></p>
<p></p><p><br>    package cn.kanmars;<br></p><br><br><br>/<strong><br><br>&nbsp;<em> Created by baolong on 2015/12/1.<br><br>&nbsp;</em>/<br><br>public class IDCreaterPlusUtils {<br><br>&nbsp;&nbsp;&nbsp; /</strong><br><br>&nbsp;&nbsp;&nbsp;&nbsp; <em> 掩码制造，从0开始，包含start，包含end，start&gt;=0，end&lt;=63<br><br>&nbsp;&nbsp;&nbsp;&nbsp; </em> @param start 0&lt;=start&lt;=63<br><br>&nbsp;&nbsp;&nbsp;&nbsp; <em> @param end&nbsp;&nbsp; 0&lt;=end&lt;=63<br><br>&nbsp;&nbsp;&nbsp;&nbsp; </em> @return<br><br>&nbsp;&nbsp;&nbsp;&nbsp; <em>/<br><br>&nbsp;&nbsp;&nbsp; public static long createMask(int start,int end) throws Exception{<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if(start &lt;0 || start &gt;63 ) throw new Exception(“IDCreaterPlusUtils createMask must: 0&lt;=start&lt;=63 “);<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if(end&nbsp;&nbsp; &lt;0 || end&nbsp;&nbsp; &gt;63 ) throw new Exception(“IDCreaterPlusUtils createMask must: 0&lt;=end&lt;=63 “);<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if(end &lt; start) throw new Exception(“IDCreaterPlusUtils createMask must: end &gt;= start”);<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; long result = 0xffffffffffffffffl;<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; result = result &lt;&lt; (64-(end+1-start));<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; result = result &gt;&gt;&gt; start;<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return result;<br><br>&nbsp;&nbsp;&nbsp; }<br><br><br><br>&nbsp;&nbsp;&nbsp; /**<br><br>&nbsp;&nbsp;&nbsp;&nbsp; </em> 给old代表的64位数字中的第start到第end位，设置一个数字为val，如果val超出start和end的长度区间，则舍弃掉超出的内容<br><br>&nbsp;&nbsp;&nbsp;&nbsp; <em> @param old&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 原始数据<br><br>&nbsp;&nbsp;&nbsp;&nbsp; </em> @param val&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 要设置进去的数据<br><br>&nbsp;&nbsp;&nbsp;&nbsp; <em> @param start&nbsp;&nbsp;&nbsp;&nbsp; 开始位置，0&lt;=start&lt;=end&lt;=63，闭区间<br><br>&nbsp;&nbsp;&nbsp;&nbsp; </em> @param end&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 结束位置，0&lt;=start&lt;=end&lt;=63, 闭区间<br><br>&nbsp;&nbsp;&nbsp;&nbsp; <em> @return<br><br>&nbsp;&nbsp;&nbsp;&nbsp; </em> @throws Exception<br><br>&nbsp;&nbsp;&nbsp;&nbsp; <em>/<br><br>&nbsp;&nbsp;&nbsp; public static long setValue(long old,long val,int start,int end) throws Exception{<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if(start &lt;0 || start &gt;63 ) throw new Exception(“IDCreaterPlusUtils createMask must: 0&lt;=start&lt;=63 “);<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if(end&nbsp;&nbsp; &lt;0 || end&nbsp;&nbsp; &gt;63 ) throw new Exception(“IDCreaterPlusUtils createMask must: 0&lt;=end&lt;=63 “);<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if(end &lt; start) throw new Exception(“IDCreaterPlusUtils createMask must: end &gt;= start”);<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; long result = old;<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; long mask = createMask(start,end);<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; result = result &amp; (0xffffffffffffffffl ^ mask);//result与掩码的反码进行与操作，将指定位置为0<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; long value = val;<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; value = value &lt;&lt; (64-(end+1-start));&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //左移到指定位置<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; value = value &gt;&gt;&gt;&nbsp; start;<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; value = value &amp; mask;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //与掩码进行计算<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; result = result | value;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //将原值与新值进行组合<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return result;<br><br>&nbsp;&nbsp;&nbsp; }<br><br><br><br><br><br>&nbsp;&nbsp;&nbsp; /**<br><br>&nbsp;&nbsp;&nbsp;&nbsp; </em> 打印一个long的二进制码，不分割<br><br>&nbsp;&nbsp;&nbsp;&nbsp; <em> @param l<br><br>&nbsp;&nbsp;&nbsp;&nbsp; </em> @return<br><br>&nbsp;&nbsp;&nbsp;&nbsp; <em>/<br><br>&nbsp;&nbsp;&nbsp; public static String pl64(long l){<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return pl64(l,false);<br><br>&nbsp;&nbsp;&nbsp; }<br><br>&nbsp;&nbsp;&nbsp; /**<br><br>&nbsp;&nbsp;&nbsp;&nbsp; </em> 打印一个long的二进制码<br><br>&nbsp;&nbsp;&nbsp;&nbsp; <em> @param l&nbsp;&nbsp; &nbsp;要打印的数值<br><br>&nbsp;&nbsp;&nbsp;&nbsp; </em> @param split&nbsp;&nbsp; &nbsp;是否每4位分割<br><br>&nbsp;&nbsp;&nbsp;&nbsp; <em> @return<br><br>&nbsp;&nbsp;&nbsp;&nbsp; </em>/<br><br>&nbsp;&nbsp;&nbsp; public static String pl64(long l,boolean split){<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; StringBuilder sb = new StringBuilder();<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; for(int i=0;i&lt;64;i++){<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; sb.append(pl(l, i));<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if((i+1)%4 ==0 &amp;&amp; split){<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; sb.append(“ “);<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; sb.append(“\r\n”);<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return sb.toString();<br><br>&nbsp;&nbsp;&nbsp; }<br><br>&nbsp;&nbsp;&nbsp; /<em>*<br><br>&nbsp;&nbsp;&nbsp;&nbsp; </em> 打印l 的从0开始第index位的数据<br><br>&nbsp;&nbsp;&nbsp;&nbsp; <em> @param l<br><br>&nbsp;&nbsp;&nbsp;&nbsp; </em> @param index<br><br>&nbsp;&nbsp;&nbsp;&nbsp; */<br><br>&nbsp;&nbsp;&nbsp; public static String pl(long l,int index){<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return (0x0000000000000001L &amp; (l&gt;&gt; (63-index)))+””;<br><br>&nbsp;&nbsp;&nbsp; }<br><br><br><br>&nbsp;&nbsp;&nbsp; public static void main(String[] args) throws Exception {<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //System.out.println(pl64(createMask(5,7)));<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; long val = 0;<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; val = setValue(val,15,3,6);<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; System.out.println(pl64(val));<br><br>&nbsp;&nbsp;&nbsp; }<br><p></p></div><p class="readmore"><a href="/2015/12/01/2015-12-01-Global_unique_key_plus/">Mehr lesen</a></p></div><div class="post"><h2 class="post-title"><a href="/2015/11/19/2014-11-19-TheLiveWayOfProcessor/">程序员的生存之道</a></h2><div class="post-meta">2015-11-19</div><a data-thread-key="2015/11/19/2014-11-19-TheLiveWayOfProcessor/" href="/2015/11/19/2014-11-19-TheLiveWayOfProcessor/#comments" class="ds-thread-count"></a><div class="post-content"><blockquote><br>  <p>大神在文章《程序员的心理疾病》里说：和程序员交往时不能谦虚，介绍自己的东西时一定要自豪，这就是世界上最好的，独一无二，没有任何人可以做到！</p><br>  <p>如果你想和一个程序员交朋友——灵魂深处的朋友，那么你必须在他最擅长精通的领域击败他、摧毁他的自信、践踏他的智商，让他有一种见到你就自惭形秽恨不得从幼儿园开始重读一遍的绝望。</p><br>  <p>就这样，这些年交了很多朋友，也被很多人交了朋友。似乎每一个程序员都是这么走出来的，交朋友与被交朋友，然后从火坑里站起来继续。说起来，这就是程序员的生存之道。 </p><br></blockquote></div><p class="readmore"><a href="/2015/11/19/2014-11-19-TheLiveWayOfProcessor/">Mehr lesen</a></p></div><div class="post"><h2 class="post-title"><a href="/2015/10/27/2015-10-29-Global_unique_key/">[KANMARS原创] - 分布式系统一致性hash中的key-全局唯一ID生成器</a></h2><div class="post-meta">2015-10-27</div><a data-thread-key="2015/10/27/2015-10-29-Global_unique_key/" href="/2015/10/27/2015-10-29-Global_unique_key/#comments" class="ds-thread-count"></a><div class="post-content"><p><br>    分布式系统一致性hash中的key<br></p><br><p><br>    –曾经和公司一个大神讨论分布式系统架构，提起一致性hash，他曾经给介绍了一种一致性hashkey的生成方式，例如一个long型数据，第0位存标志位，1-8位存放国家，9-16位存放省，17-24位存放城市，25-27位存放机房编号，28-30位存放集群编号，31-38存放物理机实例编号……….最终生成的一致性hash再通过环形hash空间完成负载均衡，借此实现高并发系统。<br></p><br><p><br>    <br><br></p><br><p><br>    万事都是想起来容易，做起来难。<br></p><br><p><br>    例如分布式系统一致性hash的全局ID生成器，前段时间公司貌似需要写一个，由于项目紧张，我们直接使用的是创建的一个NumberCreateUtil的简版工具类。<br></p><br><p><br>    “粗略的”实现了全局唯一ID生成，<br></p><br><p><br>    <br><br></p><br><p><br>    近日进行了反省，是因为“没有技术积累”，例如一些简单的工具没有，比如全局唯一ID生成器，例如短链接生成器之类的。<br></p><br><p><br>    <br><br></p><br><p><br>    因此写了一个全局ID生成器+long数据可见性转换工具。<br></p><br><p><br>    大概原理是：传入时间，国家，城市，集群，机器，随机数，用户ID，生成一个long数据，可以作为一致性Hash的唯一的key<br></p><br><p><br>    代码如下：<br></p><br><p><br>    ——————————————————————————-IDCreaterUtils——————————————————————————————————<br></p><br><p><br>    import java.util.ArrayList;<br><br>import java.util.Date;<br><br>import java.util.List;<br><br><br><br>/<strong><br><br>&nbsp;<em> ID生成器<br><br>&nbsp;</em> @author baolong<br><br>&nbsp;<em><br><br>&nbsp;</em>/<br><br>public class IDCreaterUtils {<br><br><br><br>&nbsp;&nbsp; &nbsp;/</strong><br><br>&nbsp;&nbsp; &nbsp; <em> 系统创建时间<br><br>&nbsp;&nbsp; &nbsp; </em>/<br><br>&nbsp;&nbsp; &nbsp;public static final long BEGIN_TM = new Date(115,9,10).getTime();//<br><br><br><br>&nbsp;&nbsp; &nbsp;/<strong>正负号掩码，0位为0，其余为1*/<br><br>&nbsp;&nbsp; &nbsp;public static long MASK_FLAG = 0x7FFFFFFFFFFFFFFFL;<br><br><br><br>&nbsp;&nbsp; &nbsp;/</strong><br><br>&nbsp;&nbsp; &nbsp; <em> 所有掩码之和为0x7FFFFFFFFFFFFFFFL;<br><br>&nbsp;&nbsp; &nbsp; </em>/<br><br>&nbsp;&nbsp; &nbsp;/<strong>时间掩码，长度29，范围限定[0-536870912]，[1-29]位为1，其余为0，秒为单位，够用17年*/<br><br>&nbsp;&nbsp; &nbsp;public static long MASK_TIME= 0x7FFFFFFC00000000L;<br><br>&nbsp;&nbsp; &nbsp;/</strong>国家掩码，长度3，范围限定[0-8]，[30-32]位为1，其余为0<em>/<br><br>&nbsp;&nbsp; &nbsp;public static long MASK_COUNTRY=0x0000000380000000L;<br><br>&nbsp;&nbsp; &nbsp;/**城市掩码，长度6，范围限定[0-63]，[33-38]位为1，其余为0</em>/<br><br>&nbsp;&nbsp; &nbsp;public static long MASK_CITY = 0x000000007E000000L;<br><br>&nbsp;&nbsp; &nbsp;/<strong>集群掩码，长度2，范围限定[0-3]，[39-40]位为1，其余为0*/<br><br>&nbsp;&nbsp; &nbsp;public static long MASK_CLUSTER = 0x0000000001800000L;<br><br>&nbsp;&nbsp; &nbsp;/</strong>机器掩码，长度6，范围限定[0-63]，[41-46]位为1，其余为0<em>/<br><br>&nbsp;&nbsp; &nbsp;public static long MASK_MACHINE = 0x00000000007E0000L;<br><br>&nbsp;&nbsp; &nbsp;/**随机数掩码，长度7，范围限定[0-127]，[47-53]位为1，其余为0</em>/<br><br>&nbsp;&nbsp; &nbsp;public static long MASK_RANDOM = 0x000000000001FC00L;<br><br>&nbsp;&nbsp; &nbsp;/<strong>用户ID掩码，长度10，[54-63]位为1，其余为0*/<br><br>&nbsp;&nbsp; &nbsp;public static long MASK_USER = 0x00000000000003FFL;<br><br><br><br><br><br>&nbsp;&nbsp; &nbsp;/</strong><br><br>&nbsp;&nbsp; &nbsp; <em> 64位ID生成器，正数<br><br>&nbsp;&nbsp; &nbsp; </em> @param time&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;时间，[1-29]位，长度29，范围限定[0-536870912]，以秒为单位，够用17年，如果该参数传递为0，则默认使用当前时间<br><br>&nbsp;&nbsp; &nbsp; <em> @param country&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;国家，[30-32]位，长度3，范围限定[0-8]<br><br>&nbsp;&nbsp; &nbsp; </em> @param city&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;城市，[33-38]位，长度6，范围限定[0-63]<br><br>&nbsp;&nbsp; &nbsp; <em> @param cluster&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;集群，[39-40]位，长度2，范围限定[0-3]<br><br>&nbsp;&nbsp; &nbsp; </em> @param machine&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;机器，[41-46]位，长度6，范围限定[0-63]<br><br>&nbsp;&nbsp; &nbsp; <em> @param random&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;随机数，[47-53]位，长度7，范围限定[0-127]<br><br>&nbsp;&nbsp; &nbsp; </em> @param user&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;用户ID尾数，[54-63]位，长度10，范围限定[0-1023]<br><br>&nbsp;&nbsp; &nbsp; <em> @return<br><br>&nbsp;&nbsp; &nbsp; </em>/<br><br>&nbsp;&nbsp; &nbsp;public static long createId(long time,long country,long city,long cluster,long machine,long random,long user) throws Exception {<br><br>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;if(time&lt;0 || time &gt; 536870911 ){<br><br>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;throw new Exception(“time时间范围超出[0-536870912]”);<br><br>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;}<br><br>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;if(country&lt;0 || country&gt; 7){<br><br>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;throw new Exception(“国家范围超出[0-7]”);<br><br>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;}<br><br>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;if(city&lt;0 || city&gt; 63){<br><br>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;throw new Exception(“城市范围超出[0-63]”);<br><br>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;}<br><br>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;if(cluster&lt;0 || cluster&gt; 3){<br><br>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;throw new Exception(“集群范围超出[0-3]”);<br><br>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;}<br><br>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;if(machine&lt;0 || machine&gt; 63){<br><br>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;throw new Exception(“机器范围超出[0-63]”);<br><br>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;}<br><br>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;if(random&lt;0 || random&gt; 127){<br><br>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;throw new Exception(“随机数范围超出[0-127]”);<br><br>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;}<br><br>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;if(user&lt;0 || user&gt; 1023){<br><br>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;throw new Exception(“用户ID尾数范围超出[0-1023]”);<br><br>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;}<br><br>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;long result = 0;<br><br>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;long time_base = time;<br><br>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;if(time_base ==0){<br><br>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;time_base = (System.currentTimeMillis() - BEGIN_TM)/1000;<br><br>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;}<br><br>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;result = result | ((time_base &lt;&lt; (63 - 29)) &amp; MASK_FLAG );<br><br>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;result = result | ((country &lt;&lt; (63 - 32)) &amp; MASK_COUNTRY );<br><br>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;result = result | ((city &lt;&lt; (63 - 38)) &amp; MASK_CITY );<br><br>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;result = result | ((cluster &lt;&lt; (63 - 40)) &amp; MASK_CLUSTER );<br><br>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;result = result | ((machine &lt;&lt; (63 - 46)) &amp; MASK_MACHINE );<br><br>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;result = result | ((random &lt;&lt; (63 - 53)) &amp; MASK_RANDOM );<br><br>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;result = result | ( user &amp; MASK_USER );<br><br>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;return result;<br><br>&nbsp;&nbsp; &nbsp;}<br><br><br><br>&nbsp;&nbsp; &nbsp;/<strong><br><br>&nbsp;&nbsp; &nbsp; <em> 传入一个ID，解析为LONG数组<br><br>&nbsp;&nbsp; &nbsp; </em> @param id<br><br>&nbsp;&nbsp; &nbsp; <em> @return<br><br>&nbsp;&nbsp; &nbsp; </em> new long[]{<br><br>&nbsp;&nbsp; &nbsp; <em> time,<br><br>&nbsp;&nbsp; &nbsp; </em> country,<br><br>&nbsp;&nbsp; &nbsp; <em> city,<br><br>&nbsp;&nbsp; &nbsp; </em> cluster,<br><br>&nbsp;&nbsp; &nbsp; <em> machine,<br><br>&nbsp;&nbsp; &nbsp; </em> random,<br><br>&nbsp;&nbsp; &nbsp; <em> user<br><br>&nbsp;&nbsp; &nbsp;};<br><br>&nbsp;&nbsp; &nbsp; </em> @throws Exception<br><br>&nbsp;&nbsp; &nbsp; */<br><br>&nbsp;&nbsp; &nbsp;public static long[] parseId(long id) throws Exception {<br><br>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;long time=0;<br><br>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;long country=0;<br><br>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;long city=0;<br><br>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;long cluster=0;<br><br>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;long machine=0;<br><br>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;long random=0;<br><br>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;long user=0;<br><br>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;time &nbsp;&nbsp; &nbsp;= id &gt;&gt; (63 - 29) &amp; 0x0000000001FFFFFFL;<br><br>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;country = id &gt;&gt; (63 - 32) &amp; 0x0000000000000007L;<br><br>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;city &nbsp;&nbsp; &nbsp;= id &gt;&gt; (63 - 38) &amp; 0x000000000000003FL;<br><br>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;cluster = id &gt;&gt; (63 - 40) &amp; 0x0000000000000003L;<br><br>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;machine = id &gt;&gt; (63 - 46) &amp; 0x000000000000003FL;<br><br>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;random &nbsp;&nbsp; &nbsp;= id &gt;&gt; (63 - 53) &amp; 0x000000000000007FL;<br><br>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;user &nbsp;&nbsp; &nbsp;= id&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &amp; 0x00000000000003FFL;<br><br>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;return new long[]{<br><br>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;time,<br><br>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;country,<br><br>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;city,<br><br>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;cluster,<br><br>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;machine,<br><br>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;random,<br><br>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;user<br><br>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;};<br><br>&nbsp;&nbsp; &nbsp;}<br><br><br><br>&nbsp;&nbsp; &nbsp;/</strong><br><br>&nbsp;&nbsp; &nbsp; <em> 打印一个long的二进制码，不分割<br><br>&nbsp;&nbsp; &nbsp; </em> @param l<br><br>&nbsp;&nbsp; &nbsp; <em> @return<br><br>&nbsp;&nbsp; &nbsp; </em>/<br><br>&nbsp;&nbsp; &nbsp;public static String pl64(long l){<br><br>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;return pl64(l,false);<br><br>&nbsp;&nbsp; &nbsp;}<br><br>&nbsp;&nbsp;&nbsp; &nbsp;/<strong><br><br>&nbsp;&nbsp; &nbsp; <em> 打印一个long的二进制码<br><br>&nbsp;&nbsp; &nbsp; </em> @param l&nbsp;&nbsp; &nbsp;要打印的数值<br><br>&nbsp;&nbsp; &nbsp; <em> @param split&nbsp;&nbsp; &nbsp;是否每4位分割<br><br>&nbsp;&nbsp; &nbsp; </em> @return<br><br>&nbsp;&nbsp; &nbsp; */<br><br>&nbsp;&nbsp; &nbsp;public static String pl64(long l,boolean split){<br><br>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;StringBuilder sb = new StringBuilder();<br><br>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;for(int i=0;i&lt;64;i++){<br><br>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;sb.append(pl(l, i));<br><br>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;if((i+1)%4 ==0 &amp;&amp; split){<br><br>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;sb.append(“ “);<br><br>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;}<br><br>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;}<br><br>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;sb.append(“\r\n”);<br><br>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;return sb.toString();<br><br>&nbsp;&nbsp; &nbsp;}<br><br><br><br>&nbsp;&nbsp; &nbsp;/</strong><br><br>&nbsp;&nbsp; &nbsp; <em> 打印l 的从0开始第index位的数据<br><br>&nbsp;&nbsp; &nbsp; </em> @param l<br><br>&nbsp;&nbsp; &nbsp; <em> @param index<br><br>&nbsp;&nbsp; &nbsp; </em>/<br><br>&nbsp;&nbsp; &nbsp;public static String pl(long l,int index){<br><br>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;return (0x0000000000000001L &amp; (l&gt;&gt; (63-index)))+””;<br><br>&nbsp;&nbsp; &nbsp;}<br><br><br><br>&nbsp;&nbsp; &nbsp;/<strong><br><br>&nbsp;&nbsp; &nbsp; <em> 掩码创建工具，传递一个int数组，生成的掩码字符串会将该int中的位设置为1<br><br>&nbsp;&nbsp; &nbsp; </em> 例如System.out.println(createMask(63,62));，返回结果为0x0000000000000003L<br><br>&nbsp;&nbsp; &nbsp; <em> @param cc<br><br>&nbsp;&nbsp; &nbsp; </em> @return<br><br>&nbsp;&nbsp; &nbsp; */<br><br>&nbsp;&nbsp; &nbsp;public static String createMask(int … cc){<br><br>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;StringBuilder sb = new StringBuilder();<br><br>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;for(int i=0;i&lt; 64;i++){<br><br>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;String s_v = “0”;<br><br>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;for(int idx : cc){<br><br>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;if(idx == i){<br><br>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;s_v = “1”;<br><br>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;break;<br><br>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;}<br><br>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;}<br><br>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;sb.append(s<em>v);<br><br>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;}<br><br>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;String str = sb.toString();<br><br>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;StringBuilder sb1= new StringBuilder();<br><br>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;sb1.append(“0x”);<br><br>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;for (int i=0;i&lt;64;i+=4){<br><br>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;if(str.substring(i,i+4).equals(“0000”)){<br><br>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;sb1.append(“0”);<br><br>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;}else if(str.substring(i,i+4).equals(“0001”)){<br><br>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;sb1.append(“1”);<br><br>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;}else if(str.substring(i,i+4).equals(“0010”)){<br><br>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;sb1.append(“2”);<br><br>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;}else&nbsp; if(str.substring(i,i+4).equals(“0011”)){<br><br>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;sb1.append(“3”);<br><br>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;}else if(str.substring(i,i+4).equals(“0100”)){<br><br>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;sb1.append(“4”);<br><br>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;}else if(str.substring(i,i+4).equals(“0101”)){<br><br>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;sb1.append(“5”);<br><br>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;}else if(str.substring(i,i+4).equals(“0110”)){<br><br>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;sb1.append(“6”);<br><br>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;}else if(str.substring(i,i+4).equals(“0111”)){<br><br>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;sb1.append(“7”);<br><br>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;}else if(str.substring(i,i+4).equals(“1000”)){<br><br>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;sb1.append(“8”);<br><br>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;}else if(str.substring(i,i+4).equals(“1001”)){<br><br>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;sb1.append(“9”);<br><br>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;}else if(str.substring(i,i+4).equals(“1010”)){<br><br>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;sb1.append(“A”);<br><br>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;}else if(str.substring(i,i+4).equals(“1011”)){<br><br>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;sb1.append(“B”);<br><br>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;}else if(str.substring(i,i+4).equals(“1100”)){<br><br>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;sb1.append(“C”);<br><br>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;}else if(str.substring(i,i+4).equals(“1101”)){<br><br>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;sb1.append(“D”);<br><br>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;}else if(str.substring(i,i+4).equals(“1110”)){<br><br>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;sb1.append(“E”);<br><br>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;}else if(str.substring(i,i+4).equals(“1111”)){<br><br>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;sb1.append(“F”);<br><br>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;}<br><br>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;}<br><br>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;sb1.append(“L”);<br><br>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;return sb1.toString();<br><br>&nbsp;&nbsp; &nbsp;}<br><br><br><br>&nbsp;&nbsp; &nbsp;public static void main(String[] args) throws Exception {<br><br>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;//生成指定目标位的掩码<br><br>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;//System.out.println(createMask(54, 55, 56, 57, 58, 59, 60, 61, 62, 63));<br><br>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;//创建id示例<br><br>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;long id = createId(0, 0, 1, 3, 16, 33, 777);<br><br>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;System.out.println(id);<br><br>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;//将ID生成短可见ID<br><br>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;String strid = LongTransfer.getStrFrom(id);<br><br>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;System.out.println(strid);<br><br>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;//从短可见ID生成long<br><br>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;long id</em> = LongTransfer.getLongFrom(strid);<br><br>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;System.out.println(id<em>);<br><br>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;//对ID进行反向解析<br><br>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;System.out.println(“开始反向解析”);<br><br>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;for(long l : parseId(id</em>)){<br><br>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;System.out.println(l);<br><br>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;}<br><br>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;//pl64(1);<br><br>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;//pl(1,63);<br><br>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;//System.out.println(createId(0,1,1,1,1,1,1,111));<br><br>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;//System.out.print(<br><br>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;//&nbsp;&nbsp; &nbsp;pl64(<br><br>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;//&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;MASK_TIME | MASK_COUNTRY | MASK_CITY | MASK_CLUSTER | MASK_MACHINE | MASK_RANDOM | MASK_USER<br><br>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;//&nbsp;&nbsp; &nbsp;)<br><br>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;//);<br><br>&nbsp;&nbsp; &nbsp;}<br><br><br><br><br><br>}<br></strong></p><br><p><br>    <br><br></p><br><p><br>    <br><br></p><br><p><br>    <br><br></p><br><p><br>    ——————————————————————————————————————————————————————————————————-<br></p><br><p><br>    ——————————————————————————-LongTransfer——————————————————————————————————<br></p><br><p><br>    import java.util.Date;<br><br><br><br>public class LongTransfer {<br><br>&nbsp;&nbsp; &nbsp;<br><br>&nbsp;&nbsp; &nbsp;/char 62 ,<br><br>&nbsp;&nbsp; &nbsp; <em> 用来处理62进制<br><br>&nbsp;&nbsp; &nbsp; </em>/<br><br>&nbsp;&nbsp; &nbsp;private static char[] info = {<br><br>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;’0’,’1’,’2’,’3’,’4’,’5’,’6’,’7’,’8’,’9’,<br><br>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;’A’,’B’,’C’,’D’,’E’,’F’,’G’,’H’,’I’,’J’,’K’,’L’,’M’,’N’,’O’,’P’,’Q’,’R’,’S’,’T’,’U’,’V’,’W’,’X’,’Y’,’Z’,<br><br>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;’a’,’b’,’c’,’d’,’e’,’f’,’g’,’h’,’i’,’j’,’k’,’l’,’m’,’n’,’o’,’p’,’q’,’r’,’s’,’t’,’u’,’v’,’w’,’x’,’y’,’z’,<br><br>&nbsp;&nbsp; &nbsp;};<br><br>&nbsp;&nbsp; &nbsp;<br><br>&nbsp;&nbsp; &nbsp;private static int jz<em> = 62;<br><br>&nbsp;&nbsp; &nbsp;<br><br>&nbsp;&nbsp; &nbsp;public static void main(String[] args) {<br><br>&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;System.out.println(new Date(100,11,31));<br><br>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;//long long的最大值：9223372036854775807<br><br>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;//long long的最小值：-9223372036854775808<br><br>//&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;System.out.println(getStrFrom(9223372036854775807l));//hezMo7<br><br>//&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;System.out.println(getLongFrom(“aZl8N0y58M7”));<br><br>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;<br><br>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;for(int i=0;i&lt;10;i++){<br><br>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;long date = new Date(100,11,31).getTime();//获取1900+300 = 2200年的时间<br><br>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;date = date/1000;<br><br>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;String str = getStrFrom(date);<br><br>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;long result = getLongFrom(str);<br><br>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;System.out.print(date+”&nbsp;&nbsp;&nbsp; “);<br><br>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;System.out.print(str+”&nbsp;&nbsp;&nbsp; “);<br><br>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;System.out.print(result+”&nbsp;&nbsp;&nbsp; “);<br><br>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;System.out.println(“&nbsp; “+(date==result?”true”:”false”));<br><br>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;try {<br><br>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;Thread.sleep(100);<br><br>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;} catch (InterruptedException e) {<br><br>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;e.printStackTrace();<br><br>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;}<br><br>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;}<br><br>&nbsp;&nbsp; &nbsp;}<br><br>&nbsp;&nbsp; &nbsp;public static String getStrFrom(long l){<br><br>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;StringBuffer sb = new StringBuffer();<br><br>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;if(l==0)return “0”;<br><br>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;int jz = jz</em>;<br><br>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;while(l/jz &gt;= 0){<br><br>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;if(l==0){<br><br>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;//sb.insert(0, info[0]);<br><br>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;break;<br><br>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;}<br><br>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;char c = info[(int)(l%jz)];<br><br>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;//System.out.println((int)(l%62));<br><br>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;sb.insert(0, c);<br><br>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;l=l/jz;<br><br>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;}<br><br>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;return sb.toString();<br><br>&nbsp;&nbsp; &nbsp;}<br><br>&nbsp;&nbsp; &nbsp;public static long getLongFrom(String str){<br><br>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;long result = 0;<br><br>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;int jz = jz_;<br><br>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;int strlength = str.length();<br><br>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;char[] cc = new char[strlength];<br><br>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;str.getChars(0, strlength, cc, 0);<br><br>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;for(int i=0,j=strlength;i&lt;j;i++ ){<br><br>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;int num = -1;<br><br>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;char c = cc[i];<br><br>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;if(‘0’&lt;=c&amp;&amp;c&lt;=’9’){<br><br>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;num = c-‘0’;<br><br>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;}<br><br>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;if(‘a’&lt;=c&amp;&amp;c&lt;=’z’){<br><br>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;num = c-‘a’+10;<br><br>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;}<br><br>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;if(‘A’&lt;=c&amp;&amp;c&lt;=’Z’){<br><br>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;num = c-‘A’+36;<br><br>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;}<br><br>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;//System.out.println(num);<br><br>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;result = result*jz + num;<br><br>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;}<br><br>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;return result;<br><br>&nbsp;&nbsp; &nbsp;}<br><br>}<br></p><br><p><br>    ——————————————————————————————————————————————————————————————————-<br></p><br><p><br>    <br><br></p><br><p><br>    <br><br></p><br><p><br>    <br><br></p><br><p><br>    <br><br></p></div><p class="readmore"><a href="/2015/10/27/2015-10-29-Global_unique_key/">Mehr lesen</a></p></div><div class="post"><h2 class="post-title"><a href="/2015/10/27/2015-10-27-Spring_AOP/">[KANMARS原创] - Spring 源码解析-AOP的实现</a></h2><div class="post-meta">2015-10-27</div><a data-thread-key="2015/10/27/2015-10-27-Spring_AOP/" href="/2015/10/27/2015-10-27-Spring_AOP/#comments" class="ds-thread-count"></a><div class="post-content"><p></p><p><br>    Spring 源码解析-AOP的实现<br></p><p></p>
<p></p><p><br>    <br><br></p><p></p>
<p></p><p><br>    1、spring通过自带的插件机制实现NameSpaceHandler处理xml配置<br></p><br>&nbsp;&nbsp;&nbsp;&nbsp;遇到&lt;AOP:&gt;标签，交给<br><br>&nbsp;&nbsp;&nbsp;&nbsp;AopNameSpaceHandler进行执行<br><p></p></div><p class="readmore"><a href="/2015/10/27/2015-10-27-Spring_AOP/">Mehr lesen</a></p></div><div class="post"><h2 class="post-title"><a href="/2015/10/19/2015-10-19-Spring_BeanDefinition/">[KANMARS原创] - Spring 源码解析-BeanDefinition</a></h2><div class="post-meta">2015-10-19</div><a data-thread-key="2015/10/19/2015-10-19-Spring_BeanDefinition/" href="/2015/10/19/2015-10-19-Spring_BeanDefinition/#comments" class="ds-thread-count"></a><div class="post-content"><p><br>    Spring源码解析<br></p><br><p><br>    Spring BeanDefinition结构<br></p><br><p><br>    <br><br></p><br><p><br>    <br><br></p><br><p><br>    SpringBeanDefinition是一个重要的结构，在spring初始化的时候，ApplicationContext在加载DefaultListableBeanFactory时，会对Spring的xml配置文件进行解析，将每一个标记生成一个BeanDefinition，然后封装为BeanDefinitionHolder，最终存放在DefaultListableBeanFactory中<br></p><br><p><br>    <br><br></p><br><p><br>    下图是BeanDefinition的结构图<br></p><br><p><br>    <img src="http://kanmars.github.io/images/photo/20151019/BeanDifinition.png" alt=""><br></p><br><p><br>    可以看到BeanDefinition其实就是一个配置项生成的Bean的定义<br></p><br><p><br>    最常用的BeanDefinition是GenericBeanDefinition<br></p><br><p><br>    而属性在BeanDefinition中是以PropertiesValue的形式存在的，<br></p><br><p><br>    每一个PropertiesValue含有两个关键的属性<br></p><br><p><br>    name，即名称<br></p><br><p><br>    value，即对应的值，对应的值可能是如下几种类型：<br></p><br><p><br>    TypedStringValue&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 字符串<br></p><br><p><br>    RuntimeBeanReference&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 运行时Bean指向<br></p><br><p><br>    BeanDefition&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 另一个BeanDefition<br></p><br><p><br>    Ref&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 动态生成运行时Bean指向<br></p><br><p><br>    idRef&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; RuntimeBeanNameReference<br></p><br><p><br>    ManagedArray&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; array<br></p><br><p><br>    ManagedList&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; list<br></p><br><p><br>    ManagedSet&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; set<br></p><br><p><br>    ManagedMap&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; map<br></p><br><p><br>    ManagedProperties&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; properties<br></p><br><p><br>    <br><br></p><br><p><br>    ————————————————————————————————————————————————<br></p><br><p><br>    请期待下一集BeanDefinition的合并<br></p><br><p><br>    ————————————————————————————————————————————————<br></p><br><p><br>    在BeanDefinition中有这么几个很混淆的定义：<br></p><br><p><br>    GenericBeanDefinition<br></p><br><p><br>    AbstractBeanDefinition<br></p><br><p><br>    <br><br></p><br><pre>RootBeanDefinition<br>在最开始解析一个Spring标签时，生成的是一个GenericBeanDefinition，并注册到BeanFactory中<br>在BeanDefinition进行实例化时，会调用AbstractBeanFactory.getMergedBeanDefition方法获取到合并的BeanDefition，即RootBeanDefinition<br><br>，在生成RootBeanDefinition时，会传入parentBeanDefinition<br><pre>mbd = <span style="color:#000080;font-weight:bold;">new </span>RootBeanDefinition(parentBeanDefinition);<br><br>在RootBeanDefinition的构造方法中，会调用各种方法，将parentBeanDefinition的属性放到RootBeanDefinition中<br><br>这样就形成了BeanDefinition和parentBeanDefinition的合并merge机制。<br>最终获取到的即是RootBeanDefinition<br>之后再根据RootBeanDefinition对Bean进行实例化。<br><br></pre><br></pre><br><p><br>    <br><br></p><br><p><br>    <br><br></p><br><p><br>    <br><br></p></div><p class="readmore"><a href="/2015/10/19/2015-10-19-Spring_BeanDefinition/">Mehr lesen</a></p></div><div class="post"><h2 class="post-title"><a href="/2015/09/25/2015-09-25-XIANGMUZONGJIE/">[KANMARS原创] - 近期项目经验总结</a></h2><div class="post-meta">2015-09-25</div><a data-thread-key="2015/09/25/2015-09-25-XIANGMUZONGJIE/" href="/2015/09/25/2015-09-25-XIANGMUZONGJIE/#comments" class="ds-thread-count"></a><div class="post-content"><p><br></p>
<p><br>    项目经验总结<br></p><br><p><br>    总结方面：项目管理方面，技术方案方面<br></p><br><h3><br>    <strong>项目管理方面</strong><br></h3><br><p><br>    1、需求的确定<br></p><br><p><br>    &nbsp;&nbsp;&nbsp; 项目最忌讳需求不确定，如果需求不确定，会导致项目变动频繁，进而开发人员丧失信心，进而消极怠工，进而遥遥无期。<br></p><br><p><br>    &nbsp;&nbsp;&nbsp; 因此需求尽量要在最开始就确定。确定方式为：（1）确定系统建设目的（大需求）；（2）分模块确认需求；（3）分析需求和需求之间的关系；（4）确认业务流程。<br></p><br><p><br>    &nbsp;&nbsp;&nbsp; （1）确定系统建设目的：<br></p><br><p><br>    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 在项目中经常遇到这样的情况：主次不分。<br></p><br><p><br>    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;比如：某团队要建设一个**项目，项目如何开展？开发负责人一接手就开始建设各子系统：基础模块、监控模块、权限模块、数据分析模块……。三个月后，一堆基础的东西出来了，但是项目仍然不可使用，甚至连demo都没有，于是被无情开除。<br></p><br><p><br>    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 分析其问题，就是开发负责人主次不分。<span style="color:#E53333;background-color:#000000;"></span><br></p><br><p><br>    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;任何系统都有主要系统，也有次要系统。主要系统就好比是一个数字之前的1，而次要系统就是这个数字后面的0。如果主要系统都没弄好，次要系统再多也没有意义。<br></p><br><p><br>    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 因此，让主要系统可以运行显得无比重要。而指出哪些需求是主要系统，哪些需求是次要系统，是开发负责人不可推卸的责任。<br></p><br><p><br>    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 如何判断一个系统是主要的、还是次要的？<br></p><br><p><br>    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 必须要深入了解系统建设目的，然后按照如下几步来筛选：<br></p><br><p><br>    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; a、如果缺少它无法完成建设目的，则该系统是主要系统，剩下的是次要系统。<br></p><br><p><br>    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; b、如果增加该系统可以大大提高建设目的的成功率，则该系统是主要系统。<br></p><br><p><br>    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; c、如果增加该系统在近期内无法体现出足够有效的效果，则该系统是次要系统。<br></p><br><p><br>    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 经过如此筛选，则一个项目中能列入主需求的，估计只剩原需求的20%，成功率提升80%。<br></p><br><p><br>    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;总结其经验：<span style="color:#E53333;background-color:#000000;">先让程序能用，接着让程序好用，再让程序员轻松，最后再让项目脱离了任何人都能稳定运行。</span><br></p><br><p><br>    &nbsp;&nbsp;&nbsp; （2）分模块确认需求<br></p><br><p><br>    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 在对系统的主次进行区分后，然后才是对分模块进行细致的确认<br></p><br><p><br>    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 在这个方面，需要根据业务流程进行分析，正确的业务流程是模块流程的基础。<br></p><br><p><br>    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 这个阶段的要点是：让必须业务人员参与的工作减至最少。<br></p><br><p><br>    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 因为从稳定性上说，系统内部流程远远大于人工操作。<br></p><br><p><br>    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 于是我们得到一个推论：<span style="background-color:#000000;color:#E53333;">为了系统稳定，必须尽可能的让系统自动化实现一切功能，避免人工参与。所以，必须了解子模块在一个标准业务流程中的具体功能和详细步骤。</span><br></p><br><p><br>    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 如果一个模块特别复杂，则把模块进行切分，切成两个、三个独立的异步的小模块。<br></p><br><p><br>    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 模块的失败，源于模块的复杂；模块的复杂，源于模块切分的不合理；模块切分的不合理，源于开发负责人对系统需求的把握不足。<br></p><br><p><br>    &nbsp;&nbsp;&nbsp; （3）分析需求和需求之间的关系<br></p><br><p><br>    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 在模块划分好之后，最害怕的是关联模块的影响。<br></p><br><p><br>    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 比如我们在第二步，把某个大的模块，切割成了A，B，C三个模块，那么这三个模块就是关联的，如果对某模块进行修改，则可能会影响一大片的需求。<br></p><br><p><br>    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 如果想避免对模块的修改导致整个系统的大改，则开发负责人必须对需求和需求之间的关系理清，条件反射程度的明白改一个小模块会对其他模块造成什么毁灭性的影响。<br></p><br><p><br>    &nbsp;&nbsp;&nbsp; （4）确认业务流程<br></p><br><p><br>    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 在系统建设目的，分模块确认需求，分析需求和需求之间的关系后。我们得到了一堆合理合法的积木。<br></p><br><p><br>    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 接下来需要做的就是要把这堆积木合理的组装起来，这就是业务流程的重要性，<span style="background-color:#000000;color:#E53333;">业务流程是锁链，正确的业务流程才能把需求联合起来</span>。<br></p><br><p><br>    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; PS：曾经有同事和我争论面向过程和面向对象的优劣，进而讨论我们的系统是应该以对象架构出现，还是以业务流程模型出现。<br></p><br><p><br>    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 我保留个人意见，因为类似思想的争论没有意义，如果有人争论面向过程、面对对象哪个好，我特别想告诉他，地球上还有面向函数、对称多处理、管道流、面向构件的架构、中间件技术、仓库风格……<br></p><br><p><br>    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 跳出“面向过程”和“面向对象”这狭小的两个点来看，争论这个是毫无意义的。<br></p><br><p><br>    <br><br></p><br><p><br>    2、项目开发模型的选型：<br></p><br><p><br>    &nbsp;&nbsp;&nbsp; 有不同的项目开发模型，常用的是瀑布模型，和近两年很火的敏捷开发。此外还有很多其他的模型，例如极限编程、统一过程等。<br></p><br><p><br>    &nbsp;&nbsp;&nbsp; 我之前是瀑布模型和统一过程的信众，内心中深深的鄙视敏捷开发，直到今天早上才想开，原来我错了，大家都错了……<br></p><br><p><br>    &nbsp;&nbsp;&nbsp; <span style="background-color:#000000;color:#E53333;">没有最好的开发模型：项目的大小与复杂度，决定了项目适合用的开发模型。</span><br></p><br><p><br>    &nbsp;&nbsp;&nbsp;&nbsp;<span style="background-color:#000000;color:#E53333;">大而复杂的项目，必须使用瀑布模型</span>：严格从需求分析、概要设计、详细设计、测试、试运行、正式上线；<br></p><br><p><br>    &nbsp;&nbsp;&nbsp;&nbsp;<span style="background-color:#000000;color:#E53333;">中等规模的项目适合于统一过程</span>：用例驱动、以基本架构为中心、迭代和增量。UP是一个不停迭代的过程。初始、细化、构建、交付。<br></p><br><p><br>    &nbsp;&nbsp;&nbsp; <span style="background-color:#000000;color:#E53333;">小规模的项目适合于敏捷开发</span>：开发人员和业务专家紧密协作、面对面沟通、频繁交付新的软件版本、紧凑和自我组织型团队。<br></p><br><p><br>    <br><br></p><br><p><br>    &nbsp;&nbsp;&nbsp; 人是活着的人，最忌讳的是死板，没有任何一个项目是按照开发模型一步一步走就可以成功的。否则世界上不会有这么多失败的项目。<br></p><br><p><br>    &nbsp;&nbsp;&nbsp; 根据项目规模、难度来选择瀑布模型，还是统一过程、或者敏捷开发。（合格项目经理的水准）<br></p><br><p><br>    &nbsp;&nbsp;&nbsp; 然后再灵活一点，以统一过程为基准，根据项目的困难度选择自己更像瀑布模型一些，还是更像敏捷开发一些。（高级项目经理水准）<br></p><br><p><br>    &nbsp;&nbsp;&nbsp; 根据项目的进度，随时调整项目规模，调整开发模型，同时保持团队的稳定性和凝聚力，保持项目的目标统一。（顶级项目经理水准）<br></p><br><p><br>    &nbsp;&nbsp;&nbsp;<br></p><br><p><br>    &nbsp;&nbsp;&nbsp; 同时一定要避免陷入如下境地：“为灵活而灵活”、“为了灵活而放弃了一切、乃至癫狂甚至猖狂”、“为了灵活甚至放弃了自己的底线”<br></p><br><p><br>    <br><br></p><br><p><br>    3、项目的优先度问题<br></p><br><p><br>    &nbsp;&nbsp;&nbsp; 项目是有优先度的。每个人都有每个人的认识和见解。<br></p><br><p><br>    &nbsp;&nbsp;&nbsp; 我的理解如下：优先度是可以变化的，随着时期或者环境的变化、优先度可以随时调整。<br></p><br><p><br>    &nbsp;&nbsp;&nbsp; 在今年早些时候，我的优先度是：项目进度&gt;程序员开心度&gt;项目的完整度&gt;项目的合理性<br></p><br><p><br>    &nbsp;&nbsp;&nbsp; 而现在这个时间，我的优先度是：项目的稳定性&gt;项目的合理性&gt;程序员开心度&gt;项目的完整度&gt;项目进度 &nbsp;&nbsp;&nbsp;<br></p><br><p><br>    &nbsp;&nbsp;&nbsp;<br></p><br><p><br>    &nbsp;&nbsp;&nbsp; 可以看到，早期我把项目的稳定性彻底抛弃了，这是环境、人员、条件限制下不得不做出的牺牲。因此没少和测试部门打仗—各种环境不稳定、各种随时重启、各种404和500。<br></p><br><p><br>    &nbsp;&nbsp;&nbsp; 而在后期，随着各个环境、人员、资源问题的解决，对项目的优先度进行了重新排序，把我们可以顾及到的东西都排到了优先度里。<br></p><br><p><br>    <br><br></p><br><p><br>    &nbsp;&nbsp;&nbsp; 优先度的调整、是受整体环境影响的，需要根据环境的变化而变化。<br></p><br><p><br>    &nbsp;&nbsp;&nbsp; <span style="background-color:#000000;color:#E53333;">我们必须有一个信念，在有机会做的更好的时候，我们一定要追求极致。体现在优先度上，就是资源充足的情况下，排在项目进度之前的内容会逐步增加。</span><br></p><br><p><br>    <br><br></p><br><p><br>    4、人员开心问题<br></p><br><p><br>    &nbsp;&nbsp;&nbsp; 俗话说：有钱难买爷高兴。<br></p><br><p><br>    &nbsp;&nbsp;&nbsp; 人员的开心度、最终会成为团队稳定性的关键指标。<br></p><br><p><br>    &nbsp;&nbsp;&nbsp; 如何保持团队的开心度，莫过于“团队源源不断的成功”+“己所不欲勿施于人”<br></p><br><p><br>    <br><br></p><br><p><br>    <br><br></p><br><h3><br>    <strong>技术方案方面</strong><br></h3><br><p><br>    <br><br></p><br><p><br>    我必须承认：早期我们是走了弯路的，因此我们有一堆BUG要修改。其根本原因在于早期我们的无知和短视。 &nbsp;&nbsp;<br></p><br><p><br>    同时我也必须声明：与过去相比，我们确实走在直线上；但与未来比较，我们一定是从一条弯路走进了另一条稍直的弯路。<br></p><br><p><br>    上周六我看到一句话：“未来不能靠空想出来，而是只能通过对过去不停的批判，总结经验与教训，一步一步走向未来”<br></p><br><p><br>    我深以为然。<br></p><br><p><br>    程序架构是不能空想的，我们必须批判自己的过去，多多阅读同行的尝试，从同行的尝试中吸取经验与教训，改进我们自身，然后才能逐步进化。<br></p><br><p><br>    显然，我们已经进化了一次，从CP模型进化到了伪AP模型—&gt;<span style="background-color:#000000;color:#E53333;">意味着我们还需要一次进化，从伪AP进化到真AP模型</span>。<br></p><br><p><br>    <br><br></p><br><p><br>    <span style="background-color:#000000;color:#E53333;">CAP理论</span><br></p><br><p><br>    参考<a href="http://blog.csdn.net/chen77716/article/details/30635543" target="_blank" rel="external">http://blog.csdn.net/chen77716/article/details/30635543</a><br></p><br><p><br>    参考<a href="http://blog.csdn.net/cutesource/article/details/5621725" target="_blank" rel="external">http://blog.csdn.net/cutesource/article/details/5621725</a><br></p><br><p><br>    在系统设计中有一个CAP理论，即在大型系统中，一致性C，可用性A，分区兼容性P，这三个属性只能同时满足其中的两个。<br></p><br><p><br>    <br><br></p><br><p><br>    所谓一致性Consistency，即是数据库理论ACID中的C，所有的数据都是一致的，没有冲突的。<br></p><br><p><br>    所谓可用性Availability，即是系统整体是高可用的。<br></p><br><p><br>    所谓分区容错性Partition Tolerance，就是一旦开始将数据和逻辑分布在不同的节点上，就有形成partition的风险。假定网线被切断，partition就形成了，节点A无法和节点B通讯。由<br>于Web提供的这种分布式能力，临时的partition是一个常见的情况，如之前说所的，在全球化的有多个数据中心的公司中这并不罕见。<br></p><br><p><br>    <br><br></p><br><p><br>    由于分区容错性P在系统建设中是必选的，那么我们的系统建设就只有两种选择：<br></p><br><p><br>    CP模型：放弃系统的可用性，而选择了一致性+分区容错性。<br></p><br><p><br>    AP模型：放弃了系统的搞一致性，而选择了高可用+分区容错性。<br></p><br><p><br>    <br><br></p><br><p><br>    <span style="background-color:#000000;color:#E53333;">业内目前的大型分布式系统多使用的是AP模型，即临时性的“放松”对系统一致性的要求，但是提升了系统的可用性和无限扩展性。</span><br></p><br><br><br><br><br><p><br>    <span style="background-color:#000000;color:#E53333;">金融部门早期技术方案</span><br></p><br><p><br>    早期由于各种限制，例如经验不足等原因。我们的系统结构是CP的，就是系统一致+分区容错。<br></p><br><p><br>    体现在代码结构上，就是：<br></p><br><p><br>    &nbsp;&nbsp;&nbsp; 1、web层直接对数据库进行操作。<br></p><br><p><br>    &nbsp;&nbsp;&nbsp; 2、数据库作为中央的逻辑处理，例如事务控制，任务锁定<br></p><br><p><br>    &nbsp;&nbsp;&nbsp; 3、用负载均衡提升应用层的可用性，用RAC提升数据库的可用性<br></p><br><p><br>    &nbsp;&nbsp;&nbsp; 4、使用分布式事务来处理多数据库问题<br></p><br><p><br>    对代码进行反思，其缺陷如下：<br></p><br><p><br>    &nbsp;&nbsp;&nbsp; 1、web层直接对数据库进行操作，可能导致数据库链接数成为web层的瓶颈，导致web层无法进行大规模横向扩展<br></p><br><p><br>    &nbsp;&nbsp;&nbsp; 2、数据库作为中央的逻辑处理，例如事务控制，金额控制，任务锁定等，会导致数据库的压力过大，在业务猛增时可能导致数据库瘫痪<br></p><br><p><br>    &nbsp;&nbsp;&nbsp; 3、分布式事务的二段提交，会导致<span style="background-color:#000000;color:#E53333;">可用性直线下降</span>，导致<span style="background-color:#000000;color:#E53333;">可扩展性指数级下降</span>。<br></p><br><p><br>    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;当系统需要横向扩展时，分布式事务会使每个数据库的不稳定性增加，进而形成<span style="background-color:#000000;color:#E53333;">指数级</span>下降可扩展性的惨剧。<br></p><br><p><br>    <span style="background-color:#000000;color:#E53333;">金融部门目前的技术方案</span><br></p><br><p><br>    金融部门目前的总体架构是：面向服务化、状态控制的异步任务处理的系统架构。<br></p><br><p><br>    与早期技术方案相比，最大的进化点在于，在架构中引入了面向服务化的内容。<br></p><br><p><br>    <br><br></p><br><p><br>    在代码结构上：<br></p><br><p><br>    &nbsp;&nbsp;&nbsp; 1、通过DUBBO服务化，将系统的前端和服务进行解耦，使得前端获得了近似无限的扩展能力。如果遇到大流量的业务扩展，通过增加前端服务器即可初步满足。<br></p><br><p><br>    &nbsp;&nbsp;&nbsp; 2、服务外观层的提出，使得系统结构可以将业务逻辑进行封装和组合，便于系统针对单独的服务进行横向扩展。<br></p><br><p><br>    &nbsp;&nbsp;&nbsp; 3、解决了历史遗留问题，代码趋于合理有序。<br></p><br><p><br>    但我们必须认识到还有如下问题没有解决：<br></p><br><p><br>    &nbsp;&nbsp;&nbsp; 1、数据库作为中央的逻辑处理，例如事务控制，金额控制，任务锁定等，会导致数据库的压力过大，在业务猛增时可能导致数据库瘫痪<br></p><br><p><br>    &nbsp;&nbsp;&nbsp; 2、数据库数据关联比较严重，有可能在将来拆分时会遇到较大问题。<br></p><br><p><br>    这些问题是我们需要在半年或者一年内解决的问题。<br></p><br><p><br>    <br><br></p><br><p><br>    如上文所说：一味的空想解决不了问题，我们必须从同行中寻找解决方案。<br></p><br><p><br>    <br><br></p><br><p><br>    <br><br></p><br><p><br>    我们需要学习一下ebay、taobao的解决方式，进而对我们的问题加以解决。<br></p><br><p><br>    <span style="background-color:#000000;color:#E53333;">ebay的可伸缩性实践</span><br></p><br><p><br>    &nbsp;&nbsp;&nbsp; 参见《可伸缩性最佳实践：来自ebay的经验》<a href="http://kb.cnblogs.com/page/157745/" target="_blank" rel="external">http://kb.cnblogs.com/page/157745/</a><br></p><br><p><br>    &nbsp;&nbsp;&nbsp;&nbsp;在一个可伸缩的架构中，资源的消耗应该随负载线性（或更佳）上升，负载可由用户流量、数据量等测量。如果说性能衡量的是每一工作单元所需的资源消耗，可伸缩性则是衡量当工作单元的数量或尺寸增加时，资源消耗的变化情况。换句话说，可伸缩性是整个价格-性能曲线的形状，而不是曲线上某一点的取值。<br></p><br><p><br>    &nbsp;&nbsp;&nbsp;&nbsp;可伸缩性有很多侧面——事务的方面、运营的方面、还有开发的方面。我们在改善一个Web系统的事务吞吐量的过程中学到了很多经验，本文总结了其中若<br>干关键的最佳实践。可能很多最佳实践你会觉得似曾相识，也可能有素未谋面的。这些都是开发和运营eBay网站的众人的集体经验结晶。<br></p><br><p><br>    &nbsp;&nbsp;&nbsp; <strong>最佳实践 #1：按功能分割：在编码层次，将代码分割为不同的jar、不同的包<strong>、</strong>不同的Bundle；在应用层次，将应用切割为不同的类型、如销售功能应用池、投标功能应用池，方便根据复杂独立对应用进行扩展；在数据库层次，将不同的数据放到不同的数据库中。</strong><br></p><br><p><br>    &nbsp;&nbsp;&nbsp;&nbsp;<strong>最佳实践 #2：水平切分：在应用层次，务必使每个应用都是无状态的，就可以轻而易举的使应用进行水平切分；在数据库层次略有难度，可以根据用户ID的mod，根据订单mod进行水平切分，把相同的数据，根据访问路径散列到不同的数据库中。<br><br></strong><br></p><br><p><br>    <strong>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 水平切分方案很多，例如：主键取模；区间分割；查找表；比较复杂的“全局唯一ID”+“一致性hash”；</strong><br></p><br><p><br>    &nbsp;&nbsp;&nbsp;&nbsp;<strong>最佳实践 #3：避免分布式事务：ebay是通过采用一些技术来帮助系统达到最终的一致性（eventual consistency）：周密调整数据库操作的次序、异步恢复事件，以及数据核对（reconciliation）或者集中决算（settlement batches）</strong><br></p><br><p><br>    <strong>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; taobao的方案是软事务，通过程序来实现了分布式事务。</strong><br></p><br><p><br>    <strong>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 通过放松系统的临时一致性，要求系统的最终一致性，就可以有效的提升系统的可伸缩性<br><br></strong><br></p><br><p><br>    &nbsp;&nbsp;&nbsp;&nbsp;<strong>最佳实践 #4：用异步策略解耦程序：把过程分解为阶段（stages or phases），然后将它们异步地连接起来，这是伸缩的关键。</strong><br></p><br><p><br>    &nbsp;&nbsp;&nbsp;&nbsp;<strong>最佳实践 #5：将过程转变为异步的流：任何可以晚点再做的事情都应该晚点再做。异步性可以从根本上降低基础设施的成本。将昂贵的处理过程转变为异步的流，基础设施就不需要按照峰值来配备，只需要满足平均负载。</strong><br></p><br><p><br>    &nbsp;&nbsp;&nbsp;&nbsp;<strong>最佳实践 #6：虚拟化所有层次：虚拟化和抽象化无所不在，计算机科学里有一句老话：所有问题都可以通过增加一个间接层次来解决。操作系统是对硬件的抽象，而许多现代语言所用的虚拟机又是对操作系统的抽象。</strong><br></p><br><p><br>    &nbsp;&nbsp;&nbsp;&nbsp;<strong>最佳实践 #7：适当地使用缓存：最适合缓存的是很少改变、以读为主的数据。</strong><br></p><br><p><br>    <strong>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;当你开始依赖于缓存，那么主要系统就只需要满足缓存未命中时的处理要求，自然而然你就会想到可以削减主要系统。</strong><br></p><br><p><br>    <strong>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;但当你这样做之后，系统就完全离不开缓存了。现在主要系统没办法直接应付全部流量，也就是说网站的可用性取决于缓存能否100%正常运行——潜在的危局。<br><br></strong><br></p><br><p><br>    &nbsp;&nbsp;&nbsp;&nbsp;<strong>《可伸缩性最佳实践：来自ebay的经验》的作者:</strong>Randy<br>Shoup&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 是eBay的杰出架构师。从2004年起担任eBay搜索基础设施的主要架构师。在加入eBay之前，他是Tumbleweed<br>Communications公司的总架构师，也曾在Oracle和Informatica担任多个软件开发和架构的职位。<br></p><br><p><br>    <br><br></p><br><p><br>    ———————————————————————————————————————————————————————————-<br></p><br><p><br>    以上就是我对最近项目的总结。<br></p><br><p><br>    <br><br></p></div><p class="readmore"><a href="/2015/09/25/2015-09-25-XIANGMUZONGJIE/">Mehr lesen</a></p></div><div class="post"><h2 class="post-title"><a href="/2015/09/01/2015-09-01-CPLUSPLUS_time/">[KANMARS原创] - C++学习_时间操作_002</a></h2><div class="post-meta">2015-09-01</div><a data-thread-key="2015/09/01/2015-09-01-CPLUSPLUS_time/" href="/2015/09/01/2015-09-01-CPLUSPLUS_time/#comments" class="ds-thread-count"></a><div class="post-content"><p><br>    C++时间使用<br></p><br><p><br>    <br><br></p><br><p><br>    <span style="background-color:#000000;color:#E53333;">一、时间和日期的概念</span><br></p><br><p><br>    <span style="color:#3e3e3e;"><span style="color:#3e3e3e;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span><span style="background-color:#000000;color:#E53333;">Coordinated Universal<br>Time（UTC）</span>：协调世界时，又称为世界标准时间，也就是大家所熟知的格林威治标准时间（Greenwich Mean<br>Time，GMT）。比如，中国内地的时间与UTC的时差为+8，也就是UTC+8。美国是UTC-5。 <br><br><br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <span style="background-color:#000000;color:#E53333;">Calendar<br>Time</span>：日历时间，是用“从一个标准时间点到此时的时间经过的秒数”来表示的时间。这个标准时间点对不同的编译器来说会有所不同，但对一个编译系统来<br>说，这个标准时间点是不变的，该编译系统中的时间对应的日历时间都通过该标准时间点来衡量，所以可以说日历时间是“相对时间”，但是无论你在哪一个时区，<br>在同一时刻对同一个标准时间点来说，日历时间都是一样的。 <br><br><br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <span style="background-color:#000000;color:#E53333;">epoch</span>：时间点。时间点在标准C/C++中是一个整数，它用此时的时间和标准时间点相差的秒数（即日历时间）来表示。 <br><br><br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <span style="background-color:#000000;color:#E53333;">clock tick</span>：时钟计时单元（而不把它叫做时钟滴答次数），一个时钟计时单元的时间长短是由CPU控制的。一个clock tick不是CPU的一个时钟周期，而是C/C++的一个基本计时单位。 <br><br><br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 我们可以使用ANSI标准库中的time.h头文件。这个头文件中定义的时间和日期所使用的方法，无论是在结构定义，还是命名，都具有明显的C语言风格。下面，我将说明在C/C++中怎样使用日期的时间功能。 <br><br></span><br></p><br><p><br>    <br><br><span style="color:#3e3e3e;"></span><br></p><br><p><br>    <span style="color:#3e3e3e;"><span style="background-color:#000000;color:#E53333;">二、</span><span style="color:#E53333;background-color:#000000;"><span style="color:#E53333;background-color:#000000;">计时函数</span></span></span><br></p><br><p><br>    <span style="color:#3e3e3e;"><span style="color:#3e3e3e;">C/C++中的计时函数是clock()，而与其相关的数据类型是clock_t。在MSDN中，查得对clock函数定义如下： <br><br><br><br>clock_t clock( void ); <br><br></span></span><br></p><br><p><br>    <span style="color:#3e3e3e;"><span style="color:#3e3e3e;"><span style="color:#3e3e3e;">这个函数返回从“开启这个程序进程”到“程序中调用clock()函数”时之间的CPU时钟计时单元（clock tick）数，</span></span></span><br></p><br><p><br>    <span style="color:#3e3e3e;"><span style="color:#3e3e3e;"><span style="color:#3e3e3e;"><br><br></span></span></span><br></p><br><p><br>    <span style="color:#3e3e3e;"><span style="color:#3e3e3e;"><span style="color:#3e3e3e;">可以用clock函数来计算你的机器运行一个循环或者处理其它事件到底花了多少时间</span></span></span><br></p><br><p><br>    <br><br><span style="color:#3e3e3e;"><span style="color:#3e3e3e;"><span style="color:#3e3e3e;"></span></span></span><br></p><br><p><br>    <span style="color:#E53333;background-color:#000000;"><span style="color:#E53333;background-color:#000000;"><span style="color:#E53333;background-color:#000000;">三、与日期和时间有关的函数</span></span></span><br></p><br><p><br>    <br><br><span style="color:#3e3e3e;"><span style="color:#3e3e3e;"><span style="color:#3e3e3e;"></span></span></span><br></p><br><p><br>    <span style="color:#3e3e3e;"><span style="color:#3e3e3e;"><span style="color:#3e3e3e;"><span style="color:#3e3e3e;">在标准C/C++中，我们可通过tm结构来获得日期和时间，tm结构在time.h中的定义如下： <br><br><br><br>#ifndef _TM_DEFINED <br><br>struct tm { <br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int tm_sec;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /<em> 秒 – 取值区间为[0,59] </em>/ <br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int tm_min;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /<em> 分 - 取值区间为[0,59] </em>/ <br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int tm_hour;&nbsp;&nbsp;&nbsp;&nbsp; /<em> 时 - 取值区间为[0,23] </em>/ <br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int tm_mday;&nbsp;&nbsp;&nbsp;&nbsp; /<em> 一个月中的日期 - 取值区间为[1,31] </em>/ <br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int tm_mon;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /<em> 月份（从一月开始，0代表一月） - 取值区间为[0,11] </em>/ <br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int tm_year;&nbsp;&nbsp;&nbsp;&nbsp; /<em> 年份，其值等于实际年份减去1900 </em>/ <br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br> int tm_wday;&nbsp;&nbsp;&nbsp;&nbsp; /<em> 星期 – 取值区间为[0,6]，其中0代表星期天，1代表星期一，以此推 </em>/int<br>tm_yday;&nbsp;&nbsp;&nbsp;&nbsp; /<em> 从每年的1月1日开始的天数 – 取值区间为[0,365]，其中0代表1月1日，1代表1月2日，以此类推 </em>/ <br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int tm_isdst;&nbsp;&nbsp;&nbsp; /<em> 夏令时标识符，实行夏令时的时候，tm_isdst为正。不实行夏令时的进候，tm_isdst为0；不了解情况时，tm_isdst()为负。</em>/ <br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }; <br><br></span></span></span></span><br></p><br><p><br>    <span style="color:#3e3e3e;"><span style="color:#3e3e3e;"><span style="color:#3e3e3e;"><span style="color:#3e3e3e;"><span style="color:#3e3e3e;">#define _TM_DEFINED <br><br>#endif <br><br></span></span></span></span></span><br></p><br><p><br>    <br><br><span style="color:#3e3e3e;"><span style="color:#3e3e3e;"><span style="color:#3e3e3e;"><span style="color:#3e3e3e;"><span style="color:#3e3e3e;"></span></span></span></span></span><br></p><br><p><br>    <span style="color:#3e3e3e;"><span style="color:#3e3e3e;"><span style="color:#3e3e3e;"><span style="color:#3e3e3e;"><span style="color:#3e3e3e;"><span style="color:#3e3e3e;">ANSI C标准称使用<span style="background-color:#000000;color:#E53333;">tm结构的这种时间表示为分解时间</span>(broken-down time)。&nbsp;</span></span></span></span></span></span><br></p><br><p><br>    <br><br></p><br><p><br>    <br><br></p><br><p><br>    <span style="color:#3e3e3e;">而<span style="background-color:#000000;color:#E53333;">日历时间（Calendar Time）是通过time_t数据类型来表示的</span>，用time_t表示的时间（日历时间）是从一个时间点（例如：1970年1月1日0时0分0秒）到此时的秒数。在time.h中，我们也可以看到time_t是一个长整型数： <br><br><br><br>#ifndef _TIME_T_DEFINED <br><br>typedef long time_t;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /<em> 时间值 </em>/ <br><br>#define _TIME_T_DEFINED&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /<em> 避免重复定义 time_t </em>/ <br><br>#endif </span><br><br><span style="color:#3e3e3e;"><span style="color:#3e3e3e;"><span style="color:#3e3e3e;"><span style="color:#3e3e3e;"><span style="color:#3e3e3e;"></span></span></span></span></span><br></p><br><p><br>    <br><br><span style="color:#3e3e3e;"><span style="color:#3e3e3e;"><span style="color:#3e3e3e;"><span style="color:#3e3e3e;"><span style="color:#3e3e3e;"></span></span></span></span></span><br></p><br><p><br>    <span style="color:#3e3e3e;">在time.h头文件中，我们还可以看到一些函数，它们都是以time_t为参数类型或返回值类型的函数： <br><br><br><br>double difftime(time_t time1, time_t time0); &nbsp;&nbsp;&nbsp; //计算时间的差，精度为秒<br><br>time_t mktime(struct tm <em> timeptr); &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //将分解时间struct_tm转化为日历时间time_t<br><br>time_t time(time_t </em> timer); &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //获取日历时间<br><br>char <em> asctime(const struct tm </em> timeptr); &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //从分解时间获取UTC<span style="color:#3e3e3e;">时间</span><br><br>char <em> ctime(const time_t </em>timer); &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //从日历时间获取UTC事件<br><br></span><br></p><br><p><br>    <span style="color:#3e3e3e;"><br><br></span><br></p><br><p><br>    <span style="color:#3e3e3e;">此外，time.h还提供了两种不同的函数<span style="background-color:#000000;color:#E53333;">将日历时间（一个用time_t表示的整数）转换为我们平时看到的把年月日时分秒分开显示的时间格式tm：</span> <br><br><br><br>struct tm <em> gmtime(const time_t </em>timer); &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <span style="color:#363636;">//与之相反是<span style="color:#3e3e3e;">time_t mktime(struct tm <em> timeptr); </em></span></span></span><br></p><br><p><br>    <span style="color:#3e3e3e;">&nbsp;</span><br></p><br><p><br>    <span style="color:#363636;">struct tm  localtime(const time_t <em> timer); &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //与之相反是<span style="color:#3e3e3e;">time_t mktime(struct tm </span></em> timeptr); </span><br></p><br><p><br>    <br><br></p><br><p><br>    <span style="color:#363636;">其中gmtime()函数是将日历时间转化为世界标准时间（即格林尼治时间），并返回一个<br>tm结构体来保存这个时间，</span><br></p><br><p><br>    <span style="color:#363636;">而localtime()函数是将日历时间转化为本地时间。比如现在用gmtime()函数获得的世界标准时间是2005年7月30日7点18分20秒，那么我用localtime()函数在中国地区获得的本地时间会比世界标准时间晚8个小时，即2005年7月30日15点18<br>分20秒。</span><br></p><br><p><br>    <span style="color:#363636;"></span>#include &lt;iostream&gt;<br><br>#include &lt;time.h&gt;<br><br><br><br>using namespace std;<br><br>int main (){<br><br>&nbsp;&nbsp;&nbsp; time_t t = time(NULL);<br><br>&nbsp;&nbsp;&nbsp; struct tm <em> local = localtime(&amp;t);<br><br><br><br>&nbsp;&nbsp;&nbsp; cout &lt;&lt; (local-&gt;tm_year + 1900) &lt;&lt; “年”&lt;&lt;endl;<br><br>&nbsp;&nbsp;&nbsp; cout &lt;&lt; (local-&gt;tm_mon + 1) &lt;&lt; “月”&lt;&lt;endl;<br><br>&nbsp;&nbsp;&nbsp; cout &lt;&lt; (local-&gt;tm_mday) &lt;&lt; “日”&lt;&lt;endl;<br><br>&nbsp;&nbsp;&nbsp; cout &lt;&lt; (local-&gt;tm_hour) &lt;&lt; “时”&lt;&lt;endl;<br><br>&nbsp;&nbsp;&nbsp; cout &lt;&lt; (local-&gt;tm_min) &lt;&lt; “分”&lt;&lt;endl;<br><br>&nbsp;&nbsp;&nbsp; cout &lt;&lt; (local-&gt;tm_sec) &lt;&lt; “秒”&lt;&lt;endl;<br><br>&nbsp;&nbsp;&nbsp; cout &lt;&lt; “星期” &lt;&lt; (local-&gt;tm_wday) &lt;&lt; “”&lt;&lt;endl;<br><br>&nbsp;&nbsp; &nbsp;<br><br>&nbsp;&nbsp; &nbsp;<br><br>}&nbsp;&nbsp; <br><br><br><br><span style="color:#3e3e3e;"></span><br></em></p><br><p><br>    <span style="color:#E53333;background-color:#000000;">四、时间格式转换</span><br></p><br><p><br>    <span style="color:#3e3e3e;">4.1&nbsp;&nbsp;&nbsp; 固定格式</span><br></p><br><p><br>    <span style="color:#3e3e3e;"><span style="color:#363636;">char  asctime(const struct tm <em> timeptr); <br><br>char </em> ctime(const time_t <em>timer); <br><br></em></span></span><br></p><br><p><br>    转化结果为：<br></p><br><p><br>    Tue Sep&nbsp; 1 06:39:08 2015<br><br><br><br>Tue Sep&nbsp; 1 06:39:08 2015<br></p><br><p><br>    <br><br></p><br><p><br>    4.2&nbsp;&nbsp;&nbsp; 自定义时间格式<br></p><br><p><br>    <br><br></p><br><p><br>    <span style="color:#363636;">我们可以使用strftime（）函数将时间格式化为我们想要的格式。它的原型如下： <br><br><br><br>size_t strftime( <br><br>&nbsp;&nbsp;&nbsp; char strDest, <br><br>&nbsp;&nbsp;&nbsp; size_t maxsize，</span><br></p><br><p><br>    <span style="color:#363636;">const char <em>format, <br><br>&nbsp;&nbsp;&nbsp; const struct tm </em>timeptr&nbsp;&nbsp;<br><br>); <br><br></span><br></p><br><p><br>    <span style="color:#363636;">示例如下</span><br></p><br><p><br>    <br><br><span style="color:#363636;"></span><br></p><br><p><br>    <span style="color:#363636;"><span style="color:#363636;">char str[80]; <br><br>&nbsp;&nbsp;&nbsp;&nbsp; lt=time(NUL); <br><br>&nbsp;&nbsp;&nbsp;&nbsp; ptr=localtime(&amp;lt); </span><br><br></span><br></p><br><p><br>    <span style="color:#363636;"><span style="color:#363636;">strftime(str,100,”It is now %I %p”,ptr);&nbsp;</span></span><br></p><br><p><br>    <br><br><span style="color:#363636;"></span><br></p><br><p><br>    <span style="color:#363636;"><br><br></span><br></p><br><span style="color:#363636;">%a 星期几的简写&nbsp;&nbsp;<br><br>%A 星期几的全称&nbsp;&nbsp;<br><br>%b 月分的简写&nbsp;&nbsp;<br><br>%B 月份的全称&nbsp;&nbsp;<br><br>%c 标准的日期的时间串&nbsp;&nbsp;<br><br>%C 年份的后两位数字&nbsp;&nbsp;<br><br>%d 十进制表示的每月的第几天&nbsp;&nbsp;<br><br>%D 月/天/年&nbsp;&nbsp;<br><br>%e 在两字符域中，十进制表示的每月的第几天&nbsp;&nbsp;<br><br>%F 年-月-日&nbsp;&nbsp;<br><br>%g 年份的后两位数字，使用基于周的年&nbsp;&nbsp;<br><br>%G 年分，使用基于周的年&nbsp;&nbsp;<br><br>%h 简写的月份名&nbsp;&nbsp;<br><br>%H 24小时制的小时&nbsp;&nbsp;<br><br>%I 12小时制的小时 <br><br>%j 十进制表示的每年的第几天&nbsp;&nbsp;<br><br>%m 十进制表示的月份&nbsp;&nbsp;<br><br>%M 十时制表示的分钟数&nbsp;&nbsp;<br><br>%n 新行符&nbsp;&nbsp;<br><br>%p 本地的AM或PM的等价显示&nbsp;&nbsp;<br><br>%r 12小时的时间&nbsp;&nbsp;<br><br>%R 显示小时和分钟：hh:mm&nbsp;&nbsp;<br><br>%S 十进制的秒数&nbsp;&nbsp;<br><br>%t 水平制表符&nbsp;&nbsp;<br><br>%T 显示时分秒：hh:mm:ss&nbsp;&nbsp;<br><br>%u 每周的第几天，星期一为第一天 （值从0到6，星期一为0） <br><br>%U 第年的第几周，把星期日做为第一天（值从0到53） <br><br>%V 每年的第几周，使用基于周的年&nbsp;&nbsp;<br><br>%w 十进制表示的星期几（值从0到6，星期天为0） <br><br>%W 每年的第几周，把星期一做为第一天（值从0到53）&nbsp;&nbsp;<br><br>%x 标准的日期串&nbsp;&nbsp;<br><br>%X 标准的时间串&nbsp;&nbsp;<br><br>%y 不带世纪的十进制年份（值从0到99） <br><br>%Y 带世纪部分的十进制年份&nbsp;&nbsp;<br><br>%z，%Z 时区名称，如果不能得到时区名称则返回空字符。 <br><br>%% 百分号 </span><br><br><span style="color:#3e3e3e;"><span style="color:#363636;"></span></span><br><p><br>    <br><br></p><br><p><br>    <br><br><span style="color:#3e3e3e;"><span style="color:#363636;"></span></span><br></p><br><p><br>    <span style="color:#3e3e3e;">4.3、自定义时间格式的转化</span><br></p><br><p><br>    &nbsp;&nbsp;&nbsp; 分解时间—-&gt;为字符串<br><br><span style="color:#3e3e3e;"></span><br></p><br><p><br>    <span style="color:#3e3e3e;"><span style="color:#363636;">size_t strftime( <br><br>&nbsp;&nbsp;&nbsp; char <em>strDest, <br><br>&nbsp;&nbsp;&nbsp; size_t maxsize，</em></span> </span><br></p><br><p><br>    <span style="color:#363636;">const char format, <br><br>&nbsp;&nbsp;&nbsp; const struct tm <em>timeptr&nbsp;&nbsp;<br><br>); <br><br></em></span><br></p><br><p><br>    <span style="color:#363636;">&nbsp;&nbsp;&nbsp; 字符串—-&gt;分解时间</span><br></p><br><p><br>    <span style="color:#363636;"><span style="color:#363636;">size_t strptime( <br><br>&nbsp;&nbsp;&nbsp; char strSource,</span> </span><br></p><br><p><br>    <span style="color:#363636;">const char <em>format, <br><br>&nbsp;&nbsp;&nbsp; const struct tm </em>timeptr&nbsp;&nbsp;<br><br>); <br><br></span><br></p><br><p><br>    <br><br><span style="color:#363636;"></span><br></p><br><p><br>    <span style="color:#363636;">即</span><br></p><br><p><br>    <span style="color:#363636;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; gmtime(&amp;time_t),localtime(<span style="color:#3e3e3e;"><span style="color:#363636;"><span style="color:#363636;">&amp;time_t</span></span></span>)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; strftime(buff,maxsize,format,&amp;tm)<br><br></span><br></p><br><p><br>    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; ———————————————–&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; —————————————————&gt;<br><br><span style="color:#363636;"></span><br></p><br><p><br>    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; time()==&gt; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; time_t&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; struct tm&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; string<br><br><span style="color:#363636;"></span><br></p><br><p><br>    <span style="color:#363636;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;———————————————-&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;————————————————–</span><br></p><br><p><br>    <span style="color:#363636;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mktime(&amp;struct tm)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; strptime(<span style="color:#3e3e3e;"><span style="color:#363636;"><span style="color:#363636;">buff</span></span></span>,format,&amp;tm)<br><br></span><br></p><br><br><br><p><br>    <br><br></p><br>至此，时间处理结束<br><br><p><br>    <br><br></p></div><p class="readmore"><a href="/2015/09/01/2015-09-01-CPLUSPLUS_time/">Mehr lesen</a></p></div><div class="post"><h2 class="post-title"><a href="/2015/08/31/2015-08-31-CPLUSPLUS_string/">[KANMARS原创] - C++学习_字符串操作_001</a></h2><div class="post-meta">2015-08-31</div><a data-thread-key="2015/08/31/2015-08-31-CPLUSPLUS_string/" href="/2015/08/31/2015-08-31-CPLUSPLUS_string/#comments" class="ds-thread-count"></a><div class="post-content"><p><br>    C++中的string<br></p><br><p><br>    <span style="background-color:#000000;color:#E53333;">一引入的头文件</span><br></p><br><p><br>    &nbsp;&nbsp;&nbsp; #include&lt;string&gt;<br></p><br><p><br>    <span style="background-color:#000000;color:#E53333;">二初始化</span><span style="background-color:#000000;color:#E53333;">&nbsp;&nbsp;&nbsp;</span>&nbsp;<br></p><br><p><br>    string(const char <em>s);&nbsp;&nbsp;&nbsp; //用c字符串s初始化&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 例如string s = new string(“cccccccc”)<br><br>string(int n,char c);&nbsp;&nbsp;&nbsp;&nbsp; //用n个字符c初始化&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 例如string s = new string(2,’c’)<br><br>此外，string类还支持默认构造函数和复制构造函数，如string s1；string s2=”hello”；都是正确的写法。当构造的string太长而无法表达时会抛出length_error异常 ；<br></em></p><br><p><br>    #include &lt;iostream&gt;<br><br>#include &lt;string&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;<br><br>#include &lt;fstream&gt;<br><br><br><br>using namespace std;<br><br><br><br>int main(){<br><br>&nbsp;&nbsp;&nbsp; string  s1 = new string(“这是s1”);<br><br>&nbsp;&nbsp;&nbsp; string <em> s2 = new string(10,’c’);<br><br>&nbsp;&nbsp;&nbsp; string s3 = “abcd”;<br><br>&nbsp;&nbsp;&nbsp; string s4;<br><br>&nbsp;&nbsp;&nbsp; cout &lt;&lt; </em>s1 &lt;&lt; endl;<br><br>&nbsp;&nbsp;&nbsp; cout &lt;&lt; <em>s2 &lt;&lt; endl;<br><br>&nbsp;&nbsp;&nbsp; cout &lt;&lt;&nbsp; s3 &lt;&lt; endl;<br><br>&nbsp;&nbsp;&nbsp; cout &lt;&lt;&nbsp; s3.empty() &lt;&lt; endl;<br><br>&nbsp;&nbsp;&nbsp; cout &lt;&lt;&nbsp; s4.empty() &lt;&lt; endl;<br><br>&nbsp;&nbsp; &nbsp;<br><br>}<br></em></p><br><p><br>    <span style="background-color:#000000;color:#E53333;">三string的字符操作</span><br></p><br><p><br>    #include&lt;iostream&gt;<br><br>#include&lt;string&gt;<br><br>#include&lt;fstream&gt;<br><br>#include &lt;string.h&gt;<br><br><br><br>using namespace std;<br><br><br><br>int main(){<br><br>&nbsp;&nbsp;&nbsp; string s = “abcdefghijklmn”;<br><br>&nbsp;&nbsp;&nbsp; cout &lt;&lt; s.operator<a href="2"></a> &lt;&lt; endl;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //获取第二个字符，不检查是否越界<br><br>&nbsp;&nbsp;&nbsp; cout &lt;&lt; s.at(2) &lt;&lt; endl;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //获取第二个字符，检查是否越界<br><br>&nbsp;&nbsp; &nbsp;<br><br>&nbsp;&nbsp;&nbsp; char tmp[100];<br><br>&nbsp;&nbsp;&nbsp; memset(tmp,0,100);<br><br><br><br>&nbsp;&nbsp;&nbsp; int i = s.copy(tmp,5,0);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //从s的开始位置0开始，拷贝5个字符到tmp字符数组中，返回实际拷贝数量<br><br><br><br>&nbsp;&nbsp;&nbsp; cout &lt;&lt; i &lt;&lt; endl;<br><br>&nbsp;&nbsp;&nbsp; cout &lt;&lt; tmp &lt;&lt; endl;<br></p><br><p><br>    <br><br>&nbsp;&nbsp;&nbsp; const char  cc1 = s.data();&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //返回一个非null终止的c字符数组<br><br>&nbsp;&nbsp;&nbsp; const char <em> cc2 = s.c_str();&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //返回一个以null终止的c字符串<br><br><br><br>&nbsp;&nbsp;&nbsp; cout &lt;&lt; cc1 &lt;&lt; endl;<br><br>&nbsp;&nbsp;&nbsp; cout &lt;&lt; cc2 &lt;&lt; endl;<br><br>}<br></em></p><br><p><br>    <br><br></p><br><p><br>    <span style="background-color:#000000;color:#E53333;">四、string 特性描述</span><br></p><br><p><br>    int capacity()const;&nbsp;&nbsp;&nbsp; //返回当前容量（即string中不必增加内存即可存放的元素个数）&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 容量是指数上升的0,1,2,4,8,16,32,64,128……<br><br>int max_size()const;&nbsp;&nbsp;&nbsp; //返回string对象中可存放的最大字符串的长度&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 和操作系统有关，64位系统4611686018427387897<br><br>int size()const;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //返回当前字符串的大小&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 长度，size和length相同，不包含’\0’<br><br>int length()const;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //返回当前字符串的长度&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 长度，size和length相同，不包含’\0’<br><br>bool empty()const;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //当前字符串是否为空<br><br>void resize(int len,char c);//把字符串当前大小置为len，并用字符c填充不足的部分<br></p><br><p><br>    <br><br></p><br><p><br>    <span style="background-color:#000000;color:#E53333;">五、</span><strong><span style="background-color:#000000;color:#E53333;">string类的输入输出操作</span></strong><br></p><br><p><br>    string类重载运算符operator&gt;&gt;用于输入，同样重载运算符operator&lt;&lt;用于输出操作。<br><br>函数getline(istream &amp;in,string &amp;s);用于从输入流in中读取字符串到s中，以换行符’\n’分开。<br></p><br><p><br>    #include &lt;iostream&gt;<br><br>#include &lt;fstream&gt;<br><br>#include &lt;string&gt;<br><br><br><br>using namespace std;<br><br><br><br>int main () {<br><br>&nbsp;&nbsp;&nbsp; string s ;<br><br>&nbsp;&nbsp;&nbsp; while(getline(cin,s)){<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; cout &lt;&lt; “readLine : “ &lt;&lt; s &lt;&lt; endl;<br><br>&nbsp;&nbsp;&nbsp; }<br><br>}<br></p><br><p><br>    <br><br></p><br><p><br>    <span style="background-color:#000000;color:#E53333;">六，string的赋值</span><br></p><br><p><br>    string &amp;operator=(const string &amp;s);//把字符串s赋给当前字符串<br><br>string &amp;assign(const char s);//用c类型字符串s赋值<br><br>string &amp;assign(const char <em>s,int n);//用c字符串s开始的n个字符赋值<br><br>string &amp;assign(const string &amp;s);//把字符串s赋给当前字符串<br><br>string &amp;assign(int n,char c);//用n个字符c赋值给当前字符串<br><br>string &amp;assign(const string &amp;s,int start,int n);//把字符串s中从start开始的n个字符赋给当前字符串<br><br>string &amp;assign(const_iterator first,const_itertor last);//把first和last迭代器之间的部分赋给字符串<br></em></p><br><p><br>    #include &lt;iostream&gt;<br><br>#include &lt;fstream&gt;<br><br>#include &lt;string&gt;<br><br><br><br>using namespace std;<br><br><br><br>int main(){<br><br>&nbsp;&nbsp;&nbsp; string s;<br><br>&nbsp;&nbsp;&nbsp; s.assign(new string(“abc”));&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//把字符串s赋给当前字符串<br><br>&nbsp;&nbsp;&nbsp; cout &lt;&lt; s &lt;&lt;endl;<br><br>&nbsp;&nbsp;&nbsp; s.assign(<em>new string(“abcdefghijkl”),3,6);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//把字符串s中从start开始的n个字符赋给当前字符串<br><br>&nbsp;&nbsp;&nbsp; cout &lt;&lt; s &lt;&lt;endl;<br><br>&nbsp;&nbsp;&nbsp; s.assign(“abcdefghijkl”);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//用c类型字符串s赋值<br><br>&nbsp;&nbsp;&nbsp; cout &lt;&lt; s &lt;&lt;endl;<br><br>&nbsp;&nbsp;&nbsp; s.assign(“abcdefghijkl”,6);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //用c字符串s开始的n个字符赋值<br><br>&nbsp;&nbsp;&nbsp; cout &lt;&lt; s &lt;&lt;endl;<br><br>}&nbsp;&nbsp;<br></em></p><br><p><br>    <br><br></p><br><p><br>    <span style="background-color:#000000;color:#E53333;">七、</span><strong><span style="background-color:#000000;color:#E53333;">string的连接：</span></strong><br><br>string &amp;operator+=(const string &amp;s);//把字符串s连接到当前字符串的结尾 <br><br>string &amp;append(const char s);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //把c类型字符串s连接到当前字符串结尾<br><br>string &amp;append(const char <em>s,int n);//把c类型字符串s的前n个字符连接到当前字符串结尾<br><br>string &amp;append(const string &amp;s);&nbsp;&nbsp;&nbsp; //同operator+=()<br><br>string &amp;append(const string &amp;s,int pos,int n);//把字符串s中从pos开始的n个字符连接到当前字符串的结尾<br><br>string &amp;append(int n,char c);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //在当前字符串结尾添加n个字符c<br><br>string &amp;append(const_iterator first,const_iterator last);//把迭代器first和last之间的部分连接到当前字符串的结尾<br></em></p><br><p><br>    <br><br></p><br><p><br>    <strong><span style="background-color:#000000;color:#E53333;">八、string的比较</span></strong><br></p><br><p><br>    bool operator==(const string &amp;s1,const string &amp;s2)const;//比较两个字符串是否相等<br><br>运算符”&gt;”,”&lt;”,”&gt;=”,”&lt;=”,”!=”均被重载用于字符串的比较；<br><br>int compare(const string &amp;s) const;//比较当前字符串和s的大小&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 大于是1,小于是-1<br><br>int compare(int pos, int n,const string &amp;s)const;//比较当前字符串从pos开始的n个字符组成的字符串与s的大小<br><br>int compare(int pos, int n,const string &amp;s,int pos2,int n2)const;//比较当前字符串从pos开始的n个字符组成的字符串与s中<br></p><br><p><br>    //pos2开始的n2个字符组成的字符串的大小<br><br>int compare(const char s) const;<br><br>int compare(int pos, int n,const char <em>s) const;<br><br>int compare(int pos, int n,const char </em>s, int pos2) const;<br></p><br><p><br>    <br><br>compare函数在&gt;时返回1，&lt;时返回-1，==时返回0&nbsp;&nbsp;<br></p><br>&nbsp;<br><p><br>    <br><br></p><br><p><br>    <strong><span style="background-color:#000000;color:#E53333;">九、string的子串</span></strong><br><br>string substr(int pos = 0,int n = npos) const;//返回pos开始的n个字符组成的字符串<br></p><br><p><br>    <br><br></p><br><p><br>    <strong><span style="background-color:#000000;color:#E53333;">十、string的交换</span></strong><br></p><br><p><br>    void swap(string &amp;s2);&nbsp;&nbsp;&nbsp; //交换当前字符串与s2的值<br></p><br><p><br>    <br><br></p><br><p><br>    #include &lt;iostream&gt;<br><br>#include &lt;fstream&gt;<br><br>#include &lt;string&gt;<br><br><br><br>using namespace std;<br><br><br><br>int main(){<br><br>&nbsp;&nbsp;&nbsp; string <em>s1 = new string(“abc”);<br><br>&nbsp;&nbsp;&nbsp; string </em>s2 = new string(“def”);<br><br><br><br>&nbsp;&nbsp;&nbsp; cout &lt;&lt; <em>s1 &lt;&lt; endl;<br><br>&nbsp;&nbsp;&nbsp; cout &lt;&lt; </em>s2 &lt;&lt; endl;<br><br>&nbsp;&nbsp; &nbsp;<br><br>&nbsp;&nbsp;&nbsp; (<em>s1).swap(</em>s2);<br><br><br><br>&nbsp;&nbsp;&nbsp; cout &lt;&lt; <em>s1 &lt;&lt; endl;<br><br>&nbsp;&nbsp;&nbsp; cout &lt;&lt; </em>s2 &lt;&lt; endl;<br><br>&nbsp;&nbsp;&nbsp; return 0;<br><br>}<br></p><br><p><br>    <span style="color:#E53333;background-color:#000000;">十一、</span><strong><span style="color:#E53333;background-color:#000000;">string类的查找函数</span></strong><br></p><br><p><br>    int find(char c, int pos = 0) const;//从pos开始查找字符c在当前字符串的位置<br><br>int find(const char <em>s, int pos = 0) const;//从pos开始查找字符串s在当前串中的位置<br><br>int find(const char </em>s, int pos, int n) const;//从pos开始查找字符串s中前n个字符在当前串中的位置<br><br>int find(const string &amp;s, int pos = 0) const;//从pos开始查找字符串s在当前串中的位置<br><br>//查找成功时返回所在位置，失败返回string::npos的值&nbsp;<br></p><br><p><br>    <br><br>int rfind(char c, int pos = npos) const;//从pos开始从后向前查找字符c在当前串中的位置<br><br>int rfind(const char <em>s, int pos = npos) const;<br><br>int rfind(const char </em>s, int pos, int n = npos) const;<br><br>int rfind(const string &amp;s,int pos = npos) const;<br><br>//从pos开始从后向前查找字符串s中前n个字符组成的字符串在当前串中的位置，成功返回所在位置，失败时返回string::npos的值&nbsp;<br></p><br><p><br>    <br><br>int find_first_of(char c, int pos = 0) const;//从pos开始查找字符c第一次出现的位置<br><br>int find_first_of(const char <em>s, int pos = 0) const;<br><br>int find_first_of(const char </em>s, int pos, int n) const;<br><br>int find_first_of(const string &amp;s,int pos = 0) const;<br><br>//从pos开始查找当前串中第一个在s的前n个字符组成的数组里的字符的位置。查找失败返回string::npos&nbsp;<br></p><br><p><br>    #include &lt;iostream&gt;<br><br>#include &lt;string&gt;<br><br>using namespace std;<br><br><br><br>int main ()<br><br>{<br><br>&nbsp; string str (“Replace the vowels in this sentence by asterisks.”);<br><br>&nbsp; size_t found;<br><br>&nbsp; found=str.find_first_of(“aeiou”);<br><br>&nbsp; while (found!=string::npos)<br><br>&nbsp; {<br><br>&nbsp;&nbsp;&nbsp; str[found]=’<em>‘;<br><br>&nbsp;&nbsp;&nbsp; found=str.find_first_of(“aeiou”,found+1);<br><br>&nbsp; }<br><br>&nbsp; cout &lt;&lt; str &lt;&lt; endl;<br><br>&nbsp; return 0;<br><br>}<br></em></p><br><p><br>    <br><br></p><br><p><br>    <br><br>int find_first_not_of(char c, int pos = 0) const;<br><br>int find_first_not_of(const char s, int pos = 0) const;<br><br>int find_first_not_of(const char <em>s, int pos,int n) const;<br><br>int find_first_not_of(const string &amp;s,int pos = 0) const;<br><br>//从当前串中查找第一个不在串s中的字符出现的位置，失败返回string::npos&nbsp;<br></em></p><br><p><br>    <br><br></p><br><p><br>    <br><br>int find_last_of(char c, int pos = npos) const;<br><br>int find_last_of(const char s, int pos = npos) const;<br><br>int find_last_of(const char <em>s, int pos, int n = npos) const;<br><br>int find_last_of(const string &amp;s,int pos = npos) const; <br><br>int find_last_not_of(char c, int pos = npos) const;<br><br>int find_last_not_of(const char </em>s, int pos = npos) const;<br><br>int find_last_not_of(const char <em>s, int pos, int n) const;<br><br>int find_last_not_of(const string &amp;s,int pos = npos) const;<br><br>//find_last_of和find_last_not_of与find_first_of和find_first_not_of相似，只不过是从后向前查找<br></em></p><br><p><br>    <br><br></p><br><p><br>    <span style="background-color:#000000;color:#E53333;">十二、</span><strong><span style="background-color:#000000;color:#E53333;">string类的替换函数</span></strong><br></p><br><p><br>    string &amp;replace(int p0, int n0,const char s);//删除从p0开始的n0个字符，然后在p0处插入串s<br><br>string &amp;replace(int p0, int n0,const char <em>s, int n);//删除p0开始的n0个字符，然后在p0处插入字符串s的前n个字符<br><br>string &amp;replace(int p0, int n0,const string &amp;s);//删除从p0开始的n0个字符，然后在p0处插入串s<br><br>string &amp;replace(int p0, int n0,const string &amp;s, int pos, int n);//删除p0开始的n0个字符，然后在p0处插入串s中从pos开始的n个字符<br><br>string &amp;replace(int p0, int n0,int n, char c);//删除p0开始的n0个字符，然后在p0处插入n个字符c<br><br>string &amp;replace(iterator first0, iterator last0,const char </em>s);//把[first0，last0）之间的部分替换为字符串s<br><br>string &amp;replace(iterator first0, iterator last0,const char <em>s, int n);//把[first0，last0）之间的部分替换为s的前n个字符<br><br>string &amp;replace(iterator first0, iterator last0,const string &amp;s);//把[first0，last0）之间的部分替换为串s<br><br>string &amp;replace(iterator first0, iterator last0,int n, char c);//把[first0，last0）之间的部分替换为n个字符c<br><br>string<br> &amp;replace(iterator first0, iterator last0,const_iterator first,<br>const_iterator last);//把[first0，last0）之间的部分替换成[first，last）之间的字符串<br></em></p><br><p><br>    #include &lt;iostream&gt;<br><br>#include &lt;fstream&gt;<br><br>#include &lt;string&gt;<br><br><br><br>using namespace std;<br><br><br><br>int main(){<br><br>&nbsp;&nbsp;&nbsp; string s1 = “abcdefg”;<br><br>&nbsp;&nbsp;&nbsp; string s2 = “0123456”;<br><br>&nbsp;&nbsp;&nbsp; cout &lt;&lt; s2.replace(3,2,s1) &lt;&lt; endl;<br><br>&nbsp;&nbsp;&nbsp; cout &lt;&lt; s2 &lt;&lt; endl;<br><br>&nbsp;&nbsp;&nbsp; s2 = “0123456”;<br><br>&nbsp;&nbsp;&nbsp; cout &lt;&lt; s2.replace(3,2,s1,4,3) &lt;&lt; endl;<br><br>&nbsp;&nbsp;&nbsp; cout &lt;&lt; s2 &lt;&lt; endl;<br><br>&nbsp;&nbsp;&nbsp; return 0;<br><br>}<br></p><br><p><br>    <br><br></p><br><p><br>    <span style="background-color:#000000;color:#E53333;">十三、</span><strong><span style="background-color:#000000;color:#E53333;">string类的插入函数</span></strong><br></p><br><p><br>    string &amp;insert(int p0, const char s);<br><br>string &amp;insert(int p0, const char *s, int n);<br><br>string &amp;insert(int p0,const string &amp;s);<br><br>string &amp;insert(int p0,const string &amp;s, int pos, int n);<br><br>//前4个函数在p0位置插入字符串s中pos开始的前n个字符<br><br>string &amp;insert(int p0, int n, char c);//此函数在p0处插入n个字符c<br><br>iterator insert(iterator it, char c);//在it处插入字符c，返回插入后迭代器的位置<br><br>void insert(iterator it, const_iterator first, const_iterator last);//在it处插入[first，last）之间的字符<br><br>void insert(iterator it, int n, char c);//在it处插入n个字符c<br></p><br><p><br>    <br><br></p><br><p><br>    <span style="background-color:#000000;color:#E53333;">十四、</span><strong><span style="background-color:#000000;color:#E53333;">string类的删除函数</span></strong><br></p><br><p><br>    iterator erase(iterator first, iterator last);//删除[first，last）之间的所有字符，返回删除后迭代器的位置<br><br>iterator erase(iterator it);//删除it指向的字符，返回删除后迭代器的位置<br><br>string &amp;erase(int pos = 0, int n = npos);//删除pos开始的n个字符，返回修改后的字符串<br></p><br><p><br>    <br><br></p><br><p><br>    <span style="background-color:#000000;color:#E53333;">十五、</span><strong><span style="background-color:#000000;color:#E53333;">string类的迭代器处理</span></strong><br></p><br><p><br>    string类提供了向前和向后遍历的迭代器iterator，迭代器提供了访问各个字符的语法，类似于指针操作，迭代器不检查范围。<br><br>用string::iterator或string::const_iterator声明迭代器变量，const_iterator不允许改变迭代的内容。常用迭代器函数有：<br><br>const_iterator begin()const;<br><br>iterator begin();&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //返回string的起始位置<br><br>const_iterator end()const;<br><br>iterator end();&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //返回string的最后一个字符后面的位置<br><br>const_iterator rbegin()const;<br><br>iterator rbegin();&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //返回string的最后一个字符的位置<br><br>const_iterator rend()const;<br><br>iterator rend();&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //返回string第一个字符位置的前面<br><br>rbegin和rend用于从后向前的迭代访问，通过设置迭代器string::reverse_iterator,string::const_reverse_iterator实现<br></p><br><p><br>    <br><br></p><br><p><br>    #include &lt;iostream&gt;<br><br>#include &lt;fstream&gt;<br><br>#include &lt;string&gt;<br><br>#include &lt;algorithm&gt;<br><br><br><br>using namespace std;<br><br><br><br>void doExec(char c){<br><br>&nbsp;&nbsp;&nbsp; cout &lt;&lt; c;<br><br>}<br><br><br><br>int main(){<br><br>&nbsp;&nbsp;&nbsp; string s1 = “abcdefg”;<br><br>&nbsp;&nbsp;&nbsp; string::iterator ite_begin = s1.begin();<br><br>&nbsp;&nbsp;&nbsp; string::iterator ite_end = s1.end();<br><br><br><br>&nbsp;&nbsp;&nbsp; for_each(ite_begin,ite_end,doExec);<br><br>&nbsp;&nbsp;&nbsp; cout &lt;&lt; endl;<br><br>&nbsp;&nbsp;&nbsp; return 0;<br><br>}<br></p><br><p><br>    <br><br></p><br><p><br>    <strong>十六、字符串流处理</strong> <br><br>通过定义ostringstream和istringstream变量实现，#include &lt;sstream&gt;头文件中<br><br>例如：<br><br>&nbsp;&nbsp;&nbsp; string input(“hello,this is a test”);<br><br>&nbsp;&nbsp;&nbsp; istringstream is(input);<br><br>&nbsp;&nbsp;&nbsp; string s1,s2,s3,s4;<br><br>&nbsp;&nbsp;&nbsp; is&gt;&gt;s1&gt;&gt;s2&gt;&gt;s3&gt;&gt;s4;//s1=”hello,this”,s2=”is”,s3=”a”,s4=”test”<br><br>&nbsp;&nbsp;&nbsp; ostringstream os;<br><br>&nbsp;&nbsp;&nbsp; os&lt;&lt;s1&lt;&lt;s2&lt;&lt;s3&lt;&lt;s4;<br><br>&nbsp;&nbsp;&nbsp; cout&lt;&lt;os.str();<br></p><br><p><br>    <br><br></p><br><p><br>    <br><br></p><br><p><br>    <br><br></p><br><p><br>    <br><br></p><br><p><br>    <br><br></p><br><p><br>    <br><br></p><br><p><br>    <br><br></p></div><p class="readmore"><a href="/2015/08/31/2015-08-31-CPLUSPLUS_string/">Mehr lesen</a></p></div><div class="post"><h2 class="post-title"><a href="/2015/08/16/2015-08-16-LUA_SOURCES_READ_001/">[KANMARS原创] - Lua源码阅读_DAY_001</a></h2><div class="post-meta">2015-08-16</div><a data-thread-key="2015/08/16/2015-08-16-LUA_SOURCES_READ_001/" href="/2015/08/16/2015-08-16-LUA_SOURCES_READ_001/#comments" class="ds-thread-count"></a><div class="post-content"><p><br>    <br><br></p><br><p><br>    本文从初学者的角度试探性的看了一下Lua的实现<br></p><br><p><br>    最近草草的看了点lua的结构，看这门语言的原因，是因为lua很短，并且是程序员从应用开发到语言开发的一个比较简单的路径。<br></p><br><p><br>    学艺不精，但是必须总结一下以防忘记<br></p><br><p><br>    ——————<br></p><br><p><br>    lua语法请查询官方文档，本处不再赘述<br></p><br><p><br>    ——————<br></p><br><p><br>    lua最重要的是内部的数据结构，可以参照阿里云大神<strong>罗日健</strong>的相关博客：<br></p><br><p><br>    <a href="http://blog.aliyun.com/761?spm=0.0.0.0.Bbv98y&nbsp;&nbsp;&nbsp;&amp;nbsp" target="_blank" rel="external">http://blog.aliyun.com/761?spm=0.0.0.0.Bbv98y&nbsp;&nbsp;&nbsp;&amp;nbsp</a>;<span id="__kindeditor_bookmark_start_19__">&nbsp;&nbsp; Lua数据结构 — TValue（一）</span><br></p><br><p><br>    <span id="__kindeditor_bookmark_start_19__"><a href="http://blog.aliyun.com/768?spm=0.0.0.0.IIIJKM&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Lua数据结构" target="_blank" rel="external">http://blog.aliyun.com/768?spm=0.0.0.0.IIIJKM&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Lua数据结构</a> — TString（二）</span><br></p><br><p><br>    <span id="__kindeditor_bookmark_start_19__"><a href="http://blog.aliyun.com/787?spm=0.0.0.0.nwRCjZ&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&amp;nbsp" target="_blank" rel="external">http://blog.aliyun.com/787?spm=0.0.0.0.nwRCjZ&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&amp;nbsp</a>;<span id="__kindeditor_bookmark_start_19__">Lua数据结构 — Table（三）</span></span><br></p><br><p><br>    <span id="__kindeditor_bookmark_start_19__"><span id="__kindeditor_bookmark_start_19__"><a href="http://blog.aliyun.com/845?spm=0.0.0.0.BvDyCO&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&amp;nbsp" target="_blank" rel="external">http://blog.aliyun.com/845?spm=0.0.0.0.BvDyCO&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&amp;nbsp</a>;<span id="__kindeditor_bookmark_start_19__"><span id="__kindeditor_bookmark_start_19__">Lua数据结构 — 闭包（四）</span></span></span></span><br></p><br><p><br>    <span id="__kindeditor_bookmark_start_19__"><span id="__kindeditor_bookmark_start_19__"><span id="__kindeditor_bookmark_start_19__"><span id="__kindeditor_bookmark_start_19__"><a href="http://blog.aliyun.com/789?spm=0.0.0.0.SHkRm9&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&amp;nbsp" target="_blank" rel="external">http://blog.aliyun.com/789?spm=0.0.0.0.SHkRm9&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&amp;nbsp</a>;<span id="__kindeditor_bookmark_start_19__"><span id="__kindeditor_bookmark_start_19__">&nbsp;<span id="__kindeditor_bookmark_start_19__"><span id="__kindeditor_bookmark_start_19__">Lua数据结构 — Udata（五）</span></span></span></span></span></span></span></span><br></p><br><p><br>    <span id="__kindeditor_bookmark_start_19__"><span id="__kindeditor_bookmark_start_19__"><span id="__kindeditor_bookmark_start_19__"><span id="__kindeditor_bookmark_start_19__"><span id="__kindeditor_bookmark_start_19__"><span id="__kindeditor_bookmark_start_19__"><span id="__kindeditor_bookmark_start_19__"><span id="__kindeditor_bookmark_start_19__"><a href="http://blog.aliyun.com/795?spm=0.0.0.0.xddNuq&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&amp;nbsp" target="_blank" rel="external">http://blog.aliyun.com/795?spm=0.0.0.0.xddNuq&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&amp;nbsp</a>;<span id="__kindeditor_bookmark_start_19__"><span id="__kindeditor_bookmark_start_19__"><span id="__kindeditor_bookmark_start_19__"><span id="__kindeditor_bookmark_start_19__"><span id="__kindeditor_bookmark_start_19__"><span id="__kindeditor_bookmark_start_19__">&nbsp;<span id="__kindeditor_bookmark_start_19__"><span id="__kindeditor_bookmark_start_19__">Lua数据结构 — Lua_state（六）</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span><br></p><br><p><br>    <br><br><span id="__kindeditor_bookmark_start_19__"><span id="__kindeditor_bookmark_start_19__"><span id="__kindeditor_bookmark_start_19__"><span id="__kindeditor_bookmark_start_19__"><span id="__kindeditor_bookmark_start_19__"><span id="__kindeditor_bookmark_start_19__"><span id="__kindeditor_bookmark_start_19__"><span id="__kindeditor_bookmark_start_19__"><span id="__kindeditor_bookmark_start_19__"><span id="__kindeditor_bookmark_start_19__"><span id="__kindeditor_bookmark_start_19__"><span id="__kindeditor_bookmark_start_19__"><span id="__kindeditor_bookmark_start_19__"><span id="__kindeditor_bookmark_start_19__"><span id="__kindeditor_bookmark_start_19__"></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span><br></p><br><p><br>    <span id="__kindeditor_bookmark_start_19__"><span id="__kindeditor_bookmark_start_19__"><span id="__kindeditor_bookmark_start_19__"><span id="__kindeditor_bookmark_start_19__"><span id="__kindeditor_bookmark_start_19__"><span id="__kindeditor_bookmark_start_19__"><span id="__kindeditor_bookmark_start_19__"><span id="__kindeditor_bookmark_start_19__"><span id="__kindeditor_bookmark_start_19__"><span id="__kindeditor_bookmark_start_19__"><span id="__kindeditor_bookmark_start_19__"><span id="__kindeditor_bookmark_start_19__"><span id="__kindeditor_bookmark_start_19__"><span id="__kindeditor_bookmark_start_19__"><span id="__kindeditor_bookmark_start_19__"><span id="__kindeditor_bookmark_start_19__">此外，参照网易<span id="__kindeditor_bookmark_start_19__"><span id="__kindeditor_bookmark_start_19__"><span id="__kindeditor_bookmark_start_19__"><span id="__kindeditor_bookmark_start_19__"><span id="__kindeditor_bookmark_start_19__"><span id="__kindeditor_bookmark_start_19__"><span id="__kindeditor_bookmark_start_19__"><span id="__kindeditor_bookmark_start_19__"><span id="__kindeditor_bookmark_start_19__"><span id="__kindeditor_bookmark_start_19__"><span id="__kindeditor_bookmark_start_19__"><span id="__kindeditor_bookmark_start_19__"><span id="__kindeditor_bookmark_start_19__"><span id="__kindeditor_bookmark_start_19__"><span id="__kindeditor_bookmark_start_19__"><span id="__kindeditor_bookmark_start_19__">前</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span>杭州研究中心总监吴云洋的博客，也是不错的</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span><br></p><br><p><br>    <span id="__kindeditor_bookmark_start_19__"><span id="__kindeditor_bookmark_start_19__"><span id="__kindeditor_bookmark_start_19__"><span id="__kindeditor_bookmark_start_19__"><span id="__kindeditor_bookmark_start_19__"><span id="__kindeditor_bookmark_start_19__"><span id="__kindeditor_bookmark_start_19__"><span id="__kindeditor_bookmark_start_19__"><span id="__kindeditor_bookmark_start_19__"><span id="__kindeditor_bookmark_start_19__"><span id="__kindeditor_bookmark_start_19__"><span id="__kindeditor_bookmark_start_19__"><span id="__kindeditor_bookmark_start_19__"><span id="__kindeditor_bookmark_start_19__"><span id="__kindeditor_bookmark_start_19__"><span id="__kindeditor_bookmark_start_19__"><a href="http://blog.codingnow.com/" target="_blank" rel="external">http://blog.codingnow.com/</a><br><br></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span><br></p><br><p><br>    <span id="__kindeditor_bookmark_start_19__"><span id="__kindeditor_bookmark_start_19__"><span id="__kindeditor_bookmark_start_19__"><span id="__kindeditor_bookmark_start_19__"><span id="__kindeditor_bookmark_start_19__"><span id="__kindeditor_bookmark_start_19__"><span id="__kindeditor_bookmark_start_19__"><span id="__kindeditor_bookmark_start_19__"><span id="__kindeditor_bookmark_start_19__"><span id="__kindeditor_bookmark_start_19__"><span id="__kindeditor_bookmark_start_19__"><span id="__kindeditor_bookmark_start_19__"><span id="__kindeditor_bookmark_start_19__"><span id="__kindeditor_bookmark_start_19__"><span id="__kindeditor_bookmark_start_19__"><span id="__kindeditor_bookmark_start_19__">PS:我从2004到2011，玩《大话西游》七年，人生因这个游戏而改变。</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span><br></p><br><p><br>    <span id="__kindeditor_bookmark_start_19__"><span id="__kindeditor_bookmark_start_19__"><span id="__kindeditor_bookmark_start_19__"><span id="__kindeditor_bookmark_start_19__"><span id="__kindeditor_bookmark_start_19__"><span id="__kindeditor_bookmark_start_19__"><span id="__kindeditor_bookmark_start_19__"><span id="__kindeditor_bookmark_start_19__"><span id="__kindeditor_bookmark_start_19__"><span id="__kindeditor_bookmark_start_19__"><span id="__kindeditor_bookmark_start_19__"><span id="__kindeditor_bookmark_start_19__"><span id="__kindeditor_bookmark_start_19__"><span id="__kindeditor_bookmark_start_19__"><span id="__kindeditor_bookmark_start_19__"><span id="__kindeditor_bookmark_start_19__">我看云风的博客一年，学习lua的一些语法或者内存结构……</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span><br></p><br><p><br>    <span id="__kindeditor_bookmark_start_19__"><span id="__kindeditor_bookmark_start_19__"><span id="__kindeditor_bookmark_start_19__"><span id="__kindeditor_bookmark_start_19__"><span id="__kindeditor_bookmark_start_19__"><span id="__kindeditor_bookmark_start_19__"><span id="__kindeditor_bookmark_start_19__"><span id="__kindeditor_bookmark_start_19__"><span id="__kindeditor_bookmark_start_19__"><span id="__kindeditor_bookmark_start_19__"><span id="__kindeditor_bookmark_start_19__"><span id="__kindeditor_bookmark_start_19__"><span id="__kindeditor_bookmark_start_19__"><span id="__kindeditor_bookmark_start_19__"><span id="__kindeditor_bookmark_start_19__"><span id="__kindeditor_bookmark_start_19__">直到今天上午，才知道:《大话西游》是吴云洋开发的，而吴云洋就是云风。</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span><br></p><br><p><br>    <br><br><span id="__kindeditor_bookmark_start_19__"><span id="__kindeditor_bookmark_start_19__"><span id="__kindeditor_bookmark_start_19__"><span id="__kindeditor_bookmark_start_19__"><span id="__kindeditor_bookmark_start_19__"><span id="__kindeditor_bookmark_start_19__"><span id="__kindeditor_bookmark_start_19__"><span id="__kindeditor_bookmark_start_19__"><span id="__kindeditor_bookmark_start_19__"><span id="__kindeditor_bookmark_start_19__"><span id="__kindeditor_bookmark_start_19__"><span id="__kindeditor_bookmark_start_19__"><span id="__kindeditor_bookmark_start_19__"><span id="__kindeditor_bookmark_start_19__"><span id="__kindeditor_bookmark_start_19__"></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span><br></p><br><p><br>    <span id="__kindeditor_bookmark_start_19__"><span id="__kindeditor_bookmark_start_19__"><span id="__kindeditor_bookmark_start_19__"><span id="__kindeditor_bookmark_start_19__"><span id="__kindeditor_bookmark_start_19__"><span id="__kindeditor_bookmark_start_19__"><span id="__kindeditor_bookmark_start_19__"><span id="__kindeditor_bookmark_start_19__"><span id="__kindeditor_bookmark_start_19__"><span id="__kindeditor_bookmark_start_19__"><span id="__kindeditor_bookmark_start_19__"><span id="__kindeditor_bookmark_start_19__"><span id="__kindeditor_bookmark_start_19__"><span id="__kindeditor_bookmark_start_19__"><span id="__kindeditor_bookmark_start_19__"><span id="__kindeditor_bookmark_start_19__">——————</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span><br></p><br><p><br>    <span id="__kindeditor_bookmark_start_19__"><span id="__kindeditor_bookmark_start_19__"><span id="__kindeditor_bookmark_start_19__"><span id="__kindeditor_bookmark_start_19__"><span id="__kindeditor_bookmark_start_19__"><span id="__kindeditor_bookmark_start_19__"><span id="__kindeditor_bookmark_start_19__"><span id="__kindeditor_bookmark_start_19__"><span id="__kindeditor_bookmark_start_19__"><span id="__kindeditor_bookmark_start_19__"><span id="__kindeditor_bookmark_start_19__"><span id="__kindeditor_bookmark_start_19__"><span id="__kindeditor_bookmark_start_19__"><span id="__kindeditor_bookmark_start_19__"><span id="__kindeditor_bookmark_start_19__"><span id="__kindeditor_bookmark_start_19__">lua最常用的地方是游戏引擎的开发，其优势如下：</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span><br></p><br><p><br>    <span id="__kindeditor_bookmark_start_19__"><span id="__kindeditor_bookmark_start_19__"><span id="__kindeditor_bookmark_start_19__"><span id="__kindeditor_bookmark_start_19__"><span id="__kindeditor_bookmark_start_19__"><span id="__kindeditor_bookmark_start_19__"><span id="__kindeditor_bookmark_start_19__"><span id="__kindeditor_bookmark_start_19__"><span id="__kindeditor_bookmark_start_19__"><span id="__kindeditor_bookmark_start_19__"><span id="__kindeditor_bookmark_start_19__"><span id="__kindeditor_bookmark_start_19__"><span id="__kindeditor_bookmark_start_19__"><span id="__kindeditor_bookmark_start_19__"><span id="__kindeditor_bookmark_start_19__"><span id="__kindeditor_bookmark_start_19__">1、Lua脚本可以很容易的被C/C++ 代码调用，也可以反过来调用C/C++的函数，这使得Lua在应用程序中可以被广泛应用。</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span><br></p><br><p><br>    <span id="__kindeditor_bookmark_start_19__"><span id="__kindeditor_bookmark_start_19__"><span id="__kindeditor_bookmark_start_19__"><span id="__kindeditor_bookmark_start_19__"><span id="__kindeditor_bookmark_start_19__"><span id="__kindeditor_bookmark_start_19__"><span id="__kindeditor_bookmark_start_19__"><span id="__kindeditor_bookmark_start_19__"><span id="__kindeditor_bookmark_start_19__"><span id="__kindeditor_bookmark_start_19__"><span id="__kindeditor_bookmark_start_19__"><span id="__kindeditor_bookmark_start_19__"><span id="__kindeditor_bookmark_start_19__"><span id="__kindeditor_bookmark_start_19__"><span id="__kindeditor_bookmark_start_19__"><span id="__kindeditor_bookmark_start_19__">2、在目前所有的解释器语言中，Lua的速度是最快的。</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span><br></p><br><p><br>    <span id="__kindeditor_bookmark_start_19__"><span id="__kindeditor_bookmark_start_19__"><span id="__kindeditor_bookmark_start_19__"><span id="__kindeditor_bookmark_start_19__"><span id="__kindeditor_bookmark_start_19__"><span id="__kindeditor_bookmark_start_19__"><span id="__kindeditor_bookmark_start_19__"><span id="__kindeditor_bookmark_start_19__"><span id="__kindeditor_bookmark_start_19__"><span id="__kindeditor_bookmark_start_19__"><span id="__kindeditor_bookmark_start_19__"><span id="__kindeditor_bookmark_start_19__"><span id="__kindeditor_bookmark_start_19__"><span id="__kindeditor_bookmark_start_19__"><span id="__kindeditor_bookmark_start_19__"><span id="__kindeditor_bookmark_start_19__">3、Lua足够的小，可以在嵌入平台大范围使用。</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span><br></p><br><p><br>    <span id="__kindeditor_bookmark_start_19__"><span id="__kindeditor_bookmark_start_19__"><span id="__kindeditor_bookmark_start_19__"><span id="__kindeditor_bookmark_start_19__"><span id="__kindeditor_bookmark_start_19__"><span id="__kindeditor_bookmark_start_19__"><span id="__kindeditor_bookmark_start_19__"><span id="__kindeditor_bookmark_start_19__"><span id="__kindeditor_bookmark_start_19__"><span id="__kindeditor_bookmark_start_19__"><span id="__kindeditor_bookmark_start_19__"><span id="__kindeditor_bookmark_start_19__"><span id="__kindeditor_bookmark_start_19__"><span id="__kindeditor_bookmark_start_19__"><span id="__kindeditor_bookmark_start_19__"></span></span></span></span></span></span></span></span></span></span></span></span></span></span>——————<br><br></span><br></p><br><p><br>    但对我来说,其优点就是：小，能让我短时间了解一门语言是如何运行的。<br></p><br><p><br>    Lua是用纯C语言实现的，幸好我的C语言已经达到了可以出去混饭吃的水平。<br></p><br><p><br>    <br><br></p><br><p><br>    Lua的数据结构由TValue，TString，UData，GCObject等构成，<br></p><br><p><br>    要点如下：大范围应用了TValue作为值引用，而TString和UData等都是可垃圾回收的对象，通过GCObject链接到了垃圾回收链上。<br></p><br><p><br>    而TString和UData都采用的是一个头+体的结构，即从TString后开始读取TString中的长度，即为字符串的真正内容。UData类似。<br></p><br><p><br>    <br><br></p><br><p><br>    Table是Lua比较重要的数据类型，在内部实现上，分别使用散列表Node <em>node和数组TValue </em>array来存放下标是”Value”和[index]的键和下标。<br></p><br><p><br>    当长度不够时，会调用luaH_resize函数对这两个内存进行扩容，而扩容在底层使用的是luaM_reallocvector–》realloc内存分配，可以对已分配内存进行扩容重新分配<br></p><br><p><br>    即Table可以实现动态的扩容或者缩容<br></p><br><p><br>    <br><br></p><br><p><br>    接下来是Lua_state，Lua_state是一个全局的上下文信息。储存了Lua执行过程的栈信息，函数调用信息等，参照Lua_state结构体的源码<br></p><br><p><br>    <br><br></p><br><p><br>    <br><br></p><br><p><br>    /<em><br><br>** ‘per thread’ state<br></div><p class="readmore"><a href="/2015/08/16/2015-08-16-LUA_SOURCES_READ_001/">Mehr lesen</a></p></div><nav class="page-navigator"><a class="extend prev" rel="prev" href="/page/3/">Vorheriger</a><a class="page-number" href="/">1</a><a class="page-number" href="/page/2/">2</a><a class="page-number" href="/page/3/">3</a><span class="page-number current">4</span><a class="page-number" href="/page/5/">5</a><a class="page-number" href="/page/6/">6</a><a class="page-number" href="/page/7/">7</a><a class="extend next" rel="next" href="/page/5/">Nächster</a></nav></div></div><div class="pure-u-1-4 hidden_mid_and_down"><div id="sidebar"><div class="widget"><form action="//www.baidu.com/baidu" method="get" accept-charset="utf-8" target="_blank" class="search-form"><input type="search" name="word" maxlength="20" placeholder="Search"/><input type="hidden" name="si" value="https://kanmars.github.io"/><input name="tn" type="hidden" value="bds"/><input name="cl" type="hidden" value="3"/><input name="ct" type="hidden" value="2097152"/><input name="s" type="hidden" value="on"/></form></div><div class="widget"><div class="widget-title"><i class="fa fa-folder-o"> Kategorien</i></div></div><div class="widget"><div class="widget-title"><i class="fa fa-star-o"> Tags</i></div><div class="tagcloud"><a href="/tags/jetty/" style="font-size: 15px;">jetty</a> <a href="/tags/it/" style="font-size: 15px;">it</a> <a href="/tags/architecture/" style="font-size: 15px;">architecture</a> <a href="/tags/itlife/" style="font-size: 15px;">itlife</a> <a href="/tags/rsa/" style="font-size: 15px;">rsa</a> <a href="/tags/tb/" style="font-size: 15px;">tb</a> <a href="/tags/drawline/" style="font-size: 15px;">drawline</a> <a href="/tags/life/" style="font-size: 15px;">life</a> <a href="/tags/strategy/" style="font-size: 15px;">strategy</a> <a href="/tags/tblife/" style="font-size: 15px;">tblife</a> <a href="/tags/java/" style="font-size: 15px;">java</a> <a href="/tags/linux/" style="font-size: 15px;">linux</a> <a href="/tags/spring/" style="font-size: 15px;">spring</a> <a href="/tags/server/" style="font-size: 15px;">server</a> <a href="/tags/c/" style="font-size: 15px;">c</a> <a href="/tags/c/" style="font-size: 15px;">c++</a> <a href="/tags/lua/" style="font-size: 15px;">lua</a> <a href="/tags/android/" style="font-size: 15px;">android</a> <a href="/tags/javascript/" style="font-size: 15px;">javascript</a> <a href="/tags/neuralnetwork/" style="font-size: 15px;">neuralnetwork</a> <a href="/tags/cpu/" style="font-size: 15px;">cpu</a> <a href="/tags/disk/" style="font-size: 15px;">disk</a> <a href="/tags/fidsk/" style="font-size: 15px;">fidsk</a> <a href="/tags/fstab/" style="font-size: 15px;">fstab</a> <a href="/tags/lvm/" style="font-size: 15px;">lvm</a> <a href="/tags/aix/" style="font-size: 15px;">aix</a></div></div><div class="widget"><div class="widget-title"><i class="fa fa-file-o"> Letzte</i></div><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/2017/01/06/2017-01-06-springcloud_use_002_ssc_configserver/">[KANMARS原创]-SpringCloud-实用篇(2)-configserver</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/12/11/2016-12-11-springcloud_use_001_whatissc/">[KANMARS原创]-SpringCloud-实用篇(1)-什么是springCLoud</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/11/18/2016-11-18-springmvc_source_004_viewresolver/">[KANMARS原创]-SpringMVC源码解析(4) - 视图处理器</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/11/18/2016-11-18-springmvc_source_003_requestprocess/">[KANMARS原创]-SpringMVC源码解析(3) - 请求处理过程</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/11/17/2016-11-17-springmvc_source_002_start/">[KANMARS原创]-SpringMVC源码解析(2) - 启动过程</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/11/17/2016-11-17-springmvc_source_001_introduce/">[KANMARS原创]-SpringMVC源码解析(1) - 简介</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/11/04/2016-11-04-SomeThingAndNothing/">SomeThingAndNothing</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/10/25/2016-10-25-news-LongRoad/">news It's a Long Road</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/10/19/2016-10-19-Scale-Services/">On Designing and Deploying Internet-Scale Services</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/10/18/2016-10-18-dubbo_source_006_summarize/">[KANMARS原创]-DUBBO源码解析(6)-summarize</a></li></ul></div><div class="widget"><div class="comments-title"><i class="fa fa-comment-o"> Letzte Kommentare</i></div><div data-num-items="5" data-show-avatars="0" data-show-time="1" data-show-admin="0" data-excerpt-length="32" data-show-title="1" class="ds-recent-comments"></div></div><div class="widget"><div class="widget-title"><i class="fa fa-external-link"> Blogroll</i></div><ul></ul><a href="http://www.linux.cn" title="Linux-CN" target="_blank">Linux-CN</a><ul></ul><a href="http://www.gome.com.cn" title="国美互联网" target="_blank">国美互联网</a><ul></ul><a href="http://jr.gome.com.cn" title="国美金融" target="_blank">国美金融</a></div></div></div><div class="pure-u-1 pure-u-md-3-4"><div id="footer">© <a href="/." rel="nofollow">KANMARS的博客.</a> Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a><a rel="nofollow" target="_blank" href="https://github.com/tufu9441/maupassant-hexo"> Theme</a> by<a rel="nofollow" target="_blank" href="https://github.com/pagecho"> Cho.</a></div></div></div><a id="rocket" href="#top" class="show"></a><script type="text/javascript" src="/js/totop.js?v=0.0.0" async></script><script type="text/javascript" src="//cdn.bootcss.com/fancybox/2.1.5/jquery.fancybox.pack.js" async></script><script type="text/javascript" src="/js/fancybox.js?v=0.0.0" async></script><link rel="stylesheet" type="text/css" href="/css/jquery.fancybox.css?v=0.0.0"><script>var duoshuoQuery = {short_name:'kanmars'};
(function() {
    var ds = document.createElement('script');
    ds.type = 'text/javascript';ds.async = true;
    ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
    ds.charset = 'UTF-8';
    (document.getElementsByTagName('head')[0]
        || document.getElementsByTagName('body')[0]).appendChild(ds);
})();
</script><script type="text/javascript" src="/js/codeblock-resizer.js?v=0.0.0"></script><script type="text/javascript" src="/js/smartresize.js?v=0.0.0"></script></div></body></html>