<!DOCTYPE html><html lang="null"><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description"><title>KANMARS的博客 | helloword 2046。趁着，我会喜怒你会哀乐，唱几分钟情歌。</title><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/normalize/5.0.0/normalize.min.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/pure/0.6.0/pure-min.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/pure/0.6.0/grids-responsive-min.css"><link rel="stylesheet" type="text/css" href="/css/style.css?v=0.0.0"><link rel="stylesheet" href="//cdn.bootcss.com/font-awesome/4.7.0/css/font-awesome.min.css"><script type="text/javascript" src="//cdn.bootcss.com/jquery/3.1.1/jquery.min.js"></script><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">KANMARS的博客</h1><a id="logo" href="/.">KANMARS的博客</a><p class="description">helloword 2046。趁着，我会喜怒你会哀乐，唱几分钟情歌。</p></div><div id="nav-menu"><a href="/." class="current"><i class="fa fa-home"> Start</i></a><a href="/archives/"><i class="fa fa-archive"> Archiv</i></a><a href="/2016/04/23/2016-04-23-mysongs/"><i class="fa fa-user"> Über</i></a></div></div><div id="layout" class="pure-g"><div class="pure-u-1 pure-u-md-3-4"><div class="content_container"><div class="post"><h2 class="post-title"><a href="/2016/09/18/2016-09-08-dubbo_source_003_serviceBean/">[KANMARS原创]-DUBBO源码解析(3)-serviceBean</a></h2><div class="post-meta">2016-09-18</div><a data-thread-key="2016/09/18/2016-09-08-dubbo_source_003_serviceBean/" href="/2016/09/18/2016-09-08-dubbo_source_003_serviceBean/#comments" class="ds-thread-count"></a><div class="post-content"><p>DUBBO源码解析(3)-serviceBean</p>
<h1 id="一、serviceBean概述"><a href="#一、serviceBean概述" class="headerlink" title="一、serviceBean概述"></a>一、serviceBean概述</h1><p>我们终于讲到了serviceBean这个看似和Dubbo有点直接关系的地方，因为对于dubbo来说，我们最常做的事情，就是配置一个</p></div><p class="readmore"><a href="/2016/09/18/2016-09-08-dubbo_source_003_serviceBean/">Mehr lesen</a></p></div><div class="post"><h2 class="post-title"><a href="/2016/09/18/2016-09-08-dubbo_source_002_proxyFactory/">[KANMARS原创]-DUBBO源码解析(2)-proxyFactory</a></h2><div class="post-meta">2016-09-18</div><a data-thread-key="2016/09/18/2016-09-08-dubbo_source_002_proxyFactory/" href="/2016/09/18/2016-09-08-dubbo_source_002_proxyFactory/#comments" class="ds-thread-count"></a><div class="post-content"><p>DUBBO源码解析(2)-proxyFactory</p>
<p>在ServiceConfig.java和ReferenceConfig.java中有一个神奇的类变量叫做proxyFactory</p>
<h1 id="一、用途"><a href="#一、用途" class="headerlink" title="一、用途"></a>一、用途</h1><p>proxyFactory的接口如下：</p></div><p class="readmore"><a href="/2016/09/18/2016-09-08-dubbo_source_002_proxyFactory/">Mehr lesen</a></p></div><div class="post"><h2 class="post-title"><a href="/2016/09/07/2016-09-07-dubbo_source_001_spi/">[KANMARS原创]-DUBBO源码解析(1)SPI机制</a></h2><div class="post-meta">2016-09-07</div><a data-thread-key="2016/09/07/2016-09-07-dubbo_source_001_spi/" href="/2016/09/07/2016-09-07-dubbo_source_001_spi/#comments" class="ds-thread-count"></a><div class="post-content"><p>PS:恰逢暴雨、回不了家，写点文章……</p>
<p>DUBBO源码解析(1)-SPI机制</p>
<h1 id="一、SPI机制"><a href="#一、SPI机制" class="headerlink" title="一、SPI机制"></a>一、SPI机制</h1><p>SPI机制的全称是Service Provider Interface，单从字面可以理解为Service提供者接口，正如从SPI的名字去理解SPI就是Service提供者接口；</p></div><p class="readmore"><a href="/2016/09/07/2016-09-07-dubbo_source_001_spi/">Mehr lesen</a></p></div><div class="post"><h2 class="post-title"><a href="/2016/07/13/2016-07-13-neuralnetwork_analysis/">[KANMARS原创]-人工神经网络brain.js算法解析</a></h2><div class="post-meta">2016-07-13</div><a data-thread-key="2016/07/13/2016-07-13-neuralnetwork_analysis/" href="/2016/07/13/2016-07-13-neuralnetwork_analysis/#comments" class="ds-thread-count"></a><div class="post-content"><p><br>    <span><span style="font-size:13px;line-height:19.5px;background-color:#FFFFFF;"><br>    在机器学习这一个未来的、伟大的领域，有一个小小的分支叫做人工智能。<br>    </span></span><br></p><br><p><br>    <span><span style="font-size:13px;line-height:19.5px;background-color:#FFFFFF;"><br>    举个例子：照片识别、信用卡图片识别、声音语言解析、数据聚类与离散。<br>    </span></span><br></p><br><p><br>    <span><span style="font-size:13px;line-height:19.5px;background-color:#FFFFFF;"><br>    机器学习按照有无监督者（或者有无导师），区分为监督学习和无监督学习<a href="http://www.cnblogs.com/ysjxw/articles/1149004.html" target="_blank" rel="external">http://www.cnblogs.com/ysjxw/articles/1149004.html</a><br>    </span></span><br></p><br><p><br>    <span><span style="font-size:13px;line-height:19.5px;background-color:#FFFFFF;"><br>    监督学习是最常见的学习分类，在训练集中指出正确的结果，让网络自己去适应这种结果。<br>    </span></span><br></p><br><p><br>    <span><span style="font-size:13px;line-height:19.5px;background-color:#FFFFFF;"><br>    而无监督学习，则大致有两种实现思路。<br>    </span></span><br></p><br><p><br>    <span style="font-family:Verdana, Geneva, Arial, Helvetica, sans-serif;font-size:13px;line-height:19.5px;background-color:#FFFFFF;">第一种思路是在指导Agent时不为其指定明确的分类，而是在成功时采用某种形式的激励制度。</span><br></p><br><p><br>    <span style="font-family:Verdana, Geneva, Arial, Helvetica, sans-serif;font-size:13px;line-height:19.5px;background-color:#FFFFFF;">第二种思路是<span style="font-family:Verdana, Geneva, Arial, Helvetica, sans-serif;font-size:13px;line-height:19.5px;background-color:#FFFFFF;">称之为聚合（原文为clustering，译者注）。这类学习类型的目标不是让效用函数最大化，而是找到训练数据中的近似点。聚合常常能发现那些与假设匹配的相当好的直观分类。例如，基于人口统计的聚合个体可能会在一个群体中形成一个富有的聚合，以及其他的贫穷的聚合。</span></span><br></p><br><p><br>    <span style="font-family:Verdana, Geneva, Arial, Helvetica, sans-serif;font-size:13px;line-height:19.5px;background-color:#FFFFFF;"><br><br></span><br></p><br><p><br>    <span><span style="font-size:13px;line-height:19.5px;background-color:#FFFFFF;">今天我们来从算法上分析一下人工智能的一种实现brain.js。它有输入集、隐层、输出集的基本结构，采用了BP神经网络结构，有自己的激活函数simoid，有自己的误差backpropagation算法。</span></span><br></p><br><p><br>    <span><span style="font-size:13px;line-height:19.5px;background-color:#FFFFFF;"><br><br></span></span><br></p><br><p><br>    <span><span style="font-size:13px;line-height:19.5px;background-color:#FFFFFF;">之前已经有一篇文章介绍了brain.js的用法和内部的代码结构，因此不再赘述，今天重点描述一下brain.js的BP算法和数据结构。了解这些是很有必要的，当你可以熟练掌握这些基础知识，你可以很直接的创造一套自己的人工智能工具，例如：一个简单的验证码识别工具，一个图片分类器，一个看似有点智能的自动对话程序……</span></span><br></p><br><p><br>    <span><span style="font-size:13px;line-height:19.5px;background-color:#FFFFFF;"><br><br></span></span><br></p><br><p><br>    <span style="font-size:24px;"><span style="font-size:24px;line-height:19.5px;background-color:#FFFFFF;"><strong>第一章、构造函数</strong></span></span><br></p><br><p><br>    <span><span style="font-size:13px;line-height:19.5px;background-color:#FFFFFF;"><br><br></span></span><br></p><br><p><br>    <span><span style="font-size:13px;line-height:19.5px;background-color:#FFFFFF;">var NeuralNetwork = function(options) {<br><br>&nbsp; options = options || {};                            //初始化全局变量options<br><br>&nbsp; this.learningRate = options.learningRate || 0.3;    //设置学习比率    是options.learningRate或者0.3<br><br>&nbsp; this.momentum = options.momentum || 0.1;            //惯性比率，用于设置“新的变动的影响程度”<br><br>&nbsp; this.hiddenSizes = options.hiddenLayers;            //隐层的节点的数量是一个二维数组：层数/该层节点数<br><br><br><br>&nbsp; this.binaryThresh = options.binaryThresh || 0.5;    //阈值<br><br>}<br><br>在构造函数中初始化一些全局的值，如备注所式，用于设置一些具有全局性影响的值。<br><br></span></span><br></p><br><p><br>    <span style="font-size:13px;line-height:19.5px;background-color:#FFFFFF;"><br><br></span><br></p><br><p><br>    <span style="font-size:13px;line-height:19.5px;background-color:#FFFFFF;">参数含义如下：</span><br></p><br><p><br>    <span><span style="font-size:13px;line-height:19.5px;background-color:#FFFFFF;"><span style="font-size:13px;line-height:19.5px;background-color:#FFFFFF;">learningRate用于影响</span>节点对新知识的学习速度，如果该比例较大，则每个node在变动时会采用较剧烈的幅度，速度会加快稳定性会下降</span></span><br></p><br><p><br>    <span><span style="font-size:13px;line-height:19.5px;background-color:#FFFFFF;"><span style="font-size:13px;line-height:19.5px;background-color:#FFFFFF;">momentum</span>用于影响节点对旧知识的保留，如果该比例较大，则节点发生的变动会有较剧烈的幅度，速度会加快稳定性会下降<br><br></span></span><br></p><br><p><br>    <span><span style="font-size:13px;line-height:19.5px;background-color:#FFFFFF;"><span style="font-size:13px;line-height:19.5px;background-color:#FFFFFF;">hiddenLayers是隐层的节点的数量，是一个二维数组：层数/该层节点数，涉及在训练时（神经网络从训练开始，因此此句话等价于“在开始时”）初始化隐层节点的数量。</span><br><br></span></span><br></p><br><p><br>    <span><span style="font-size:13px;line-height:19.5px;background-color:#FFFFFF;"><span style="font-size:13px;line-height:19.5px;background-color:#FFFFFF;">binaryThresh是一个阈值</span>,在test模式下才能使用<br><br></span></span><br></p><br><p><br>    <span><span style="font-size:13px;line-height:19.5px;background-color:#FFFFFF;"><br><br></span></span><br></p><br><p><br>    <span style="font-size:24px;"><span style="font-size:24px;line-height:19.5px;background-color:#FFFFFF;"><strong>第二章、训练</strong></span></span><br></p><br><p><br>    <span><span style="font-size:13px;line-height:19.5px;background-color:#FFFFFF;"><br><br></span></span><br></p><br><p><br>    <span><span style="font-size:13px;line-height:19.5px;background-color:#FFFFFF;">train: function(data, options) {<br><br>&nbsp; &nbsp; data = this.formatData(data);<br><br><br><br>&nbsp; &nbsp; ……<br><br>}</span></span><br></p><br><p><br>    <span><span style="font-size:13px;line-height:19.5px;background-color:#FFFFFF;">我们逐行解析一下，挑重要的看：<br><br>var iterations = options.iterations || 20000;                                                    //设置每个节点的迭代次数为20000，用逼近论逐步逼近目标</span></span><br></p><br><p><br>    <span><span style="font-size:13px;line-height:19.5px;background-color:#FFFFFF;">var errorThresh = options.errorThresh || 0.005;                                                    //误差的目标值为0.005</span></span><br></p><br><p><br>    <span><span style="font-size:13px;line-height:19.5px;background-color:#FFFFFF;">……</span></span><br></p><br><p><br>    <span><span style="font-size:13px;line-height:19.5px;background-color:#FFFFFF;">var inputSize = data[0].input.length;                                                            //设置输入数量为data[0]的输入的数组的长度</span></span><br></p><br><p><br>    <span><span style="font-size:13px;line-height:19.5px;background-color:#FFFFFF;">var outputSize = data[0].output.length;                                                            //设置输出数量为data[0]</span></span><br></p><br><p><br>    <span><span style="font-size:13px;line-height:19.5px;background-color:#FFFFFF;">var hiddenSizes = this.hiddenSizes;                                                                //隐层数量</span></span><br></p><br><p><br>    <span><span style="font-size:13px;line-height:19.5px;background-color:#FFFFFF;">if (!hiddenSizes) {                                                                                //如果隐层数量未初始化，则设置隐层数量为一个数组，数组的0号元素为3到inputSize/2的MAX<br><br>&nbsp; &nbsp; &nbsp; hiddenSizes = [Math.max(3, Math.floor(inputSize / 2))];<br><br>}</span></span><br></p><br><p><br>    <span><span style="font-size:13px;line-height:19.5px;background-color:#FFFFFF;">this.initialize(sizes); //初始化，详见第二章第一节、初始化</span></span><br></p><br><p><br>    <span><span style="font-size:13px;line-height:19.5px;background-color:#FFFFFF;"><br><br></span></span><br></p><br><p><br>    <span><span style="font-size:13px;line-height:19.5px;background-color:#FFFFFF;">for (var i = 0; i &lt; iterations &amp;&amp; error &gt; errorThresh; i++) {                                    //遍历iterations次，并且在当前偏差大于误差的目标值为0.005的情况下进行训练<br><br>&nbsp; &nbsp; &nbsp; var sum = 0;                                                                                    //误差初始值为0<br><br>&nbsp; &nbsp; &nbsp; for (var j = 0; j &lt; data.length; j++) {                                                        //对data数量进行逐个训练<br><br>&nbsp; &nbsp; &nbsp; &nbsp; var err = this.trainPattern(data[j].input, data[j].output, learningRate);//详见第二章第二节训练匹配</span></span><br></p><br><p><br>    <span><span style="font-size:13px;line-height:19.5px;background-color:#FFFFFF;">&nbsp; &nbsp; &nbsp; &nbsp; //训练trainPattern，传入的值为第j个输入，第j个输出，学习比率，输出结果为当前这一行数据，在各个网络层各个节点的误差的平方的平均数<br><br>&nbsp; &nbsp; &nbsp; &nbsp; sum += err;                                                                                    //计算误差的和<br><br>&nbsp; &nbsp; &nbsp; }<br><br>&nbsp; &nbsp; &nbsp; error = sum / data.length;                                                                    //计算误差的平均值<br><br><br><br>&nbsp; &nbsp; &nbsp; if (log &amp;&amp; (i % logPeriod == 0)) {                                                            //如果在logPeriod的倍数，则打印日志<br><br>&nbsp; &nbsp; &nbsp; &nbsp; log(“iterations:”, i, “training error:”, error);<br><br>&nbsp; &nbsp; &nbsp; }<br><br>&nbsp; &nbsp; &nbsp; if (callback &amp;&amp; (i % callbackPeriod == 0)) {                                                    //如果在callbackPeriod的倍数，则调用回调函数<br><br>&nbsp; &nbsp; &nbsp; &nbsp; callback({ error: error, iterations: i });<br><br>&nbsp; &nbsp; &nbsp; }<br><br>&nbsp; &nbsp; }<br><br><br><br></span></span><br></p><br><p><br>    <span><span style="font-size:13px;line-height:19.5px;background-color:#FFFFFF;"><br><br><strong><span style="font-size:24px;">第二章第一节、初始化</span></strong></span></span><br></p><br><p><br>    <span><span style="font-size:13px;line-height:19.5px;background-color:#FFFFFF;">this.initialize(sizes);</span></span><br></p><br><p><br>    <span><span style="font-size:13px;line-height:19.5px;background-color:#FFFFFF;">在该方法内部，会对神经网络的数据结构进行初始化，代码比较简单，我们关键描述几个数据结构</span></span><br></p><br><p><br>    <span><span style="font-size:13px;line-height:19.5px;background-color:#FFFFFF;">this.outputLayer = this.sizes.length - 1;        //输出层的最后一个下标</span></span><br></p><br><p><br>    <span><span style="font-size:13px;line-height:19.5px;background-color:#FFFFFF;">this.biases = []; //阈值的二维数组:层/值</span></span><br></p><br><p><br>    <span><span style="font-size:13px;line-height:19.5px;background-color:#FFFFFF;">this.weights = [];                                //权重的三维数组:层/节点/值    [layer][node][k]</span></span><br></p><br><p><br>    <span><span style="font-size:13px;line-height:19.5px;background-color:#FFFFFF;">this.outputs = [];                                //输出结果的二维数组:层/值</span></span><br></p><br><p><br>    <span><span style="font-size:13px;line-height:19.5px;background-color:#FFFFFF;">this.deltas = [];                                //偏差的二维数组：层/值</span></span><br></p><br><p><br>    <span><span style="font-size:13px;line-height:19.5px;background-color:#FFFFFF;">this.changes = []; // for momentum                //改变值的三维数组：层/节点/值    [layer][node][k]</span></span><br></p><br><p><br>    <span><span style="font-size:13px;line-height:19.5px;background-color:#FFFFFF;">this.errors = [];                                //误差的二维数组：层/值</span></span><br></p><br><p><br>    <span><span style="font-size:13px;line-height:19.5px;background-color:#FFFFFF;"><strong><span style="font-size:24px;"></span></strong><strong><span style="font-size:24px;"></span></strong><strong><span style="font-size:24px;"></span></strong><strong><span style="font-size:24px;"></span></strong><strong><span style="font-size:24px;">第二章第二节、训练匹配</span></strong><br><br></span></span><br></p><br><p><br>    <span><span style="font-size:13px;line-height:19.5px;background-color:#FFFFFF;"><span style="font-size:13px;line-height:19.5px;background-color:#FFFFFF;">this.trainPattern(data[j].input, data[j].output, learningRate);</span><br><br></span></span><br></p><br><p><br>    <span><span style="font-size:13px;line-height:19.5px;background-color:#FFFFFF;">该方法在两层循环中被调用，第一层循环为训练次数iterations，第二层循环为data[j]输入的数据的数量</span></span><br></p><br><p><br>    <span><span style="font-size:13px;line-height:19.5px;background-color:#FFFFFF;">完成了加快训练的效果（目前很多神经网络的重点就在提高训练速度和减少误差的方向上）</span></span><br></p><br><p><br>    <span><span style="font-size:13px;line-height:19.5px;background-color:#FFFFFF;">this.runInput(input);//信号的前馈传播，详见第二章第二节第一部分、信号的前馈传播<br><br><br><br>this.calculateDeltas(target);//计算误差deltas，详见第二章第二节第二部分、误差的反向传播一计算误差deltas<br><br><br><br>this.adjustWeights(learningRate);//重新计算权重，详见第二章第二节第三部分，误差的反向传播二权重的重新调整<br><br></span></span><br></p><br><p><br>    <span><span style="font-size:13px;line-height:19.5px;background-color:#FFFFFF;"><br><br></span></span><br></p><br><p><br>    <span style="font-size:24px;"><span style="font-size:24px;line-height:19.5px;background-color:#FFFFFF;"><span style="font-size:24px;line-height:19.5px;background-color:#FFFFFF;"><strong>第二章第二节第一部分、信号的前馈传播</strong></span></span></span><br></p><br><p><br>    <span><span style="font-size:13px;line-height:19.5px;background-color:#FFFFFF;"><span style="font-size:13px;line-height:19.5px;background-color:#FFFFFF;">this.runInput(input);//</span><span style="font-size:13px;line-height:19.5px;background-color:#FFFFFF;">信号的前馈传播</span></span></span><br></p><br><p><br>    <span><span style="font-size:13px;line-height:19.5px;background-color:#FFFFFF;">对input为单行的输入数据向量进行操作，该方法代表了一个神经网络对某行数据的操作<br><br></span></span><br></p><br><p><br>    <span><span style="font-size:13px;line-height:19.5px;background-color:#FFFFFF;">this.outputs[0] = input;//设置this.outputs的第0个元素为输入的数据<br><br><br><br>&nbsp; &nbsp;&nbsp;<span style="font-size:13px;line-height:19.5px;background-color:#FFFFFF;">//针对每个输出层/隐层去执行，从第一层开始，（0层为输入）</span><br><br>&nbsp; &nbsp; for (var layer = 1; layer &lt;= this.outputLayer; layer++) {</span></span><br></p><br><p><br>    <span><span style="font-size:13px;line-height:19.5px;background-color:#FFFFFF;">&nbsp; &nbsp; &nbsp; <span style="font-size:13px;line-height:19.5px;background-color:#FFFFFF;">//针对当前隐层的节点进行操作</span>&nbsp;<br><br>&nbsp; &nbsp; &nbsp; for (var node = 0; node &lt; this.sizes[layer]; node++) {&nbsp;</span></span><br></p><br><p><br>    <span><span style="font-size:13px;line-height:19.5px;background-color:#FFFFFF;">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp;<span style="font-size:13px;line-height:19.5px;background-color:#FFFFFF;">//获取当前节点的权重数组</span><br><br>&nbsp; &nbsp; &nbsp; &nbsp; var weights = this.weights[layer][node];&nbsp;<br><br>&nbsp; &nbsp; &nbsp; &nbsp;&nbsp;<span style="font-size:13px;line-height:19.5px;background-color:#FFFFFF;">//获取当前节点的阈值</span><br><br>&nbsp; &nbsp; &nbsp; &nbsp; var sum = this.biases[layer][node];&nbsp;</span></span><br></p><br><p><br>    <span><span style="font-size:13px;line-height:19.5px;background-color:#FFFFFF;">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp;<span style="font-size:13px;line-height:19.5px;background-color:#FFFFFF;">//对每个输入项进行遍历</span><br><br>&nbsp; &nbsp; &nbsp; &nbsp; for (var k = 0; k &lt; weights.length; k++) {&nbsp;</span></span><br></p><br><p><br>    <span><span style="font-size:13px;line-height:19.5px;background-color:#FFFFFF;">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;<span style="font-size:13px;line-height:19.5px;background-color:#FFFFFF;">//总和等于当前节点和上一个节点的输入乘以权重</span><br><br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; sum += weights[k] <em> input[k];&nbsp;<br><br>&nbsp; &nbsp; &nbsp; &nbsp; }<br><br>&nbsp; &nbsp; &nbsp; &nbsp;&nbsp;</em></span></span><br></p><br><p><br>    <span><span style="font-size:13px;line-height:19.5px;background-color:#FFFFFF;">&nbsp; &nbsp; &nbsp; &nbsp; //激活函数-输出值等于1除以(1+-sum的以e为底的指数函数,即e的-sum次方，位于0-1之间)</span></span><br></p><br><p><br>    <span><span style="font-size:13px;line-height:19.5px;background-color:#FFFFFF;">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp;<span style="font-size:13px;line-height:19.5px;background-color:#FFFFFF;">this.outputs[layer][node] = 1 / (1 + Math.exp(-sum));</span><br><br>&nbsp; &nbsp; &nbsp; } <br><br>&nbsp; &nbsp; &nbsp; var output = input = this.outputs[layer];                                                        //递归将当前的输出作为下一层的输入<br><br>&nbsp; &nbsp; }<br><br>&nbsp; &nbsp; return output;                                                                                    //在所有层的神经网络通过之后，输出结果<br><br><br><br></span></span><br></p><br><p><br>    <span><span style="font-size:13px;line-height:19.5px;background-color:#FFFFFF;"><span style="font-size:13px;line-height:19.5px;background-color:#FFFFFF;">上述代码中的激活函数，并不是去激活什么，而是指<span style="color:#E53333;"><strong>如何把“激活的神经元的特征”通过函数把特征保留并映射出来</strong></span>（保留特征，去除一些数据中的冗余），<span style="color:#E53333;"><strong>这是神经网络能解决非线性问题关键</strong></span>。</span><br><br><span style="font-size:13px;line-height:19.5px;background-color:#FFFFFF;">激活函数是用来加入非线性因素的，因为线性模型的表达力不够</span><br><br><span style="font-size:13px;line-height:19.5px;background-color:#FFFFFF;">该算法为simoid激活函数，但是如果出现极值，该算法可能会出现大批节点死亡，即值为0无法激活的情况</span><br><br><span style="font-size:13px;line-height:19.5px;background-color:#FFFFFF;">其他可选算法推荐ReLU即f(x)=max(x,0);比较简单</span><br><br><span style="font-size:13px;line-height:19.5px;background-color:#FFFFFF;">关于激活函数的研究，可以参考<a href="http://www.mamicode.com/info-detail-873243.html" target="_blank" rel="external">http://www.mamicode.com/info-detail-873243.html</a></span><br><br><span style="font-size:13px;line-height:19.5px;background-color:#FFFFFF;">①单侧抑制    //通过激活函数把特征保留并映射出来</span><br><br><span style="font-size:13px;line-height:19.5px;background-color:#FFFFFF;">②相对宽阔的兴奋边界    //??</span><br><br><span style="font-size:13px;line-height:19.5px;background-color:#FFFFFF;">③稀疏激活性    //节省能量，生物神经具有稀疏激活性，因此在数学逻辑上也是需要有稀疏激活特性的</span><br><br></span></span><br></p><br><p><br>    <span><span style="font-size:13px;line-height:19.5px;background-color:#FFFFFF;"><br><br></span></span><br></p><br><p><br>    <span style="font-size:13px;line-height:19.5px;background-color:#FFFFFF;">以上红色内容，是小白理解神经网络的关键~~~</span><br></p><br><p><br>    <span style="font-size:13px;line-height:19.5px;background-color:#FFFFFF;">但是对于专业数学家，这个是需要用数学证明的：证明特征是可再分的，再分的特征根据贝叶斯公式，多个特征将会休整人的信念，再根据逼近论用较简单的函数来代替复杂的函数。</span><br></p><br><p><br>    <span style="font-size:13px;line-height:19.5px;background-color:#FFFFFF;"><br><br></span><br></p><br><p><br>    <span style="font-size:13px;line-height:19.5px;background-color:#FFFFFF;">最终可以通过任意个节点来拟合任何一个复杂函数。</span><br></p><br><p><br>    <span style="font-size:13px;line-height:19.5px;background-color:#FFFFFF;">这就是神经网络最神奇之处，它可以实现任何一个符合函数的拟合，也就是说：输入一个图片，它能告诉你这张图片上的物种叫做猫。</span><br></p><br><p><br>    <span><span style="font-size:13px;line-height:19.5px;background-color:#FFFFFF;"><br><br></span></span><br></p><br><p><br>    <span><span style="font-size:13px;line-height:19.5px;background-color:#FFFFFF;"><br><br><br><br><span style="font-size:24px;line-height:19.5px;background-color:#FFFFFF;"><strong>第二章第二节第二部分、误差的反向传播一计算误差deltas</strong></span></span></span><br></p><br><p><br>    <span><span style="font-size:13px;line-height:19.5px;background-color:#FFFFFF;"><span style="font-size:13px;line-height:19.5px;background-color:#FFFFFF;">this.calculateDeltas(target);//计算误差deltas</span><br><br>在BP神经网络中、误差的反向传播，进而对权重进行调整是核心内容</span></span><br></p><br><p><br>    <span><span style="font-size:13px;line-height:19.5px;background-color:#FFFFFF;"><br><br></span></span><br></p><br><p><br>    <span><span style="font-size:13px;line-height:19.5px;background-color:#FFFFFF;">代码如下：</span></span><br></p><br><p><br>    <span><span style="font-size:13px;line-height:19.5px;background-color:#FFFFFF;">calculateDeltas: function(target) {                                                                //误差计算<br><br>&nbsp; &nbsp; for (var layer = this.outputLayer; layer &gt;= 0; layer–) {                                        //对每个输出层进行遍历，逆向计算<br><br>&nbsp; &nbsp; &nbsp; for (var node = 0; node &lt; this.sizes[layer]; node++) {                                        //对当前层的节点数进行遍历<br><br>&nbsp; &nbsp; &nbsp; &nbsp; var output = this.outputs[layer][node];                                                        //获取当前节点的输出<br><br><br><br>&nbsp; &nbsp; &nbsp; &nbsp; var error = 0;                                                                                //偏差为0<br><br>&nbsp; &nbsp; &nbsp; &nbsp; if (layer == this.outputLayer) {                                                            //如果是最后一层<br><br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; error = target[node] - output;                                                            //误差等于目标值减去输出-》即初始误差<br><br>&nbsp; &nbsp; &nbsp; &nbsp; }<br><br>&nbsp; &nbsp; &nbsp; &nbsp; else {                                                                                        //非最后一层<br><br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; var deltas = this.deltas[layer + 1];                                                        //获取到下一层的误差的数组</span></span><br></p><br><p><br>    <span><span style="font-size:13px;line-height:19.5px;background-color:#FFFFFF;">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; //deltas在最后一层时赋予了初始值，此后随着层数的减少，低次获取上一次的误差//deletas是二维数组，层/值<br><br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; for (var k = 0; k &lt; deltas.length; k++) {<br><br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; error += deltas[k]  this.weights[layer + 1][k][node];</span></span><br></p><br><p><br>    <span><span style="font-size:13px;line-height:19.5px;background-color:#FFFFFF;">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; //当前节点的error为下一层的偏差按照权重的总和值</span></span><br></p><br><p><br>    <span><span style="font-size:13px;line-height:19.5px;background-color:#FFFFFF;">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; //此处对误差的评估有多种算法，算数加权 &nbsp;为其中一种，此外还有开方差等方法<br><br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br><br>&nbsp; &nbsp; &nbsp; &nbsp; }<br><br>&nbsp; &nbsp; &nbsp; &nbsp; this.errors[layer][node] = error;                                                            //当前层，当前node的error<br><br>&nbsp; &nbsp; &nbsp; &nbsp; this.deltas[layer][node] = error <em> output </em> (1 - output);&nbsp;<br><br>&nbsp; &nbsp; &nbsp; }<br><br>&nbsp; &nbsp; }<br><br>&nbsp; },</span></span><br></p><br><p><br>    <span><span style="font-size:13px;line-height:19.5px;background-color:#FFFFFF;">上述代码有两个要点</span></span><br></p><br><p><br>    <span><span style="font-size:13px;line-height:19.5px;background-color:#FFFFFF;">1、error的计算，是通过下一层的误差根据权重汇总起来的</span></span><br></p><br><p><br>    <span><span style="font-size:13px;line-height:19.5px;background-color:#FFFFFF;">2、deltas的计算，是通过公式deltas=error <em> output </em> (1-output)计算出的</span></span><br></p><br><p><br>    <span><span style="font-size:13px;line-height:19.5px;background-color:#FFFFFF;"><br><br></span></span><br></p><br><p><br>    <span><span style="font-size:13px;line-height:19.5px;background-color:#FFFFFF;"><br><br></span></span><br></p><br><p><br>    <span><span style="font-size:13px;line-height:19.5px;background-color:#FFFFFF;"><span style="font-size:13px;line-height:19.5px;background-color:#FFFFFF;">在最后一行代码中，有一个神奇的deltas = error<em>output</em>(1-output)</span><br><br></span></span><br></p><br><p><br>    <span><span style="font-size:13px;line-height:19.5px;background-color:#FFFFFF;"><span style="font-size:13px;line-height:19.5px;background-color:#FFFFFF;">//当前层，当前node的为errors误差 <em> 当层的输出 </em> (1-当层的输出)</span><br><br><span style="font-size:13px;line-height:19.5px;background-color:#FFFFFF;">//该算法为BP前馈申请网络的误差传播算法，详见论文<a href="http://www.doc88.com/p-601587528491.html" target="_blank" rel="external">http://www.doc88.com/p-601587528491.html</a></span><br><br><span style="font-size:13px;line-height:19.5px;background-color:#FFFFFF;">//大概原理如下:BP</span><br><br><span style="font-size:13px;line-height:19.5px;background-color:#FFFFFF;">//BP算法实质是求取误差函数的最小值问题。采用非线性规划中的最速下降方法，按误差函数的负</span><br><br><span style="font-size:13px;line-height:19.5px;background-color:#FFFFFF;">//梯度方向修改权系数。从其数学表达可知：多层网络的训练方法是把一个样本加到输入层，并根据</span><br><br><span style="font-size:13px;line-height:19.5px;background-color:#FFFFFF;">//向前传播的规则X(k,j) = f(U(k,j))，一层一层向输出层传递，最终在输出层得到输出X(m,i)，把X(m,i)</span><br><br><span style="font-size:13px;line-height:19.5px;background-color:#FFFFFF;">//和期望输出Yi进行比较，若两者不等，则产生误差信号e，接着按下式反向传播修改权系</span><br><br><span style="font-size:13px;line-height:19.5px;background-color:#FFFFFF;">//此处公式推导可见<a href="http://blog.csdn.net/zhouchengyunew/article/details/6267193的“二、BP算法的数学表达”章节" target="_blank" rel="external">http://blog.csdn.net/zhouchengyunew/article/details/6267193的“二、BP算法的数学表达”章节</a></span><br><br><span style="font-size:13px;line-height:19.5px;background-color:#FFFFFF;">//或者关于BP网络的数学表达可以参见<a href="http://www.cnblogs.com/wengzilin/archive/2013/04/24/3041019.html" target="_blank" rel="external">http://www.cnblogs.com/wengzilin/archive/2013/04/24/3041019.html</a></span><br><br><span style="font-size:13px;line-height:19.5px;background-color:#FFFFFF;">//最终结论为this.deltas[layer][node] = error <em> output </em> (1 - output);</span><br><br><br><br><span style="font-size:13px;line-height:19.5px;background-color:#FFFFFF;">//但比较粗糙直观的理解是:</span></span></span><br></p><br><p><br>    <span><span style="font-size:13px;line-height:19.5px;background-color:#FFFFFF;"><span style="font-size:13px;line-height:19.5px;background-color:#FFFFFF;">//<strong><span style="color:#E53333;">计算出的error是子层误差的总和，而output和(1-output)是一种修正，因本例中激活函数为simoid，因此output在(0,1)之间</span></strong></span><br><br><span style="font-size:13px;line-height:19.5px;background-color:#FFFFFF;">//<span style="color:#E53333;"><strong>因此output和(1-output)呈x在[0-1]区间的倒U型，因此output如果位于0.5时，error就会有较大的变动，</strong></span></span></span></span><br></p><br><p><br>    <span><span style="font-size:13px;line-height:19.5px;background-color:#FFFFFF;"><span style="font-size:13px;line-height:19.5px;background-color:#FFFFFF;">//<span style="color:#E53333;"><strong>位于两边时，就会有较小的变动，因此</strong></span></span><span style="font-size:13px;line-height:19.5px;color:#E53333;background-color:#FFFFFF;"><strong>delta = error <em> output </em> (1 - output);    这个函数就会有一种“趋势”来</strong></span></span></span><br></p><br><p><br>    <span><span style="font-size:13px;line-height:19.5px;background-color:#FFFFFF;"><span style="font-size:13px;line-height:19.5px;background-color:#FFFFFF;">//<span style="color:#E53333;"><strong>倾向与0，结合adjustWeights误差反向传播调整公式，</strong></span></span><span style="font-size:13px;line-height:19.5px;color:#E53333;background-color:#FFFFFF;"><strong>就会使误差在最终趋向于0-&gt;实现“误差降低的特性”</strong></span><br><br></span></span><br></p><br><p><br>    <span><span style="font-size:13px;line-height:19.5px;background-color:#FFFFFF;"><br><br></span></span><br></p><br><p><br>    <span><span style="font-size:13px;line-height:19.5px;background-color:#FFFFFF;"><br><br><br><br><span style="font-size:24px;line-height:19.5px;background-color:#FFFFFF;"><strong>第二章第二节第三部分，误差的反向传播二权重的重新调整</strong></span></span></span><br></p><br><p><br>    <span><span style="font-size:13px;line-height:19.5px;background-color:#FFFFFF;"><span style="font-size:13px;line-height:19.5px;background-color:#FFFFFF;"><br><br></span></span></span><br></p><br><p><br>    <span><span style="font-size:13px;line-height:19.5px;background-color:#FFFFFF;"><span style="font-size:13px;line-height:19.5px;background-color:#FFFFFF;">this.adjustWeights(learningRate);                                                                //重新计算权重—-此处为核心操作</span></span></span><br></p><br><p><br>    <span><span style="font-size:13px;line-height:19.5px;background-color:#FFFFFF;"><span style="font-size:13px;line-height:19.5px;background-color:#FFFFFF;"><br><br></span></span></span><br></p><br><p><br>    <span><span style="font-size:13px;line-height:19.5px;background-color:#FFFFFF;"><span style="font-size:13px;line-height:19.5px;background-color:#FFFFFF;">adjustWeights: function(learningRate) {<br><br>&nbsp; &nbsp; for (var layer = 1; layer &lt;= this.outputLayer; layer++) {                                        //对所有的层进行判断，除了输入层<br><br>&nbsp; &nbsp; &nbsp; var incoming = this.outputs[layer - 1];                                                        //incoming为上一层的输出，这一层的输入<br><br><br><br>&nbsp; &nbsp; &nbsp; for (var node = 0; node &lt; this.sizes[layer]; node++) {                                        //对当层的节点进行遍历<br><br>&nbsp; &nbsp; &nbsp; &nbsp; var delta = this.deltas[layer][node];                                                        //获取到当前节点的delta    是一个数字，为下一层的error<em>下一层的output</em>(1-下一层的output)<br><br><br><br>&nbsp; &nbsp; &nbsp; &nbsp; for (var k = 0; k &lt; incoming.length; k++) {                                                    //根据上一层的输入节点<br><br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; var change = this.changes[layer][node][k];                                                //获取到变动前的change<br><br><br><br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; change = (learningRate <em> delta </em> incoming[k])                                                //对当前节点的change进行修正 &nbsp;change = (学习比率 <em> 差值 </em> 上一层的该点的输出值) + (当前的保持的势能<em> 之前的change)<br><br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;+ (this.momentum </em> change);                                                        //其核心原理在于error越小-&gt;delta越小-&gt;change越小—-&gt;具有逼近作用<br><br><br><br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; this.changes[layer][node][k] = change;                                                    //对当前的change进行保存<br><br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; this.weights[layer][node][k] += change;                                                    //将change增加到weight上<br><br>&nbsp; &nbsp; &nbsp; &nbsp; }<br><br>&nbsp; &nbsp; &nbsp; &nbsp; this.biases[layer][node] += learningRate <em> delta;                                            //重新设置biases阈值<br><br>&nbsp; &nbsp; &nbsp; }<br><br>&nbsp; &nbsp; }<br><br>&nbsp; },<br><br><br><br></em></span></span></span><br></p><br><p><br>    <span><span style="font-size:13px;line-height:19.5px;background-color:#FFFFFF;"><span style="font-size:13px;line-height:19.5px;background-color:#FFFFFF;"><br><br></span></span></span><br></p><br><p><br>    <span><span style="font-size:13px;line-height:19.5px;background-color:#FFFFFF;"><span style="font-size:13px;line-height:19.5px;background-color:#FFFFFF;">关键在于change 的计算和 weights的计算</span></span></span><br></p><br><p><br>    <span><span style="font-size:13px;line-height:19.5px;background-color:#FFFFFF;"><span style="font-size:13px;line-height:19.5px;background-color:#FFFFFF;"><span style="font-size:13px;line-height:19.5px;background-color:#FFFFFF;">change = (learningRate  delta <em> incoming[k])</em></span>&nbsp;<span style="font-size:13px;line-height:19.5px;background-color:#FFFFFF;">+ (this.momentum  change)&nbsp;</span><br><br></span></span></span><br></p><br><p><br>    <span><span style="font-size:13px;line-height:19.5px;background-color:#FFFFFF;"><span style="font-size:13px;line-height:19.5px;background-color:#FFFFFF;"><span style="font-size:13px;line-height:19.5px;background-color:#FFFFFF;">其核心原理在于error越小-&gt;delta越小-&gt;change越小—-&gt;具有逼近作用</span></span></span></span><br></p><br><p><br>    <span><span style="font-size:13px;line-height:19.5px;background-color:#FFFFFF;"><span style="font-size:13px;line-height:19.5px;background-color:#FFFFFF;"><br><br></span></span></span><br></p><br><p><br>    <span><span style="font-size:13px;line-height:19.5px;background-color:#FFFFFF;"><span style="font-size:13px;line-height:19.5px;background-color:#FFFFFF;"><strong><span style="color:#E53333;">由上文可知delta是趋向于0的，因此change是最终趋向于0</span></strong><br><br></span></span></span><br></p><br><p><br>    <span><span style="font-size:13px;line-height:19.5px;background-color:#FFFFFF;"><span style="font-size:13px;line-height:19.5px;background-color:#FFFFFF;"><br><br></span></span></span><br></p><br><p><br>    <span><span style="font-size:13px;line-height:19.5px;background-color:#FFFFFF;"><span style="font-size:13px;line-height:19.5px;background-color:#FFFFFF;">而weights的计算公式为</span></span></span><br></p><br><p><br>    <span><span style="font-size:13px;line-height:19.5px;background-color:#FFFFFF;"><span style="font-size:13px;line-height:19.5px;background-color:#FFFFFF;"><span style="font-size:13px;line-height:19.5px;background-color:#FFFFFF;">this.weights[layer][node][k] += change;</span></span></span></span><br></p><br><p><br>    <span style="color:#E53333;"><span style="font-size:13px;line-height:19.5px;color:#E53333;background-color:#FFFFFF;"><span style="font-size:13px;line-height:19.5px;color:#E53333;background-color:#FFFFFF;"><strong>因为change最终趋于0，因此weights最终趋于固定值，即：神经网络的联结的权重最终趋于固定值。</strong></span></span></span><br></p><br><p><br>    <span><span style="font-size:13px;line-height:19.5px;background-color:#FFFFFF;"><span style="font-size:13px;line-height:19.5px;background-color:#FFFFFF;"><br><br></span></span></span><br></p><br><p><br>    <span><span style="font-size:13px;line-height:19.5px;background-color:#FFFFFF;"><span style="font-size:13px;line-height:19.5px;background-color:#FFFFFF;"><br><br></span></span></span><br></p><br><p><br>    <span style="color:#000000;font-size:24px;"><span style="font-size:24px;line-height:19.5px;color:#000000;background-color:#FFFFFF;"><span style="font-size:24px;line-height:19.5px;color:#000000;background-color:#FFFFFF;"><strong>第三章、运行</strong></span></span></span><br></p><br><p><br>    <span><span style="font-size:13px;line-height:19.5px;background-color:#FFFFFF;"><span style="font-size:13px;line-height:19.5px;background-color:#FFFFFF;"><br><br></span></span></span><br></p><br><p><br>    <span><span style="font-size:13px;line-height:19.5px;background-color:#FFFFFF;"><span style="font-size:13px;line-height:19.5px;background-color:#FFFFFF;">run: function(input) {<br><br>&nbsp; &nbsp; if (this.inputLookup) {<br><br>&nbsp; &nbsp; &nbsp; input = lookup.toArray(this.inputLookup, input);<br><br>&nbsp; &nbsp; }<br><br><br><br>&nbsp; &nbsp; var output = this.runInput(input);<br><br><br><br>&nbsp; &nbsp; if (this.outputLookup) {<br><br>&nbsp; &nbsp; &nbsp; output = lookup.toHash(this.outputLookup, output);<br><br>&nbsp; &nbsp; }<br><br>&nbsp; &nbsp; return output;<br><br>&nbsp; },<br><br><br><br></span></span></span><br></p><br><p><br>    <span><span style="font-size:13px;line-height:19.5px;background-color:#FFFFFF;"><span style="font-size:13px;line-height:19.5px;background-color:#FFFFFF;"><br><br></span></span></span><br></p><br><p><br>    <span><span style="font-size:13px;line-height:19.5px;background-color:#FFFFFF;"><span style="font-size:13px;line-height:19.5px;background-color:#FFFFFF;">调用了runInput方法，最终的输出结果为output</span></span></span><br></p><br><p><br>    <span><span style="font-size:13px;line-height:19.5px;background-color:#FFFFFF;"><span style="font-size:13px;line-height:19.5px;background-color:#FFFFFF;">方法不再赘述。</span></span></span><br></p><br><p><br>    <span><span style="font-size:13px;line-height:19.5px;background-color:#FFFFFF;"><span style="font-size:13px;line-height:19.5px;background-color:#FFFFFF;">—————————————————————————————————</span></span></span><br></p><br><p><br>    <span><span style="font-size:13px;line-height:19.5px;background-color:#FFFFFF;"><span style="font-size:13px;line-height:19.5px;background-color:#FFFFFF;"><br><br></span></span></span><br></p><br><p><br>    <span><span style="font-size:13px;line-height:19.5px;background-color:#FFFFFF;"><span style="font-size:13px;line-height:19.5px;background-color:#FFFFFF;">由以上分析看到，神经网络最大的作用就是“拟合”一个复杂函数，该函数输入一堆复杂的值，通过训练，使得一些小函数的和最终模拟出了一个确定的值(逼近论)。</span></span></span><br></p><br><p><br>    <span><span style="font-size:13px;line-height:19.5px;background-color:#FFFFFF;"><span style="font-size:13px;line-height:19.5px;background-color:#FFFFFF;"><br><br></span></span></span><br></p><br><p><br>    <span><span style="font-size:13px;line-height:19.5px;background-color:#FFFFFF;"><span style="font-size:13px;line-height:19.5px;background-color:#FFFFFF;">这种特性在“图像识别”“声音识别”等机器视觉和机器听觉领域十分有用。</span></span></span><br></p><br><p><br>    <span><span style="font-size:13px;line-height:19.5px;background-color:#FFFFFF;"><span style="font-size:13px;line-height:19.5px;background-color:#FFFFFF;"><br><br></span></span></span><br></p><br><p><br>    <span><span style="font-size:13px;line-height:19.5px;background-color:#FFFFFF;"><span style="font-size:13px;line-height:19.5px;background-color:#FFFFFF;">但是：上述例子的输出结果只能是0~1的数值，代表了是或者否的判断，例如输入一堆图片，判断这些图片上是否有一只猫，它会告诉你是或者否</span></span></span><br></p><br><p><br>    <span><span style="font-size:13px;line-height:19.5px;background-color:#FFFFFF;"><span style="font-size:13px;line-height:19.5px;background-color:#FFFFFF;"><br><br></span></span></span><br></p><br><p><br>    <span style="font-size:13px;line-height:19.5px;background-color:#FFFFFF;">倘若：你需要输入一堆图片，然后将图片分成五类，或者输出一个图片的色情度是0%还是10000%，它需要进行一些深度的改造。</span><br></p><br><p><br>    <span style="font-size:13px;line-height:19.5px;background-color:#FFFFFF;">————————————————————————————————–</span><br></p><br><p><br>    <span><span style="font-size:13px;line-height:19.5px;background-color:#FFFFFF;"><span style="font-size:13px;line-height:19.5px;background-color:#FFFFFF;">由于人类大脑本身的运行机制还不清晰，因此很难说这种程度的人工智能能否真正匹配真实的人类智能。</span></span></span><br></p><br><p><br>    <span><span style="font-size:13px;line-height:19.5px;background-color:#FFFFFF;"><span style="font-size:13px;line-height:19.5px;background-color:#FFFFFF;"><br><br></span></span></span><br></p><br><p><br>    <span><span style="font-size:13px;line-height:19.5px;background-color:#FFFFFF;"><span style="font-size:13px;line-height:19.5px;background-color:#FFFFFF;">但前段时间的阿尔法狗人机大战，说明了人类的智能或许在本质上就是一种对过往的拟合，兴许抽象点说：能看懂的都是科学，看不懂但是有效果的叫做智能，看不懂也没效果但是还有人信的叫做宗教</span></span></span><br></p><br><p><br>    <span><span style="font-size:13px;line-height:19.5px;background-color:#FFFFFF;"><span style="font-size:13px;line-height:19.5px;background-color:#FFFFFF;"><br><br></span></span></span><br></p><br><p><br>    <span><span style="font-size:13px;line-height:19.5px;background-color:#FFFFFF;"><span style="font-size:13px;line-height:19.5px;background-color:#FFFFFF;">人工做了一个程序，实现了看不懂但是有效果的功能，这就是人工智能。</span></span></span><br></p><br><p><br>    <br><br></p><br><p><br>    此外人工智能领域从去年开始CNN比较火热，就是卷积神经网络，<span>用隐层的深度换单个隐层的宽度</span>，这又是另一个课题了，我比较有兴趣的是：卷积层究竟是由人类硬编码实现的？还是由人工智能训练出的？还是由人工智能在漫长的训练中自发形成的？<br></p><br><p><br>    <br><br></p><br><p><br>    <br><br></p></div><p class="readmore"><a href="/2016/07/13/2016-07-13-neuralnetwork_analysis/">Mehr lesen</a></p></div><div class="post"><h2 class="post-title"><a href="/2016/06/06/2016-06-06-whoami/">[KANMARS原创]-我究竟是怎么样的一个程序员</a></h2><div class="post-meta">2016-06-06</div><a data-thread-key="2016/06/06/2016-06-06-whoami/" href="/2016/06/06/2016-06-06-whoami/#comments" class="ds-thread-count"></a><div class="post-content"><p><br>    我究竟是怎么样一个程序员。总结那么几个标签：<span>勤奋、</span>浪、嘴炮型诗人。<br></p><br><p><br>    ——————————————————————————————–<br></p><br><p><br>    一、<span>勤奋</span><br></p><br><p><br>    <span>也许我在别的方面很懒，但是在编程方面我还是自认勤奋的，举个栗子：</span><br></p><br><p><br>    <span>1、结婚前一晚，花一夜看完了《UNIX进程间通讯》；</span><br></p><br><p><br>    <span>2、半夜睡不着就翻译一篇神经网络文章brain.js</span><br></p><br><p><br>    <span>3、星期六星期天不喜欢出门，喜欢在家看代码玩</span><br></p><br><p><br>    <span>4、。。。。。。</span><br></p><br><p><br>    就像我之前看到的一句话：过了这条线，coding就不是为了钱是为了多巴胺了。这条线之上，程序不再是工具，而是玩具，会让你感到兴奋。你能感觉到语言，代码，算法，模式，思想都碎成粉碎，一块块等着你来拼。你能体会到程序里齿轮般环环相扣的精巧。你能闻到代码的味道，看到代码的形状。<span id="__kindeditor_bookmark_end_14__"></span><br></p><br><p><br>    <br><br></p><br><p><br>    我依稀觉得我差不多在这线的附近了，因为我看到程序就感觉看到了玩具一样，不论是任何语言，不论是任何模式。<br></p><br><p><br>    <br><br></p><br><p><br>    而我的学习方法，大致是：<br></p><br><p><br>    1、遇到一个不知道的东西，先让它能用，再让它好用；<br><br>2、把它拆成小碎块，然后拼成我需要的样子；<br><br>3、<span>再系统学习一遍这个东西的文档，看看别人是怎么拼的，或者有没有什么神奇的小碎块；</span><br></p><br><p><br>    4、<span>随着小碎块越攒越多，我就能拼出越来越复杂的东西，我就越来越强大；</span><br></p><br><p><br>    <br><br></p><br><p><br>    <br><br></p><br><p><br>    ————–世界上有很多大神————-<br><br><br><br>————–你也可以成为其中一尊————–<br></p><br><p><br>    <br><br></p><br><p><br>    <br><br></p><br><p><br>    二、浪<br></p><br><p><br>    浪，是我对自己的评价。但当我想举例子的时候，还真举不出来…<br><br>难道是一颗闷骚的心脏，却配了一副老实的身体…<br></p><br><p><br>    <br><br></p><br><p><br>    ——但是真的很浪，竟然没出什么大事……<br></p><br><p><br>    ——从概率论上说，我这么干终有一天会倒霉的……<br></p><br><p><br>    <br><br></p><br><p><br>    不过我至今没倒过霉…求虐…没倒过霉的人生是不完整的<br></p><br><p><br>    <br><br></p><br><p><br>    浪的行为：主要体现在代码和技术上<br></p><br><p><br>    1、我喜欢看别人的代码，沿着他的思路走，我就能看到当时候他脑袋里进了什么水，或者中了什么毒<br></p><br><p><br>    2、技术上我喜欢走一些比较浪的路线，因为正常做没什么意思，如果时间充足的情况下，我还是喜欢走一些比较浪的路线<br></p><br><p><br>    3、我喜欢伊布拉希莫维奇远超喜欢C罗和梅西——》这足以说明一切<br></p><br><p><br>    <br><br></p><br><p><br>    <br><br></p><br><p><br>    <br><br></p><br><p><br>    三、<span>嘴炮型诗人</span><br></p><br><p><br>    朕是嘴炮型诗人………<br></p><br><p><br>    这个毫无疑问，举例说明，我刚换的QQ签名：<br></p><br><h4><br>    &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span style="color:#E53333;"><strong>朕就用灵长类动物看着爬虫一样的眼神看着你们，充满了鄙夷、不齿、怜悯</strong></span>。计数器20<br></h4><br><p><br>    此事是因为一群人在微信群里推脱着责任，各种使着无用的绊，各种可笑的推脱着责任…………..<br></p><br><p><br>    在我看来，就是可笑……<br></p><br><p><br>    <br><br></p><br><p><br>    <br><br></p></div><p class="readmore"><a href="/2016/06/06/2016-06-06-whoami/">Mehr lesen</a></p></div><div class="post"><h2 class="post-title"><a href="/2016/05/07/2016-05-07-neuralnetwork/">[KANMARS原创]-基于隐层的前馈式神经网络之brain.js</a></h2><div class="post-meta">2016-05-07</div><a data-thread-key="2016/05/07/2016-05-07-neuralnetwork/" href="/2016/05/07/2016-05-07-neuralnetwork/#comments" class="ds-thread-count"></a><div class="post-content"><p>睡不着，翻译点资料……</p>
<p>好久之前帮同学写过一篇论文，大致是基于ELM（Extreme Learning Machine极限学习机）的前馈式神经网络.</p>
<p>因此对神经网络的一些概念还算了解。</p>
<p>凑巧最近对人工智能感兴趣，所以百度了一下成型的产品，比如brain.js，然后翻译以及阅读一下。</p></div><p class="readmore"><a href="/2016/05/07/2016-05-07-neuralnetwork/">Mehr lesen</a></p></div><div class="post"><h2 class="post-title"><a href="/2016/04/23/2016-04-23-mysongs/">[KANMARS原创]-非夜深不可听歌</a></h2><div class="post-meta">2016-04-23</div><a data-thread-key="2016/04/23/2016-04-23-mysongs/" href="/2016/04/23/2016-04-23-mysongs/#comments" class="ds-thread-count"></a><div class="post-content"><h2 id="好久没有听歌，忽然瞬间开始怀念暑假时的雨夜，在小阁楼上打开窗户，听着歌听着雨。"><a href="#好久没有听歌，忽然瞬间开始怀念暑假时的雨夜，在小阁楼上打开窗户，听着歌听着雨。" class="headerlink" title="好久没有听歌，忽然瞬间开始怀念暑假时的雨夜，在小阁楼上打开窗户，听着歌听着雨。"></a>好久没有听歌，忽然瞬间开始怀念暑假时的雨夜，在小阁楼上打开窗户，听着歌听着雨。</h2><p>刚才在听歌，因为忽然想起了田馥甄和苏运莹唱的</p></div><p class="readmore"><a href="/2016/04/23/2016-04-23-mysongs/">Mehr lesen</a></p></div><div class="post"><h2 class="post-title"><a href="/2016/04/09/2016-04-09-psBayes_001/">[KANMARS原创] -  贝叶斯公式</a></h2><div class="post-meta">2016-04-09</div><a data-thread-key="2016/04/09/2016-04-09-psBayes_001/" href="/2016/04/09/2016-04-09-psBayes_001/#comments" class="ds-thread-count"></a><div class="post-content"><p>贝叶斯公式是一个很朴素的定理，可以参考百度百科：<br><a href="http://baike.baidu.com/link?url=h2V8ZHTHcxk05h7zqO_LIqN05F18CunIaMli3Zlabo6SV10I5E8qp4QODWkutCXEpYzUlM4KsCijmV5pIkmTHq" title="百度百科：贝叶斯公式" target="_blank" rel="external">http://baike.baidu.com/link?url=h2V8ZHTHcxk05h7zqO_LIqN05F18CunIaMli3Zlabo6SV10I5E8qp4QODWkutCXEpYzUlM4KsCijmV5pIkmTHq</a></p></div><p class="readmore"><a href="/2016/04/09/2016-04-09-psBayes_001/">Mehr lesen</a></p></div><div class="post"><h2 class="post-title"><a href="/2016/03/14/2016-03-14-KB_GOMERPC_1/">[KANMARS原创] - KB，国美金融未来的RPC框架（一）</a></h2><div class="post-meta">2016-03-14</div><a data-thread-key="2016/03/14/2016-03-14-KB_GOMERPC_1/" href="/2016/03/14/2016-03-14-KB_GOMERPC_1/#comments" class="ds-thread-count"></a><div class="post-content"><p><br>    KB，国美金融未来的RPC框架<span>（一）</span>，具有更高的性能，更细的力度，更灵活的配置，更加适应未来。<br></p><br><p><br>    <br><br></p><br><p><br>    之前公司为了更加适应互联网架构，一直在推行dubbo服务化，在实际中发现了一些无法解决的坑，例如：循环依赖问题、开发中经常会有接口文件冲突、接口不明确，web无法调用等缺点。<br></p><br><p><br>    <br><br></p><br><p><br>    尽管公司的总体架构方向是推行dubbo化，但是我们想做的更好！<br></p><br><p><br>    在2016年，我们基本可以看到：未来是一个虚拟化的世界，各种虚拟、容器技术例如docker等将会支撑起大量的微服务,整个互联网将活在微服务上。这是潮流所趋，没有一个“集中化”的方案能解决所有问题，没有一个“高可用”的技术可以保证100%的可用。我们能做出的选择，只有不停的将系统拆分，拆分为互不关联、互不影响的独立个体，让大量的独立个体来保障整体的可用与健康发展。<br></p><br><p><br>    <br><br></p><br><p><br>    如果把软件也看作生命，过去的“集中式”是一种恐龙式的生命，不停的走向更大更强。—但是恐龙灭绝了，正如当今时代的集中式系统基本灭绝（除了几家银行被IOE等巨头忽悠出来的大集中系统）。<br></p><br><p><br>    <br><br></p><br><p><br>    因此我们如果想走得远，就需要向未来的方向靠拢，如果你不想走回头路，那么你需要看的更远！<br></p><br><p><br>    因此，为了适应将来的docker和微服务，并且改进现有的dubbo的缺点，顺手解决几个来自无线部门的BUG，KB框架诞生了。<br></p><br><p><br>    —————————————————————————————————————–<br></p><br><p><br>    KB框架是一款类似dubbo的rpc框架，用于系统间通信，例如你可以把web页面放在一个服务上，然后把logic服务放在另一个服务上。之所以我们会把web,logic,service,dao等拆分到不同的服务器上，为的其实是“复用”，很多架构师和我说了一堆的无用的理由，例如代码可以随时更新，随时发布等，但我认为，将一个流程的不同“层面”拆分到不同的服务上，可以将整个复杂的流程在“<span style="color:#E53333;background-color:#000000;">逻辑上切割为很多可前后连接的步骤</span>这样就可以在新扩展出业务的时候，选择最佳的步骤进行介入。例如，新开发了一条业务线如下：<br></p><br><p><br>    A &nbsp;-》 &nbsp;B &nbsp; -》 &nbsp;C &nbsp; -》 &nbsp; D &nbsp; -》 &nbsp; E &nbsp;-》 &nbsp;F &nbsp;-》 &nbsp;G &nbsp;<br></p><br><p><br>    如果新来了一个业务改造，就可以有7个接入点选择—》比起重新开发一套，这是非常划算的结构。<br></p><br><p><br>    因此就可以改造成为<br></p><br><p><br>    <span style="line-height:7.2px;">A &nbsp;-》 &nbsp;B &nbsp; -》 &nbsp;C &nbsp; -》 &nbsp; D &nbsp; -》 &nbsp; E &nbsp;-》 &nbsp;F &nbsp;-》 &nbsp;G</span><br></p><br><p><br>    &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ┕ &nbsp;-》 &nbsp; E’ -》 &nbsp;F’ -》 &nbsp;G’&nbsp;&nbsp;<br></p><br><p><br>    &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span style="line-height:7.2px;">┕ &nbsp;-》 F’<span style="line-height:7.2px;">‘</span>-》 &nbsp;G’<span style="line-height:7.2px;">‘</span></span><span style="line-height:7.2px;"></span><br></p><br><p><br>    <span style="line-height:7.2px;"><span style="line-height:7.2px;"><br><br></span></span><br></p><br><p><br>    这种结构会使得业务减少很多的改造，减少很多工作量<br></p><br><p><br>    <br><br></p><br><p><br>    但缺陷在于：<br></p><br><p><br>    1、层之间的语言不通时，会导致转换复杂。例如dubbo服务无法被外网访问<br></p><br><p><br>    2、层之间的通讯性能消耗比较大，会成为一个新的瓶颈<br></p><br><p><br>    3、最终会导致系统结构复杂。<br></p><br><p><br>    <br><br></p><br><p><br>    针对第一个问题，没有一个人尝试解决<br></p><br><p><br>    针对第二个问题，很多程序员非常粗暴的对各种RPC框架进行“压力测试”，测出了一堆不靠谱的数据，然后说A框架性能比B框架好。颇有原始人看两个巫师比赛占卜之势。<br></p><br><p><br>    针对第三个问题，很多公司开发了自己的“监控分析系统”，希望对服务点之间的关系进行“绘图”，最终绘出一个层次清晰的表单，进而描述系统的压力负载，系统消耗数据等等内容。<br></p><br><p><br>    —————————————————————-<br></p><br><p><br>    为解决问题1，KB系统采用了标准HTTP+JSON报文，并且支持采用配置的方式支持原生JSON或者Base64编码或者AES加密。<span style="line-height:7.2px;">其优势在于：“真正的互联网”，</span>支持服务器端对端调用，也支持浏览器对服务端直接调用，也支持APP、IOS客户端对服务端直接调用。<br></p><br><p><br>    我认为互联不是指服务器与服务器之间的互联，也包含了浏览器、客户端与应用之间的互联。目前的RPC框架基本上全部都是服务器端和服务器端的交互，而没有考虑到随着时代的发展，移动设备的计算能力甚至已经近似等于服务器端，如果仅仅把移动设备看作一个“浏览器”这是多么浪费的行为，未来的时代将会是移动设备可以直接与服务器端交互的时代，因此，KB系统最重要的特征就是：通用的标准报文，支持任意设备访问，支持有或没有注册中心的访问。<br></p><br><p><br>    <br><br></p><br><p><br>    关于问题2，性能的问题，很多程序员非常粗暴，简单的对RPC框架调用十万次，算出平均时间就下结论说A框架性能比B框架的性能好。<br></p><br><p><br>    用狗哥的话讲：这些我家的狗都会。<br></p><br><p><br>    性能是个复杂的问题：性能是一个“用已有资源得到最优结果”的过程。已有资源包括CPU、带宽、内存、网络质量……….<br></p><br><p><br>    所谓性能，是一种看锅下菜的工作。例如：<br><br>1、在CPU充足，带宽不足的地方，对报文进行压缩，那么系统性能就会表现优秀<br></p><br><p><br>    2、在内存不足，CPU不足，带宽充足的地方，对报文进行简单处理直接发送，那么系统性能就会表现优秀<br></p><br><p><br>    3、在网络质量差，但是CPU、带宽、内存比较充足的地方，就比较适合用一些大比例压缩和复杂分段传输的方法以达到优秀性能<br></p><br><p><br>    。。。。。。<br></p><br><p><br>    那些调用十万次算平均时间的，只能统计出一个结果：“统计出这个系统中有多少代码”。毕竟计算机是个很实在的东西，代码多了自然慢。<br></p><br><p><br>    以下是KB与DUBBO的性能对比：<br></p><br><p><br>    通信层： KB ： jetty &nbsp;对&nbsp; DUBBO : netty<br></p><br><p><br>    协议转换层： KB JSONlib &nbsp; &nbsp; DUBBO:ObjectOutputStream<br></p><br><p><br>    网络层:KB &nbsp;HTTP协议 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;DUBBO:dubbo协议<br></p><br><p><br>    ………..<br></p><br><p><br>    从字面看，jetty是应用层框架，而netty是网络层框架，JSONlib是JSON转化包,而ObjectOutputStream<br></p><br><p><br>    你可以猜测到：KB框架对CPU和内存的需求比DUBBO要高<br></p><br><p><br>    但是你可以看到:由于使用了JSON协议，在复杂对象的格式转换和网络消耗上，KB框架是比DUBBO有一定优势的<br></p><br><p><br>    参见<a href="https://github.com/eishay/jvm-serializers/wiki" target="_blank" rel="external">https://github.com/eishay/jvm-serializers/wiki</a> &nbsp;中的json和java原生序列化性能对比<br></p><br><p><br>    据测试：KB框架的性能和DUBBO的性能基本没有差距。<br></p><br><p><br>    <br><br></p><br><p><br>    关于问题3：为了使系统之间调用层次清晰可见，很多公司开发了服务监控框架。但事实上，服务和服务之间的关系复杂，最终将是N纬立体结构，无法用图来描述。做的好点的公司，一般是根据交易唯一ID来进行跟踪，跟踪某条交易在不同服务之间的调用关系，最终可以得到性能、成功率，稳定性等数据。<br></p><br><p><br>    这儿有两条必走道路：<br></p><br><p><br>    1、对系统整体进行规划，规划系统的架构统一，避免癌症一般的肆意发展<br></p><br><p><br>    2、要求服务层级之间“完全的向下兼容”，尽量杜绝既有服务的修改（几乎不可能，但不代表不需要做）<br></p><br><p><br>    ————————————————————————————————————–<br></p><br><p><br>    接下来是正文：KB框架<br></p><br><p><br>    内部包含8个子包<br></p><br><p><br>    kb<br></p><br><p><br>    &nbsp; kb-client &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;kb客户端<br></p><br><p><br>    &nbsp; kb-config &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; kb配置<br></p><br><p><br>    &nbsp; kb-core &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;kb依赖核心<br></p><br><p><br>    &nbsp; kb-demo &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;kb演示demo<br></p><br><p><br>    &nbsp; kb-properties &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;kb配置管理<br></p><br><p><br>    &nbsp; kb-protocol &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; kb协议管理<br></p><br><p><br>    &nbsp; kb-server &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; kb服务器端<br></p><br><p><br>    &nbsp; kb-util &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; kb基础工具<br></p><br><p><br>    <br><br></p><br><p><br>    入口可以从kb-demo开始看：<br></p><br><p><br>    ——————————————————————————————————————————————————————————–<br></p><br><p><br>    <strong><span style="font-size:24px;">1、发布服务端，仅需3步</span></strong><br></p><br><p><br>    <span style="font-size:16px;"><strong>1.1、配置spring文件</strong></span><br></p><br><p><br>    <span style="background-color:#FFE500;">spring-server.xml</span><br></p><br><p><br>    &lt;?xml version=”1.0” encoding=”UTF-8”?&gt;<br><br>&lt;beans xmlns=”<a href="http://www.springframework.org/schema/beans" target="_blank" rel="external">http://www.springframework.org/schema/beans</a>“<br><br>&nbsp; &nbsp; &nbsp; &nbsp;xmlns:xsi=”<a href="http://www.w3.org/2001/XMLSchema-instance" target="_blank" rel="external">http://www.w3.org/2001/XMLSchema-instance</a>“<br><br>&nbsp; &nbsp; &nbsp; &nbsp;xmlns:context=”<a href="http://www.springframework.org/schema/context" target="_blank" rel="external">http://www.springframework.org/schema/context</a>“<br><br>&nbsp; &nbsp; &nbsp; &nbsp;<span style="color:#E53333;background-color:#000000;">xmlns:kb= “<a href="http://www.kanmars.cn/kb" target="_blank" rel="external">http://www.kanmars.cn/kb</a>“</span><br><br>&nbsp; &nbsp; &nbsp; &nbsp;xsi:schemaLocation=”<br><br>&nbsp; &nbsp; &nbsp; &nbsp;<a href="http://www.springframework.org/schema/beans" target="_blank" rel="external">http://www.springframework.org/schema/beans</a> <a href="http://www.springframework.org/schema/beans/spring-beans.xsd" target="_blank" rel="external">http://www.springframework.org/schema/beans/spring-beans.xsd</a><br><br>&nbsp; &nbsp; &nbsp; &nbsp;<a href="http://www.springframework.org/schema/context" target="_blank" rel="external">http://www.springframework.org/schema/context</a> <a href="http://www.springframework.org/schema/context/spring-context.xsd" target="_blank" rel="external">http://www.springframework.org/schema/context/spring-context.xsd</a><br><br>&nbsp; &nbsp; &nbsp; &nbsp;<span style="color:#E53333;background-color:#000000;"><a href="http://www.kanmars.cn/kb" target="_blank" rel="external">http://www.kanmars.cn/kb</a> <a href="http://www.kanmars.cn/kb.xsd" target="_blank" rel="external">http://www.kanmars.cn/kb.xsd</a></span><br><br>&nbsp; &nbsp; &nbsp; &nbsp;”&gt;<br><br>&nbsp; &nbsp; &nbsp; &nbsp;&lt;context:annotation-config&gt;&lt;/context:annotation-config&gt;<br><br>&nbsp; &nbsp; &nbsp; &nbsp;&lt;context:component-scan base-package=”cn.kanmars.service”/&gt;<br><br>&nbsp; &nbsp; &nbsp; &nbsp;<span style="color:#E53333;background-color:#000000;">&lt;kb:server id=”kbserver1” bindip=”0.0.0.0” bindport=”9999” minthreadpool=”5” maxthreadpool=”150” register=”localhost:2181” idleTimeout=”30000”/&gt;</span><br><br><span style="color:#E53333;background-color:#000000;">&nbsp; &nbsp; &nbsp; &nbsp;&lt;kb:server id=”kbserver2” bindip=”0.0.0.0” bindport=”9998” minthreadpool=”5” maxthreadpool=”150” register=”localhost:2181” idleTimeout=”30000”/&gt;</span><br><br>&nbsp; &nbsp; &nbsp; &nbsp;<span style="color:#E53333;background-color:#000000;">&lt;kb:properties id=”getAesKeyFromSpring” value=”123456”/&gt;</span><br><br>&lt;/beans&gt;<br></p><br><p><br>    <br><br></p><br><p><br>    <strong><span style="font-size:16px;">1.2、将一个方法注册到server上</span></strong><span style="font-size:16px;"></span><br></p><br><p><br>    <span style="background-color:#FFE500;">CCC.java</span><br></p><br><p><br>    package cn.kanmars.service;<br><br><br><br>/<strong><br><br>&nbsp;<em> Created by baolong on 2016/3/7.<br><br>&nbsp;</em>/<br><br>@Service<br><br>public class CCC {<br><br><br><br>&nbsp; &nbsp; <span style="color:#E53333;background-color:#000000;">@KBRouteServer(group = “KB_DEFAULT”,globalname = “cn.kanmars.service.CCC.exec0”,servername=”kbserver1”,key = “NONE”)</span><br><br>&nbsp; &nbsp; public Map exec0(Map reqInfo){<br><br>&nbsp; &nbsp; &nbsp; &nbsp; String s = “cn.kanmars.service.CCC.exec0”;<br><br>&nbsp; &nbsp; &nbsp; &nbsp; LoggerUtil.print(LoggerUtil.INFO, “调用了服务[“ + s + “]”, null);<br><br>&nbsp; &nbsp; &nbsp; &nbsp; return null;<br><br>&nbsp; &nbsp; }<br><br>&nbsp; &nbsp; <span style="color:#E53333;background-color:#000000;">@KBRouteServer(group = “KB_DEFAULT”,globalname = “cn.kanmars.service.CCC.exec1”,servername=”kbserver1”,key = “getAesKeyFromSpring”)</span><br><br>&nbsp; &nbsp; public Map exec1(Map reqInfo){<br><br>&nbsp; &nbsp; &nbsp; &nbsp; String s = “cn.kanmars.service.CCC.exec1”;<br><br>&nbsp; &nbsp; &nbsp; &nbsp; LoggerUtil.print(LoggerUtil.INFO, “调用了服务[“ + s + “]”, null);<br><br>&nbsp; &nbsp; &nbsp; &nbsp; return null;<br><br>&nbsp; &nbsp; }<br><br>}<br></strong></p><br><p><br>    <br><br></p><br><p><br>    <br><br></p><br><p><br>    <strong><span style="font-size:16px;">1.3、启动spring</span></strong><br></p><br><p><br>    ServerDemo.java<br></p><br><p><br>    public class ServerDemo {<br><br>&nbsp; &nbsp; public static void main(String[] args) {<br><br>&nbsp; &nbsp; &nbsp; &nbsp; ClassPathXmlApplicationContext c = new ClassPathXmlApplicationContext(“classpath:spring-server.xml”);<br><br>&nbsp; &nbsp; &nbsp; &nbsp; Object cc = c.getBean(“kbserver1”);<br><br>&nbsp; &nbsp; }<br><br>}<br><br><span style="color:#E53333;"></span><br></p><br><p><br>    <span style="line-height:14.4px;">——————————————————————————————————————————————————————————–</span><br></p><br><p><br>    <strong><span style="font-size:24px;">2、发布客户端，仅需3步</span></strong><br></p><br><p><br>    <br><br></p><br><p><br>    <span style="font-size:16px;"><strong>2.1、配置spring文件</strong></span><br></p><br><p><br>    <span style="background-color:#FFE500;">spring-client.xml</span><br></p><br>&lt;?xml version=”1.0” encoding=”UTF-8”?&gt;<br><br>&lt;beans xmlns=”<a href="http://www.springframework.org/schema/beans" target="_blank" rel="external">http://www.springframework.org/schema/beans</a>“<br><br>&nbsp; &nbsp; &nbsp; &nbsp;xmlns:xsi=”<a href="http://www.w3.org/2001/XMLSchema-instance" target="_blank" rel="external">http://www.w3.org/2001/XMLSchema-instance</a>“<br><br>&nbsp; &nbsp; &nbsp; &nbsp;xmlns:context=”<a href="http://www.springframework.org/schema/context" target="_blank" rel="external">http://www.springframework.org/schema/context</a>“<br><br>&nbsp; &nbsp; &nbsp; &nbsp;<span style="color:#E53333;background-color:#000000;">xmlns:kb= “<a href="http://www.kanmars.cn/kb" target="_blank" rel="external">http://www.kanmars.cn/kb</a>“</span><br><br>&nbsp; &nbsp; &nbsp; &nbsp;xsi:schemaLocation=”<br><br>&nbsp; &nbsp; &nbsp; &nbsp;<a href="http://www.springframework.org/schema/beans" target="_blank" rel="external">http://www.springframework.org/schema/beans</a> <a href="http://www.springframework.org/schema/beans/spring-beans.xsd" target="_blank" rel="external">http://www.springframework.org/schema/beans/spring-beans.xsd</a><br><br>&nbsp; &nbsp; &nbsp; &nbsp;<a href="http://www.springframework.org/schema/context" target="_blank" rel="external">http://www.springframework.org/schema/context</a> <a href="http://www.springframework.org/schema/context/spring-context.xsd" target="_blank" rel="external">http://www.springframework.org/schema/context/spring-context.xsd</a><br><br>&nbsp; &nbsp; &nbsp; &nbsp;<span style="color:#E53333;background-color:#000000;"><a href="http://www.kanmars.cn/kb" target="_blank" rel="external">http://www.kanmars.cn/kb</a> <a href="http://www.kanmars.cn/kb.xsd" target="_blank" rel="external">http://www.kanmars.cn/kb.xsd</a></span><br><br>&nbsp; &nbsp; &nbsp; &nbsp;”&gt;<br><br>&nbsp; &nbsp; &lt;context:annotation-config&gt;&lt;/context:annotation-config&gt;<br><br>&nbsp; &nbsp; &lt;context:component-scan base-package=”cn.kanmars.client”/&gt;<br><br>&nbsp; &nbsp; <span style="color:#E53333;background-color:#000000;">&lt;kb:client id=”clientd” basepackage=”cn.kanmars.client”/&gt;</span><br><br>&nbsp; &nbsp; <span style="color:#E53333;background-color:#000000;">&lt;kb:properties id=”getAesKeyFromSpring” value=”123456”/&gt;</span><br><br>&lt;/beans&gt;<br><p><br>    <br><br></p><br><p><br>    <br><br></p><br><p><br>    <br><br><strong><span style="font-size:16px;"></span></strong><strong><span style="font-size:16px;">2.2、配置访问代理</span></strong><strong><span style="font-size:16px;"></span></strong><br></p><br><p><br>    <br><br></p><br><p><br>    <span style="background-color:#FFE500;">DDD.java</span><br></p><br><p><br>    /<br><br>&nbsp;<em> Created by baolong on 2016/3/8.<br><br>&nbsp;</em>/<br><br>@Service<br><br>public class DDD {<br><br>&nbsp; &nbsp; <span style="background-color:#E53333;">@KBRouteClient(register = “localhost:2181”,url = “”,name=”DDD_KB_0308”,group = “KB_DEFAULT”,globalname = “cn.kanmars.service.CCC.exec0”,key=”getAesKeyFromSpring”)</span><br><br>&nbsp; &nbsp; public KBRouteClientProxy kbRouteClientProxy;<br><br><br><br>&nbsp; &nbsp; public void exec() {<br><br>&nbsp; &nbsp; &nbsp; &nbsp; long pre =System.currentTimeMillis();<br><br>&nbsp; &nbsp; &nbsp; &nbsp; long now =System.currentTimeMillis();<br><br>&nbsp; &nbsp; &nbsp; &nbsp; LoggerUtil.print(LoggerUtil.INFO, “初始时间[“+(now-pre)+”]”, null);<br><br>&nbsp; &nbsp; &nbsp; &nbsp; HashMap param = new HashMap();<br><br>&nbsp; &nbsp; &nbsp; &nbsp; Map result = null;<br><br>&nbsp; &nbsp; &nbsp; &nbsp; for(int i=0;i&lt;1;i++){<br><br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; try{<br><br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; //Thread.sleep(2000);<br><br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; result = <span style="color:#E53333;background-color:#000000;">kbRouteClientProxy.exec(param);</span><br><br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; //———————————–<br><br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; now =System.currentTimeMillis();<br><br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; LoggerUtil.print(LoggerUtil.INFO, “第[“+i+”]次调用耗时[“ + (now - pre) + “]”, null);<br><br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; pre =System.currentTimeMillis();<br><br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }catch (Exception e){<br><br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; e.printStackTrace();<br><br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br><br>&nbsp; &nbsp; &nbsp; &nbsp; }<br><br>&nbsp; &nbsp; }<br></p><br><p><br>    <br><br></p><br><strong><span style="font-size:16px;"></span></strong><strong><span style="font-size:16px;">2.3、启动spring</span></strong><br><p><br>    <br><br></p><br><p><br>    ClientDemo.java<br></p><br><p><br>    /<em>*<br><br>&nbsp;</em> Created by baolong on 2016/3/8.<br><br>&nbsp;*/<br><br>public class ClientDemo {<br><br><br><br><br><br>&nbsp; &nbsp; public static void main(String[] args){<br><br>&nbsp; &nbsp; &nbsp; &nbsp; ClassPathXmlApplicationContext c = new ClassPathXmlApplicationContext(“classpath:spring-client.xml”);<br><br>&nbsp; &nbsp; &nbsp; &nbsp; DDD ddd = (DDD)c.getBean(DDD.class);<br><br>&nbsp; &nbsp; &nbsp; &nbsp; ddd.exec();<br><br>&nbsp; &nbsp; }<br><br><br><br>}<br></p><br><p><br>    <br><br></p><br><p><br>    <br><br></p><br><p><br>    <span style="line-height:14.4px;">——————————————————————————————————————————————————————————–</span><br></p><br><p><br>    从以上内容可以看到KB框架的调用方式很简单，并且原理很易懂：<br></p><br><p><br>    1、server将某个方法暴露到register代表的zookeeper上，并且对外提供服务<br></p><br><p><br>    2、client在zookeeper上寻找对应的服务，并且生成代理后调用<br></p><br><p><br>    <br><br></p><br><p><br>    与DUBBO的区别是:Dubbo是将一个“接口”暴露在外，而KB系统是将一个“方法”暴露在外，提供给客户端的是一个“属性”，因此KB具有更细的粒度。<br></p><br><p><br>    之所以这么设计，是因为我们在实际中发现：DUBBO中某个接口里的方法很多，但是真正用的只有一两个，其他的方法都是没用的废方法，并且，如果谁新增了一个方法，会导致所有的开发人员报错，严重阻塞了系统进度。<br></p><br><p><br>    我们在使用DUBBO时，不得不采取了各种奇葩的方法来避免这种问题。<br></p><br><p><br>    追根究底是这样的原因：<br><br>1，作为调用者，只对被调用者感兴趣，其他无关的内容尽管在一个类，但是没有存在的必要<br></p><br><p><br>    ２，由于强制把不相关的内容聚合在一起，导致这些内容可能出现冲突<br></p><br><p><br>    ３，之所以dubbo将方法和类绑定到一起，是因为作者局限于类和方法的思维，不考虑将方法本身暴露出去的好处。<br></p><br><p><br>    因此在KB系统中，我们直接采用方法与属性的细力度对方法进行了封装，仅需globalname和group就可以唯一确定一个服务并进行调用。<br></p><br><p><br>    完美的解决了类的依赖，以及如果系统双方要互相调用，那么必须把class类进行互通的问题（也许一些人会批评我“你完全不懂什么是面对对象”，我会很坦荡的告诉他们：“请你回去看三年面对函数编程再来”）<br></p><br><p><br>    <span style="line-height:14.4px;">——————————————————————————————————————————————————————————–</span><br></p><br><p><br>    同时，如果你在浏览器中访问如下地址<br></p><br><p><br>    <a href="http://localhost:9999/cn.kanmars.service.CCC.exec0" target="_blank" rel="external">http://localhost:9999/cn.kanmars.service.CCC.exec0</a><br></p><br><p><br>    你会看到如下结果：<br></p><br><p><br>    {“RSPCODE”:”0002”,”RSPMSG”:{“RSPCODE”:”0002”,”RSPDESC”:”报文格式不正确”},”RSPDESC”:”报文格式不正确”}<br></p><br><p><br>    这是KB比DUBBO最大的优势：可以在内网由java客户端调用，也可以将服务暴露到外网，由javascript,app,ios等直接调用，在新的互联网时代，一定要了解“互联”的概念，不要局限于局域网。<br></p><br><p><br>    <span style="line-height:14.4px;">——————————————————————————————————————————————————————————–</span><br></p><br><p><br>    有人会质疑：安全么？<br></p><br><p><br>    请访问另一个地址<br></p><br><p><br>    <span><a href="http://localhost:9999/cn.kanmars.service.CCC.exec1" target="_blank" rel="external">http://localhost:9999/cn.kanmars.service.CCC.exec1</a></span><br></p><br><p><br>    你会看到如下结果：<br></p><br><p><br>    {“RSPCODE”:”0002”,”RSPMSG”:”yc7h9oGF6iOVKX6QrhHpx3jTpxTbiI6wo6Y1w3nE1xqp7AjahtxrOVLg0WERoZPuljktOifC09jRvWul593iXg==”,”RSPDESC”:”报文格式不正确”}<br></p><br><p><br>    可以看到RSPMSG为加密后的结果，从配置可以看出来，此配置已经将加密内容配置上去，极大的保障了安全性<br></p><br><p><br>    @KBRouteServer(group = “KB_DEFAULT”,globalname = “cn.kanmars.service.CCC.exec1”,servername=”kbserver1”,<span style="color:#E53333;background-color:#000000;">key = “getAesKeyFromSpring”</span>)<br></p><br><p><br>    同时，密钥可以通过spring的beanFactoryPostProcessor机制储存在各种机制中，如数据库、diamond、配置、环境变量等处<br></p><br><p><br>    &lt;kb:properties id=”getAesKeyFromSpring” value=”123456”/&gt;<br></p><br><p><br>    KB系统支持三种通讯加密方式：<br></p><br><p><br>    key=”NONE” &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;不加密<br></p><br><p><br>    key=”BASE64” &nbsp; &nbsp; &nbsp; &nbsp;采用BASE64编码<br></p><br><p><br>    key=”其他” &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;采用aes加密<br></p><br><p><br>    通过如上加密方式，在通讯报文中，还会有sign签名信息对报文整体进行校验，最终保障通讯安全。<br></p><br><p><br>    也就是说，如果是内网，就可以采用NONE<br></p><br><p><br>    如果是安全的外网，可以采用NONE<br></p><br><p><br>    如果是需要混淆的外网，可以使用混淆后的BASE64<br></p><br><p><br>    如果是需要严格加密，可以实用AES加密<br></p><br><p><br>    整个过程配置简单，仅需客户端和服务器端配置的密钥字符串相同即可<br></p><br><p><br>    服务器端 &nbsp;： &nbsp; @KBRouteServer(group = “KB_DEFAULT”,globalname = “cn.kanmars.service.CCC.exec1”,servername=”kbserver1”,<span style="color:#E53333;background-color:#000000;">key = “getAesKeyFromSpring”</span>)<br></p><br><p><br>    客户端 &nbsp; &nbsp; ： &nbsp;&nbsp;@KBRouteClient(register = “localhost:2181”,url = “”,name=”DDD_KB_0308”,group = “KB_DEFAULT”,globalname = “cn.kanmars.service.CCC.exec0”,<span style="color:#E53333;background-color:#000000;">key=”getAesKeyFromSpring”</span>)<br></p><br><p><br>    <span style="line-height:1.5;">&nbsp;<span style="line-height:14.4px;">——————————————————————————————————————————————————————————–</span></span><br></p><br><p><br>    <span style="line-height:1.5;"><br><br></span><br></p><br><p><br>    <span style="line-height:1.5;">关于系统架构</span><br></p><br><p><br>    <span style="line-height:1.5;">。。。。。。。</span><br></p><br><p><br>    <span style="line-height:1.5;">12点了，改天再写</span><br></p><br><p><br>    <br><br></p><br><p><br>    <br><br></p></div><p class="readmore"><a href="/2016/03/14/2016-03-14-KB_GOMERPC_1/">Mehr lesen</a></p></div><div class="post"><h2 class="post-title"><a href="/2016/03/03/2016-03-03-JVM_MAINTHREAD_START/">[KANMARS原创] - (六) 从JVM源码来理解JavaThread类启动过程与main方法调用</a></h2><div class="post-meta">2016-03-03</div><a data-thread-key="2016/03/03/2016-03-03-JVM_MAINTHREAD_START/" href="/2016/03/03/2016-03-03-JVM_MAINTHREAD_START/#comments" class="ds-thread-count"></a><div class="post-content"><p><br>    JavaThread类启动过程与main方法调用<br></p><br><p><br>    &nbsp; &nbsp; JavaThread对应于每一个java层的Thread，例如调用public static void main(String[] args)时，自动生成一个java线程，而且每new Thread(){()-&gt;{}}.start();的时候也会生成一个java线程。<br></p><br><p><br>    &nbsp; &nbsp; 根据一些粗显的知识，java线程中包含虚拟机栈、程序计数器。<br></p><br><p><br>    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;虚拟机栈包含：栈帧，每一个方法调用都会生成一个栈帧<br></p><br><p><br>    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp; 栈帧包含：&nbsp; &nbsp; 局部变量表、操作数栈、动态链接、方法返回地址<br></p><br><p><br>    <br><br></p><br><p><br>    &nbsp; &nbsp; ———————————————————————————————————————————————–<br></p><br><p><br>    &nbsp; &nbsp; <span>或许大家作为JAVA程序员想象了一遍又一遍的JVM内部实现，但大部分是错误的想法，（<span>例如 ：</span>每一个虚拟机栈包含了局部变量表，但在OpenJDK 的JVM中，虚拟机栈和局部变量表是分离的实现） ,</span>今天我们就来看一下，在JVM中，这些东西是怎么实现的。<br></p><br><p><br>    <span>&nbsp; &nbsp; ———————————————————————————————————————————————–</span><br></p><br><p><br>    &nbsp; &nbsp; JavaThread是如何启动并运行的<br></p><br><p><br>    &nbsp; &nbsp; JavaThread的启动位于&nbsp;&nbsp;&nbsp;&nbsp;<br></p><br><p><br>    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp; java.c:main -&gt; java.c:javaMain -&gt; java.c:InitializeJVM-&gt;Thread.cpp:CreateJavaVM<br></p><br><p><br>    <br><br></p><br><p><br>    &nbsp; &nbsp; JavaThread内部的重要属性如下：<br></p><br><p><br>    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;JavaThread<em> &nbsp; &nbsp;_next; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp; 下一个JavaThread<br></em></p><br><p><br>    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;oop &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;_threadObj;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br></p><br><p><br>    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;JavaFrameAnchor _anchor;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp; JavaFrame的锚点<br></p><br><p><br>    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ThreadFunction _entry_point;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br></p><br><p><br>    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;JNIEnv &nbsp; &nbsp; &nbsp; &nbsp;_jni_environment;<br></p><br><p><br>    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;vframeArray &nbsp;_vframe_array_head;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span>vframe_array的头部</span><br></p><br><p><br>    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;vframeArray<em> &nbsp;_vframe_array_last;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span>vframe_array的尾部</span><br></em></p><br><p><br>    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;GrowableArray&lt;jvmtiDeferredLocalVariableSet&gt;<em> _deferred_locals_updates;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp; 本地变量表，即localVariable，从此可以看出，本地变量表并非在栈帧中，而是并列的结构<br></em></p><br><p><br>    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;methodOop &nbsp; &nbsp; _callee_target;<br></p><br><p><br>    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;oop &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; _vm_result;<br></p><br><p><br>    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;oop &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; _vm_result_2;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br></p><br><p><br>    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;MemRegion &nbsp; &nbsp; _deferred_card_mark;<br></p><br><p><br>    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ThreadSafepointState _safepoint_state;<br></p><br><p><br>    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;address &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; _saved_exception_pc;<br></p><br><p><br>    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;volatile oop &nbsp; &nbsp; _exception_oop;<br></p><br><p><br>    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;volatile address _exception_pc;<br></p><br><p><br>    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;volatile address _exception_handler_pc;<br></p><br><p><br>    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;volatile int &nbsp; &nbsp; _exception_stack_size;&nbsp;<br></p><br><p><br>    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;volatile int &nbsp; &nbsp; _is_method_handle_return;<br></p><br><p><br>    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br></p><br><p><br>    <span>&nbsp; &nbsp; ———————————————————————————————————————————————–</span><br></p><br><p><br>    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;JavaThread<em> main_thread = new JavaThread();<br></em></p><br><p><br>    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp; 调用父构造函数:&nbsp;&nbsp;&nbsp;&nbsp;Thread()<br></p><br><p><br>    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp; 代码:&nbsp;&nbsp;&nbsp;&nbsp;new HandleMark(this);<br></p><br><p><br>    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp; 代码:&nbsp;&nbsp;&nbsp;&nbsp;_unhandled_oops = new UnhandledOops(this);<br></p><br><p><br>    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp; 代码:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;initialize();<br></p><br><p><br>    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp; 代码:&nbsp;&nbsp;&nbsp;&nbsp;_anchor.clear();<br></p><br><p><br>    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp; 代码:&nbsp;&nbsp;&nbsp;&nbsp;pd_initialize();<br></p><br><p><br>    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp; 代码:&nbsp;&nbsp;&nbsp;&nbsp;_anchor.clear();<br></p><br><p><br>    <span>&nbsp; &nbsp;&nbsp;</span><span>&nbsp;&nbsp;&nbsp;&nbsp;</span><span>&nbsp;&nbsp;&nbsp;&nbsp;</span><span>&nbsp;&nbsp;&nbsp;&nbsp;</span><span>&nbsp; &nbsp; 代码:</span><span>&nbsp;&nbsp;&nbsp;&nbsp;</span><span>&nbsp;&nbsp;&nbsp;&nbsp;</span><span>&nbsp;&nbsp;&nbsp;&nbsp;</span><span>&nbsp;&nbsp;&nbsp;&nbsp;</span><span>&nbsp; &nbsp;_is_attaching = is_attaching;</span><br></p><br><p><br>    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;main_thread-&gt;set_thread_state(_thread_in_vm);<br></p><br><p><br>    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp; 线程状态共12种<br></p><br><p><br>    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;enum JavaThreadState {<br><br><span>&nbsp; &nbsp;&nbsp;</span><span>&nbsp;&nbsp;&nbsp;&nbsp;</span><span>&nbsp;&nbsp;&nbsp;&nbsp;</span><span>&nbsp;&nbsp;&nbsp;&nbsp;</span><span>&nbsp;&nbsp;&nbsp;&nbsp;</span><span>&nbsp; &nbsp;&nbsp;</span>&nbsp; _thread_uninitialized &nbsp; &nbsp; = &nbsp;0, // should never happen (missing initialization)<br><br><span>&nbsp; &nbsp;&nbsp;</span><span>&nbsp;&nbsp;&nbsp;&nbsp;</span><span>&nbsp;&nbsp;&nbsp;&nbsp;</span><span>&nbsp;&nbsp;&nbsp;&nbsp;</span><span>&nbsp;&nbsp;&nbsp;&nbsp;</span><span>&nbsp; &nbsp;&nbsp;</span>&nbsp; _thread_new &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; = &nbsp;2, // just starting up, i.e., in process of being initialized<br><br>&nbsp;<span>&nbsp; &nbsp;&nbsp;</span><span>&nbsp;&nbsp;&nbsp;&nbsp;</span><span>&nbsp;&nbsp;&nbsp;&nbsp;</span><span>&nbsp;&nbsp;&nbsp;&nbsp;</span><span>&nbsp;&nbsp;&nbsp;&nbsp;</span><span>&nbsp; &nbsp;&nbsp;</span> _thread_new_trans &nbsp; &nbsp; &nbsp; &nbsp; = &nbsp;3, // corresponding transition state (not used, included for completness)<br><br><span>&nbsp; &nbsp;&nbsp;</span><span>&nbsp;&nbsp;&nbsp;&nbsp;</span><span>&nbsp;&nbsp;&nbsp;&nbsp;</span><span>&nbsp;&nbsp;&nbsp;&nbsp;</span><span>&nbsp;&nbsp;&nbsp;&nbsp;</span><span>&nbsp; &nbsp;&nbsp;</span>&nbsp; _thread_in_native &nbsp; &nbsp; &nbsp; &nbsp; = &nbsp;4, // running in native code<br><br><span>&nbsp; &nbsp;&nbsp;</span><span>&nbsp;&nbsp;&nbsp;&nbsp;</span><span>&nbsp;&nbsp;&nbsp;&nbsp;</span><span>&nbsp;&nbsp;&nbsp;&nbsp;</span><span>&nbsp;&nbsp;&nbsp;&nbsp;</span><span>&nbsp; &nbsp;&nbsp;</span>&nbsp; _thread_in_native_trans &nbsp; = &nbsp;5, // corresponding transition state<br><br><span>&nbsp; &nbsp;&nbsp;</span><span>&nbsp;&nbsp;&nbsp;&nbsp;</span><span>&nbsp;&nbsp;&nbsp;&nbsp;</span><span>&nbsp;&nbsp;&nbsp;&nbsp;</span><span>&nbsp;&nbsp;&nbsp;&nbsp;</span><span>&nbsp; &nbsp; &nbsp;</span> _thread_in_vm &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; = &nbsp;6, // running in VM<br><br>&nbsp;<span>&nbsp; &nbsp;&nbsp;</span><span>&nbsp;&nbsp;&nbsp;&nbsp;</span><span>&nbsp;&nbsp;&nbsp;&nbsp;</span><span>&nbsp;&nbsp;&nbsp;&nbsp;</span><span>&nbsp;&nbsp;&nbsp;&nbsp;</span><span>&nbsp; &nbsp;&nbsp;</span> _thread_in_vm_trans &nbsp; &nbsp; &nbsp; = &nbsp;7, // corresponding transition state<br><br>&nbsp;<span>&nbsp; &nbsp;&nbsp;</span><span>&nbsp;&nbsp;&nbsp;&nbsp;</span><span>&nbsp;&nbsp;&nbsp;&nbsp;</span><span>&nbsp;&nbsp;&nbsp;&nbsp;</span><span>&nbsp;&nbsp;&nbsp;&nbsp;</span><span>&nbsp; &nbsp;&nbsp;</span> _thread_in_Java &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; = &nbsp;8, // running in Java or in stub code<br><br>&nbsp;<span>&nbsp; &nbsp;&nbsp;</span><span>&nbsp;&nbsp;&nbsp;&nbsp;</span><span>&nbsp;&nbsp;&nbsp;&nbsp;</span><span>&nbsp;&nbsp;&nbsp;&nbsp;</span><span>&nbsp;&nbsp;&nbsp;&nbsp;</span><span>&nbsp; &nbsp;&nbsp;</span> _thread_in_Java_trans &nbsp; &nbsp; = &nbsp;9, // corresponding transition state (not used, included for completness)<br><br>&nbsp;<span>&nbsp; &nbsp;&nbsp;</span><span>&nbsp;&nbsp;&nbsp;&nbsp;</span><span>&nbsp;&nbsp;&nbsp;&nbsp;</span><span>&nbsp;&nbsp;&nbsp;&nbsp;</span><span>&nbsp;&nbsp;&nbsp;&nbsp;</span><span>&nbsp; &nbsp;&nbsp;</span> _thread_blocked &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; = 10, // blocked in vm<br><br>&nbsp;<span>&nbsp; &nbsp;&nbsp;</span><span>&nbsp;&nbsp;&nbsp;&nbsp;</span><span>&nbsp;&nbsp;&nbsp;&nbsp;</span><span>&nbsp;&nbsp;&nbsp;&nbsp;</span><span>&nbsp;&nbsp;&nbsp;&nbsp;</span><span>&nbsp; &nbsp;&nbsp;</span> _thread_blocked_trans &nbsp; &nbsp; = 11, // corresponding transition state<br><br>&nbsp;<span>&nbsp; &nbsp;&nbsp;</span><span>&nbsp;&nbsp;&nbsp;&nbsp;</span><span>&nbsp;&nbsp;&nbsp;&nbsp;</span><span>&nbsp;&nbsp;&nbsp;&nbsp;</span><span>&nbsp;&nbsp;&nbsp;&nbsp;</span><span>&nbsp; &nbsp;&nbsp;</span> _thread_max_state &nbsp; &nbsp; &nbsp; &nbsp; = 12 &nbsp;// maximum thread state+1 - used for statistics allocation<br><br><span>&nbsp; &nbsp;&nbsp;</span><span>&nbsp;&nbsp;&nbsp;&nbsp;</span><span>&nbsp;&nbsp;&nbsp;&nbsp;</span><span>&nbsp;&nbsp;&nbsp;&nbsp;</span><span>&nbsp;&nbsp;&nbsp;&nbsp;</span><span>&nbsp; &nbsp;&nbsp;</span>};<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br></p><br><p><br>    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;main_thread-&gt;record_stack_base_and_size();<br></p><br><p><br>    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;main_thread-&gt;initialize_thread_local_storage();<br></p><br><p><br>    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp; 代码:&nbsp;&nbsp;&nbsp;&nbsp;ThreadLocalStorage::set_thread(this);<br></p><br><p><br>    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp; 代码:&nbsp;&nbsp;&nbsp;&nbsp;os::initialize_thread();&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp; 空函数<br></p><br><p><br>    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;main_thread-&gt;set_active_handles(JNIHandleBlock::allocate_block());<br></p><br><p><br>    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp; 代码:&nbsp;&nbsp;&nbsp;&nbsp;block = new JNIHandleBlock();<br></p><br><p><br>    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp; 代码:&nbsp;&nbsp;&nbsp;&nbsp;return block;<br></p><br><p><br>    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;main_thread-&gt;set_as_starting_thread()<br></p><br><p><br>    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp; 代码:&nbsp;&nbsp;&nbsp;&nbsp;os::create_main_thread((JavaThread)this)<br></p><br><p><br>    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp; 代码:&nbsp;&nbsp;&nbsp;&nbsp;create_attached_thread(thread)<br></p><br><p><br>    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp; 代码:&nbsp;&nbsp;&nbsp;&nbsp;OSThread<em> osthread = new OSThread(NULL, NULL);<br></em></p><br><p><br>    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp; 代码:&nbsp;&nbsp;&nbsp;&nbsp;osthread-&gt;set_thread_id(os::Linux::gettid());&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp; //设置线程ID为Linux的gettid，内部代码为系统调用syscall(SYS_gettid);<br></p><br><p><br>    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp; 代码:&nbsp;&nbsp;&nbsp;&nbsp;osthread-&gt;set_pthread_id(::pthread_self());&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp; &nbsp;//设置pthreadId为当前运行的线程id<br></p><br><p><br>    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp; 代码:&nbsp;&nbsp;&nbsp;&nbsp;os::Linux::init_thread_fpu_state();<br></p><br><p><br>    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span>代码:</span>&nbsp;&nbsp;&nbsp;&nbsp;osthread-&gt;set_state(RUNNABLE);<br></p><br><p><br>    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp; 代码:&nbsp;&nbsp;&nbsp;&nbsp;thread-&gt;set_osthread(osthread);<br></p><br><p><br>    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp; 代码:&nbsp;&nbsp;&nbsp;&nbsp;JavaThread jt = (JavaThread <em>)thread;<br></em></p><br><p><br>    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp; 代码:&nbsp;&nbsp;&nbsp;&nbsp;address addr = jt-&gt;stack_yellow_zone_base();<br></p><br><p><br>    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp; 代码:&nbsp;&nbsp;&nbsp;&nbsp;osthread-&gt;set_expanding_stack();<br></p><br><p><br>    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp; 代码:&nbsp;&nbsp;&nbsp;&nbsp;os::Linux::manually_expand_stack(jt, addr);<br></p><br><p><br>    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp; 代码:&nbsp;&nbsp;&nbsp;&nbsp;osthread-&gt;clear_expanding_stack();<br></p><br><p><br>    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp; 代码:&nbsp;&nbsp;&nbsp;&nbsp;os::Linux::hotspot_sigmask(thread);<br></p><br><p><br>    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp; 以上代码需要注意的是，在内部并没有调用任何os:create_thread()方法，只是将主线程设置为了osthread的threadId，因此此步骤并未生成新的thread，而是使用原thread继续运行<br></p><br><p><br>    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;main_thread-&gt;create_stack_guard_pages();&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp; 创建警戒页并把该警戒页通过::mmap函数映射到address low_addr = stack_base() - stack_size();处<br></p><br><p><br>    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;main_thread-&gt;cache_global_variables();&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp; 空函数<br></p><br><p><br>    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Threads::add(main_thread);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br></p><br><p><br>    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp; 代码:&nbsp;&nbsp;&nbsp;&nbsp;p-&gt;initialize_queues();<br></p><br><p><br>    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp; 代码:&nbsp;&nbsp;&nbsp;&nbsp;p-&gt;set_next(_thread_list);<br></p><br><p><br>    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp; 代码:&nbsp;&nbsp;&nbsp;&nbsp;_thread_list = p;<br></p><br><p><br>    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp; 代码:&nbsp;&nbsp;&nbsp;&nbsp;_number_of_threads++;<br></p><br><p><br>    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp; 代码:&nbsp;&nbsp;&nbsp;&nbsp;ThreadService::add_thread(p, daemon);<br></p><br><p><br>    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;oop thread_object = create_initial_thread(thread_group, main_thread, CHECK_0);<br></p><br><p><br>    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;main_thread-&gt;set_threadObj(thread_object);<br></p><br><p><br>    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;java_lang_Thread::set_thread_status(thread_object,&nbsp;java_lang_Thread::RUNNABLE);<br></p><br><p><br>    <br><br></p><br><p><br>    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp; 在执行完毕<span>Thread.cpp:CreateJavaVM后</span>，在java.c中<br></p><br><p><br>    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;mainClassName = GetMainClassName(env, jarfile);<br></p><br><p><br>    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;classname = (char )(<em>env)-&gt;GetStringUTFChars(env, mainClassName, 0);<br></em></p><br><p><br>    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;mainClass = LoadClass(env, classname);<br></p><br><p><br>    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;mainID = (env)-&gt;GetStaticMethodID(env, mainClass, “main”,&nbsp;”([Ljava/lang/String;)V”);<br></p><br><p><br>    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;jmethodID mid;<br></p><br><p><br>    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;jobject obj = (<em>env)-&gt;ToReflectedMethod(env, mainClass,mainID, JNI_TRUE);<br></em></p><br><p><br>    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;mid =&nbsp;(env)-&gt;GetMethodID(env,(<em>env)-&gt;GetObjectClass(env, obj),”getModifiers”, “()I”);<br></em></p><br><p><br>    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;mods = (env)-&gt;CallIntMethod(env, obj, mid);<br></p><br><p><br>    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<em>env)-&gt;CallStaticVoidMethod(env, mainClass, mainID, mainArgs);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp; //执行java的main方法<br></em></p><br><p><br>    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp; 代码:&nbsp;&nbsp;&nbsp;&nbsp;<span>env</span>-&gt;CallStaticVoidMethod( pClass, pMid, pArgs);<br></p><br><p><br>    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp; 代码:&nbsp;&nbsp;&nbsp;&nbsp;functions-&gt;CallStaticVoidMethodV(this,cls,methodID,args);<br></p><br><p><br>    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp; 代码:&nbsp; &nbsp; &nbsp;JavaValue jvalue(T_VOID);<br></p><br><p><br>    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;JNI_ArgumentPusherVaArg ap(THREAD, methodID, args);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp; //将参数推送到堆栈中<br></p><br><p><br>    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp; 调用父类构造函数:&nbsp;&nbsp;&nbsp;&nbsp;JNI_ArgumentPusher(thread, JNIHandles::resolve_jmethod_id(method_id)-&gt;signature())<br></p><br><p><br>    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;调用父类构造函数:&nbsp;&nbsp;&nbsp;&nbsp;SignatureIterator(thread, signature)<br></p><br><p><br>    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp; 代码:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;_signature &nbsp; &nbsp; &nbsp; = signature;<br></p><br><p><br>    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp; 代码:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;_parameter_index = 0;<br></p><br><p><br>    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp; 代码:&nbsp;&nbsp;&nbsp;&nbsp;this-&gt;_return_type = T_ILLEGAL;<br></p><br><p><br>    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp; 代码:&nbsp;&nbsp;&nbsp;&nbsp;_arguments = NULL;<br></p><br><p><br>    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp; 代码:&nbsp;&nbsp;&nbsp;&nbsp;set_ap(rap);<br></p><br><p><br>    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp; 代码:&nbsp;&nbsp;&nbsp;&nbsp;_ap = rap;<br></p><br><p><br>    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;jni_invoke_static(env, &amp;jvalue, NULL, JNI_STATIC, methodID, &amp;ap, CHECK);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp; //执行static方法，参数为ap，返回值为jvalue<br></p><br><p><br>    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp; 代码:&nbsp;&nbsp;&nbsp;&nbsp;methodHandle method(THREAD, JNIHandles::resolve_jmethod_id(method_id));&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br></p><br><p><br>    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp; 代码:&nbsp;&nbsp;&nbsp;&nbsp;ResourceMark rm(THREAD);<br></p><br><p><br>    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp; 代码:&nbsp;&nbsp;&nbsp;&nbsp;int number_of_parameters = method-&gt;size_of_parameters();<br></p><br><p><br>    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp; 代码:&nbsp;&nbsp;&nbsp;&nbsp;JavaCallArguments java_args(number_of_parameters);<br></p><br><p><br>    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span>代码:</span><span>&nbsp; &nbsp;&nbsp;</span>args-&gt;set_java_argument_object(&amp;java_args);<br></p><br><p><br>    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp; 代码:&nbsp;&nbsp;&nbsp;&nbsp;args-&gt;iterate( Fingerprinter(THREAD, method).fingerprint() );&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp; //???????????+++++++++++++++<br></p><br><p><br>    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp; 代码:&nbsp;&nbsp;&nbsp;&nbsp;result-&gt;set_type(args-&gt;get_ret_type());<br></p><br><p><br>    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;代码:&nbsp;&nbsp;&nbsp;&nbsp;JavaCalls::call(result, method, &amp;java_args, CHECK);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; invoke the method<br></p><br><p><br>    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp; 代码:&nbsp;&nbsp;&nbsp;&nbsp;JavaCalls::call<br></p><br><p><br>    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;代码:&nbsp;&nbsp;&nbsp;&nbsp;JavaCalls::call_helper<br></p><br><p><br>    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp; 代码:&nbsp;&nbsp;&nbsp;&nbsp;JavaCallWrapper link(method, receiver, result, CHECK);<br></p><br><p><br>    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp; 代码:&nbsp;&nbsp;&nbsp;&nbsp;address entry_point = method-&gt;from_interpreted_entry();<br></p><br><p><br>    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp; 代码:&nbsp;&nbsp;&nbsp;&nbsp;<br></p><br><p><br>    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp; 代码:&nbsp;&nbsp;&nbsp;&nbsp;StubRoutines::call_stub()(&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp; 调用Stub，在java中，每一个方法都会解析为一个Stub<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; (address)&amp;link,<br><br><span>&nbsp; &nbsp;&nbsp;</span><span>&nbsp;&nbsp;&nbsp;&nbsp;</span><span>&nbsp;&nbsp;&nbsp;&nbsp;</span><span>&nbsp;&nbsp;&nbsp;&nbsp;</span><span>&nbsp;&nbsp;&nbsp;&nbsp;</span><span>&nbsp;&nbsp;&nbsp;&nbsp;</span><span>&nbsp;&nbsp;&nbsp;&nbsp;</span><span>&nbsp;&nbsp;&nbsp;&nbsp;</span><span>&nbsp;&nbsp;&nbsp;&nbsp;</span><span>&nbsp;&nbsp;&nbsp;&nbsp;</span><span>&nbsp;&nbsp;&nbsp;&nbsp;</span><span>&nbsp;&nbsp;&nbsp;&nbsp;</span><span>&nbsp;&nbsp;&nbsp;&nbsp;</span><span>&nbsp;&nbsp;&nbsp;&nbsp;</span><span>&nbsp;&nbsp;&nbsp;&nbsp;</span><span>&nbsp;&nbsp;&nbsp;&nbsp;</span><span>&nbsp;&nbsp;&nbsp;&nbsp;</span><span>&nbsp;&nbsp;&nbsp;&nbsp;</span><span>&nbsp;&nbsp;&nbsp;&nbsp;</span><span>&nbsp;&nbsp;&nbsp;&nbsp;</span><span>&nbsp;&nbsp;&nbsp;&nbsp;</span><span>&nbsp;&nbsp;&nbsp;&nbsp;</span><span>&nbsp;&nbsp;&nbsp;&nbsp;</span><span>&nbsp; &nbsp;&nbsp;</span>&nbsp; &nbsp; &nbsp; &nbsp; // (intptr_t)&amp;(result-&gt;_value), // see NOTE above (compiler problem)<br><br>&nbsp; &nbsp; &nbsp;<span>&nbsp; &nbsp;&nbsp;</span><span>&nbsp;&nbsp;&nbsp;&nbsp;</span><span>&nbsp;&nbsp;&nbsp;&nbsp;</span><span>&nbsp;&nbsp;&nbsp;&nbsp;</span><span>&nbsp;&nbsp;&nbsp;&nbsp;</span><span>&nbsp;&nbsp;&nbsp;&nbsp;</span><span>&nbsp;&nbsp;&nbsp;&nbsp;</span><span>&nbsp;&nbsp;&nbsp;&nbsp;</span><span>&nbsp;&nbsp;&nbsp;&nbsp;</span><span>&nbsp;&nbsp;&nbsp;&nbsp;</span><span>&nbsp;&nbsp;&nbsp;&nbsp;</span><span>&nbsp;&nbsp;&nbsp;&nbsp;</span><span>&nbsp;&nbsp;&nbsp;&nbsp;</span><span>&nbsp;&nbsp;&nbsp;&nbsp;</span><span>&nbsp;&nbsp;&nbsp;&nbsp;</span><span>&nbsp;&nbsp;&nbsp;&nbsp;</span><span>&nbsp;&nbsp;&nbsp;&nbsp;</span><span>&nbsp;&nbsp;&nbsp;&nbsp;</span><span>&nbsp;&nbsp;&nbsp;&nbsp;</span><span>&nbsp;&nbsp;&nbsp;&nbsp;</span><span>&nbsp;&nbsp;&nbsp;&nbsp;</span><span>&nbsp;&nbsp;&nbsp;&nbsp;</span><span>&nbsp;&nbsp;&nbsp;&nbsp;</span><span>&nbsp; &nbsp;&nbsp;</span> &nbsp; result_val_address, &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;// see NOTE above (compiler problem)<br><br>&nbsp; &nbsp; <span>&nbsp; &nbsp;&nbsp;</span><span>&nbsp;&nbsp;&nbsp;&nbsp;</span><span>&nbsp;&nbsp;&nbsp;&nbsp;</span><span>&nbsp;&nbsp;&nbsp;&nbsp;</span><span>&nbsp;&nbsp;&nbsp;&nbsp;</span><span>&nbsp;&nbsp;&nbsp;&nbsp;</span><span>&nbsp;&nbsp;&nbsp;&nbsp;</span><span>&nbsp;&nbsp;&nbsp;&nbsp;</span><span>&nbsp;&nbsp;&nbsp;&nbsp;</span><span>&nbsp;&nbsp;&nbsp;&nbsp;</span><span>&nbsp;&nbsp;&nbsp;&nbsp;</span><span>&nbsp;&nbsp;&nbsp;&nbsp;</span><span>&nbsp;&nbsp;&nbsp;&nbsp;</span><span>&nbsp;&nbsp;&nbsp;&nbsp;</span><span>&nbsp;&nbsp;&nbsp;&nbsp;</span><span>&nbsp;&nbsp;&nbsp;&nbsp;</span><span>&nbsp;&nbsp;&nbsp;&nbsp;</span><span>&nbsp;&nbsp;&nbsp;&nbsp;</span><span>&nbsp;&nbsp;&nbsp;&nbsp;</span><span>&nbsp;&nbsp;&nbsp;&nbsp;</span><span>&nbsp;&nbsp;&nbsp;&nbsp;</span><span>&nbsp;&nbsp;&nbsp;&nbsp;</span><span>&nbsp;&nbsp;&nbsp;&nbsp;</span><span>&nbsp; &nbsp;&nbsp;</span>&nbsp; &nbsp; result_type,<br><br>&nbsp;<span>&nbsp; &nbsp;&nbsp;</span><span>&nbsp;&nbsp;&nbsp;&nbsp;</span><span>&nbsp;&nbsp;&nbsp;&nbsp;</span><span>&nbsp;&nbsp;&nbsp;&nbsp;</span><span>&nbsp;&nbsp;&nbsp;&nbsp;</span><span>&nbsp;&nbsp;&nbsp;&nbsp;</span><span>&nbsp;&nbsp;&nbsp;&nbsp;</span><span>&nbsp;&nbsp;&nbsp;&nbsp;</span><span>&nbsp;&nbsp;&nbsp;&nbsp;</span><span>&nbsp;&nbsp;&nbsp;&nbsp;</span><span>&nbsp;&nbsp;&nbsp;&nbsp;</span><span>&nbsp;&nbsp;&nbsp;&nbsp;</span><span>&nbsp;&nbsp;&nbsp;&nbsp;</span><span>&nbsp;&nbsp;&nbsp;&nbsp;</span><span>&nbsp;&nbsp;&nbsp;&nbsp;</span><span>&nbsp;&nbsp;&nbsp;&nbsp;</span><span>&nbsp;&nbsp;&nbsp;&nbsp;</span><span>&nbsp;&nbsp;&nbsp;&nbsp;</span><span>&nbsp;&nbsp;&nbsp;&nbsp;</span><span>&nbsp;&nbsp;&nbsp;&nbsp;</span><span>&nbsp;&nbsp;&nbsp;&nbsp;</span><span>&nbsp;&nbsp;&nbsp;&nbsp;</span><span>&nbsp;&nbsp;&nbsp;&nbsp;</span><span>&nbsp; &nbsp;&nbsp;</span> &nbsp; &nbsp; &nbsp; method(),<br><br><span>&nbsp; &nbsp;&nbsp;</span><span>&nbsp;&nbsp;&nbsp;&nbsp;</span><span>&nbsp;&nbsp;&nbsp;&nbsp;</span><span>&nbsp;&nbsp;&nbsp;&nbsp;</span><span>&nbsp;&nbsp;&nbsp;&nbsp;</span><span>&nbsp;&nbsp;&nbsp;&nbsp;</span><span>&nbsp;&nbsp;&nbsp;&nbsp;</span><span>&nbsp;&nbsp;&nbsp;&nbsp;</span><span>&nbsp;&nbsp;&nbsp;&nbsp;</span><span>&nbsp;&nbsp;&nbsp;&nbsp;</span><span>&nbsp;&nbsp;&nbsp;&nbsp;</span><span>&nbsp;&nbsp;&nbsp;&nbsp;</span><span>&nbsp;&nbsp;&nbsp;&nbsp;</span><span>&nbsp;&nbsp;&nbsp;&nbsp;</span><span>&nbsp;&nbsp;&nbsp;&nbsp;</span><span>&nbsp;&nbsp;&nbsp;&nbsp;</span><span>&nbsp;&nbsp;&nbsp;&nbsp;</span><span>&nbsp;&nbsp;&nbsp;&nbsp;</span><span>&nbsp;&nbsp;&nbsp;&nbsp;</span><span>&nbsp;&nbsp;&nbsp;&nbsp;</span><span>&nbsp;&nbsp;&nbsp;&nbsp;</span><span>&nbsp;&nbsp;&nbsp;&nbsp;</span><span>&nbsp;&nbsp;&nbsp;&nbsp;</span><span>&nbsp; &nbsp;&nbsp;</span>&nbsp; &nbsp; &nbsp; &nbsp; entry_point,<br><br>&nbsp; &nbsp;<span>&nbsp; &nbsp;&nbsp;</span><span>&nbsp;&nbsp;&nbsp;&nbsp;</span><span>&nbsp;&nbsp;&nbsp;&nbsp;</span><span>&nbsp;&nbsp;&nbsp;&nbsp;</span><span>&nbsp;&nbsp;&nbsp;&nbsp;</span><span>&nbsp;&nbsp;&nbsp;&nbsp;</span><span>&nbsp;&nbsp;&nbsp;&nbsp;</span><span>&nbsp;&nbsp;&nbsp;&nbsp;</span><span>&nbsp;&nbsp;&nbsp;&nbsp;</span><span>&nbsp;&nbsp;&nbsp;&nbsp;</span><span>&nbsp;&nbsp;&nbsp;&nbsp;</span><span>&nbsp;&nbsp;&nbsp;&nbsp;</span><span>&nbsp;&nbsp;&nbsp;&nbsp;</span><span>&nbsp;&nbsp;&nbsp;&nbsp;</span><span>&nbsp;&nbsp;&nbsp;&nbsp;</span><span>&nbsp;&nbsp;&nbsp;&nbsp;</span><span>&nbsp;&nbsp;&nbsp;&nbsp;</span><span>&nbsp;&nbsp;&nbsp;&nbsp;</span><span>&nbsp;&nbsp;&nbsp;&nbsp;</span><span>&nbsp;&nbsp;&nbsp;&nbsp;</span><span>&nbsp;&nbsp;&nbsp;&nbsp;</span><span>&nbsp;&nbsp;&nbsp;&nbsp;</span><span>&nbsp;&nbsp;&nbsp;&nbsp;</span><span>&nbsp; &nbsp;&nbsp;</span> &nbsp; &nbsp; args-&gt;parameters(),<br><br>&nbsp; &nbsp;<span>&nbsp; &nbsp;&nbsp;</span><span>&nbsp;&nbsp;&nbsp;&nbsp;</span><span>&nbsp;&nbsp;&nbsp;&nbsp;</span><span>&nbsp;&nbsp;&nbsp;&nbsp;</span><span>&nbsp;&nbsp;&nbsp;&nbsp;</span><span>&nbsp;&nbsp;&nbsp;&nbsp;</span><span>&nbsp;&nbsp;&nbsp;&nbsp;</span><span>&nbsp;&nbsp;&nbsp;&nbsp;</span><span>&nbsp;&nbsp;&nbsp;&nbsp;</span><span>&nbsp;&nbsp;&nbsp;&nbsp;</span><span>&nbsp;&nbsp;&nbsp;&nbsp;</span><span>&nbsp;&nbsp;&nbsp;&nbsp;</span><span>&nbsp;&nbsp;&nbsp;&nbsp;</span><span>&nbsp;&nbsp;&nbsp;&nbsp;</span><span>&nbsp;&nbsp;&nbsp;&nbsp;</span><span>&nbsp;&nbsp;&nbsp;&nbsp;</span><span>&nbsp;&nbsp;&nbsp;&nbsp;</span><span>&nbsp;&nbsp;&nbsp;&nbsp;</span><span>&nbsp;&nbsp;&nbsp;&nbsp;</span><span>&nbsp;&nbsp;&nbsp;&nbsp;</span><span>&nbsp;&nbsp;&nbsp;&nbsp;</span><span>&nbsp;&nbsp;&nbsp;&nbsp;</span><span>&nbsp;&nbsp;&nbsp;&nbsp;</span><span>&nbsp; &nbsp;&nbsp;</span> &nbsp; &nbsp; args-&gt;size_of_parameters(),<br><br>&nbsp; <span>&nbsp; &nbsp;&nbsp;</span><span>&nbsp;&nbsp;&nbsp;&nbsp;</span><span>&nbsp;&nbsp;&nbsp;&nbsp;</span><span>&nbsp;&nbsp;&nbsp;&nbsp;</span><span>&nbsp;&nbsp;&nbsp;&nbsp;</span><span>&nbsp;&nbsp;&nbsp;&nbsp;</span><span>&nbsp;&nbsp;&nbsp;&nbsp;</span><span>&nbsp;&nbsp;&nbsp;&nbsp;</span><span>&nbsp;&nbsp;&nbsp;&nbsp;</span><span>&nbsp;&nbsp;&nbsp;&nbsp;</span><span>&nbsp;&nbsp;&nbsp;&nbsp;</span><span>&nbsp;&nbsp;&nbsp;&nbsp;</span><span>&nbsp;&nbsp;&nbsp;&nbsp;</span><span>&nbsp;&nbsp;&nbsp;&nbsp;</span><span>&nbsp;&nbsp;&nbsp;&nbsp;</span><span>&nbsp;&nbsp;&nbsp;&nbsp;</span><span>&nbsp;&nbsp;&nbsp;&nbsp;</span><span>&nbsp;&nbsp;&nbsp;&nbsp;</span><span>&nbsp;&nbsp;&nbsp;&nbsp;</span><span>&nbsp;&nbsp;&nbsp;&nbsp;</span><span>&nbsp;&nbsp;&nbsp;&nbsp;</span><span>&nbsp;&nbsp;&nbsp;&nbsp;</span><span>&nbsp;&nbsp;&nbsp;&nbsp;</span><span>&nbsp; &nbsp;&nbsp;</span>&nbsp; &nbsp; &nbsp; CHECK<br><br>&nbsp; &nbsp;<span>&nbsp; &nbsp;&nbsp;</span><span>&nbsp;&nbsp;&nbsp;&nbsp;</span><span>&nbsp;&nbsp;&nbsp;&nbsp;</span><span>&nbsp;&nbsp;&nbsp;&nbsp;</span><span>&nbsp;&nbsp;&nbsp;&nbsp;</span><span>&nbsp;&nbsp;&nbsp;&nbsp;</span><span>&nbsp;&nbsp;&nbsp;&nbsp;</span><span>&nbsp;&nbsp;&nbsp;&nbsp;</span><span>&nbsp;&nbsp;&nbsp;&nbsp;</span><span>&nbsp;&nbsp;&nbsp;&nbsp;</span><span>&nbsp;&nbsp;&nbsp;&nbsp;</span><span>&nbsp;&nbsp;&nbsp;&nbsp;</span><span>&nbsp;&nbsp;&nbsp;&nbsp;</span><span>&nbsp;&nbsp;&nbsp;&nbsp;</span><span>&nbsp;&nbsp;&nbsp;&nbsp;</span><span>&nbsp;&nbsp;&nbsp;&nbsp;</span><span>&nbsp;&nbsp;&nbsp;&nbsp;</span><span>&nbsp;&nbsp;&nbsp;&nbsp;</span><span>&nbsp;&nbsp;&nbsp;&nbsp;</span><span>&nbsp;&nbsp;&nbsp;&nbsp;</span><span>&nbsp;&nbsp;&nbsp;&nbsp;</span><span>&nbsp;&nbsp;&nbsp;&nbsp;</span><span>&nbsp;&nbsp;&nbsp;&nbsp;</span><span>&nbsp; &nbsp;&nbsp;</span> &nbsp; );<br></p><br><p><br>    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp; 代码:&nbsp;&nbsp;&nbsp;&nbsp;<span style="font-family:'Courier New', monospace;background-color:#F7F7F7;">result = link.result();</span><br></p><br><p><br>    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp; 代码:&nbsp;&nbsp;&nbsp;&nbsp;result-&gt;set_jobject((jobject)thread-&gt;vm_result());<br></p><br><p><br>    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br></p><br><p><br>    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp; 代码:&nbsp;&nbsp;&nbsp;&nbsp;if (result-&gt;get_type() == T_OBJECT || result-&gt;get_type() == T_ARRAY) {<br><br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;result-&gt;set_jobject(JNIHandles::make_local(env, (oop) result-&gt;get_jobject()));<br><br><span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;</span><span>&nbsp; &nbsp;</span>&nbsp; }<br></p><br><p><br>    <br><br></p><br><p><br>    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ret = (*env)-&gt;ExceptionOccurred(env) == NULL ? 0 : 1;<br></p><br><p><br>    &nbsp; &nbsp; 至此，可以看到<br></p><br><p><br>    &nbsp; &nbsp; java.c中的launcher创建了JVM环境，然后获取到了java的main方法，然后执行jenv-&gt;<span>CallStaticVoidMethod函数，触发了<span>jni_invoke_static函数，之后触发了</span><span>StubRoutines::call_stub()所代表的函数指针</span></span><br></p><br><p><br>    <span><br><br></span><br></p><br><p><br>    <span>&nbsp; &nbsp; 那么问题来了，<span>StubRoutines是什么东西，是在什么时候产生的？其内部又会对JavaThread的属性产生什么操作？其内部是如何调用到<span>entry_point即</span><span>method-&gt;from_interpreted_entry()的?</span></span></span><br></p><br><p><br>    <span><span>&nbsp; &nbsp; 可以阅读一下R大的博客<a href="http://hllvm.group.iteye.com/group/topic/37707，权当预习。" target="_blank" rel="external">http://hllvm.group.iteye.com/group/topic/37707，权当预习。</a></span></span><br></p><br><p><br>    <span><span>&nbsp; &nbsp; 这个行业前辈众多，需要膜拜之……例如R大，在我刚学Java之时他成名已久</span></span><br></p><br><p><br>    <br><br></p><br><p><br>    <br><br></p></div><p class="readmore"><a href="/2016/03/03/2016-03-03-JVM_MAINTHREAD_START/">Mehr lesen</a></p></div><nav class="page-navigator"><a class="extend prev" rel="prev" href="/">Vorheriger</a><a class="page-number" href="/">1</a><span class="page-number current">2</span><a class="page-number" href="/page/3/">3</a><a class="page-number" href="/page/4/">4</a><span class="space">&hellip;</span><a class="page-number" href="/page/7/">7</a><a class="extend next" rel="next" href="/page/3/">Nächster</a></nav></div></div><div class="pure-u-1-4 hidden_mid_and_down"><div id="sidebar"><div class="widget"><form action="//www.baidu.com/baidu" method="get" accept-charset="utf-8" target="_blank" class="search-form"><input type="search" name="word" maxlength="20" placeholder="Search"/><input type="hidden" name="si" value="https://kanmars.github.io"/><input name="tn" type="hidden" value="bds"/><input name="cl" type="hidden" value="3"/><input name="ct" type="hidden" value="2097152"/><input name="s" type="hidden" value="on"/></form></div><div class="widget"><div class="widget-title"><i class="fa fa-folder-o"> Kategorien</i></div></div><div class="widget"><div class="widget-title"><i class="fa fa-star-o"> Tags</i></div><div class="tagcloud"><a href="/tags/jetty/" style="font-size: 15px;">jetty</a> <a href="/tags/it/" style="font-size: 15px;">it</a> <a href="/tags/architecture/" style="font-size: 15px;">architecture</a> <a href="/tags/itlife/" style="font-size: 15px;">itlife</a> <a href="/tags/rsa/" style="font-size: 15px;">rsa</a> <a href="/tags/tb/" style="font-size: 15px;">tb</a> <a href="/tags/drawline/" style="font-size: 15px;">drawline</a> <a href="/tags/life/" style="font-size: 15px;">life</a> <a href="/tags/strategy/" style="font-size: 15px;">strategy</a> <a href="/tags/tblife/" style="font-size: 15px;">tblife</a> <a href="/tags/java/" style="font-size: 15px;">java</a> <a href="/tags/linux/" style="font-size: 15px;">linux</a> <a href="/tags/spring/" style="font-size: 15px;">spring</a> <a href="/tags/server/" style="font-size: 15px;">server</a> <a href="/tags/c/" style="font-size: 15px;">c</a> <a href="/tags/c/" style="font-size: 15px;">c++</a> <a href="/tags/lua/" style="font-size: 15px;">lua</a> <a href="/tags/android/" style="font-size: 15px;">android</a> <a href="/tags/javascript/" style="font-size: 15px;">javascript</a> <a href="/tags/neuralnetwork/" style="font-size: 15px;">neuralnetwork</a> <a href="/tags/cpu/" style="font-size: 15px;">cpu</a> <a href="/tags/disk/" style="font-size: 15px;">disk</a> <a href="/tags/fidsk/" style="font-size: 15px;">fidsk</a> <a href="/tags/fstab/" style="font-size: 15px;">fstab</a> <a href="/tags/lvm/" style="font-size: 15px;">lvm</a> <a href="/tags/aix/" style="font-size: 15px;">aix</a></div></div><div class="widget"><div class="widget-title"><i class="fa fa-file-o"> Letzte</i></div><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/2016/11/18/2016-11-18-springmvc_source_004_viewresolver/">[KANMARS原创]-SpringMVC源码解析(4) - 视图处理器</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/11/18/2016-11-18-springmvc_source_003_requestprocess/">[KANMARS原创]-SpringMVC源码解析(3) - 请求处理过程</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/11/17/2016-11-17-springmvc_source_002_start/">[KANMARS原创]-SpringMVC源码解析(2) - 启动过程</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/11/17/2016-11-17-springmvc_source_001_introduce/">[KANMARS原创]-SpringMVC源码解析(1) - 简介</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/11/04/2016-11-04-SomeThingAndNothing/">SomeThingAndNothing</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/10/25/2016-10-25-news-LongRoad/">news It's a Long Road</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/10/19/2016-10-19-Scale-Services/">On Designing and Deploying Internet-Scale Services</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/10/18/2016-10-18-dubbo_source_006_summarize/">[KANMARS原创]-DUBBO源码解析(6)-summarize</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/10/18/2016-10-18-dubbo_source_005_consumerCall/">[KANMARS原创]-DUBBO源码解析(5)-consumerCall</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/09/19/2016-09-08-dubbo_source_004_referenceBean/">[KANMARS原创]-DUBBO源码解析(4)-referenceBean</a></li></ul></div><div class="widget"><div class="comments-title"><i class="fa fa-comment-o"> Letzte Kommentare</i></div><div data-num-items="5" data-show-avatars="0" data-show-time="1" data-show-admin="0" data-excerpt-length="32" data-show-title="1" class="ds-recent-comments"></div></div><div class="widget"><div class="widget-title"><i class="fa fa-external-link"> Blogroll</i></div><ul></ul><a href="http://www.linux.cn" title="Linux-CN" target="_blank">Linux-CN</a><ul></ul><a href="http://www.gome.com.cn" title="国美互联网" target="_blank">国美互联网</a><ul></ul><a href="http://jr.gome.com.cn" title="国美金融" target="_blank">国美金融</a></div></div></div><div class="pure-u-1 pure-u-md-3-4"><div id="footer">© <a href="/." rel="nofollow">KANMARS的博客.</a> Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a><a rel="nofollow" target="_blank" href="https://github.com/tufu9441/maupassant-hexo"> Theme</a> by<a rel="nofollow" target="_blank" href="https://github.com/pagecho"> Cho.</a></div></div></div><a id="rocket" href="#top" class="show"></a><script type="text/javascript" src="/js/totop.js?v=0.0.0" async></script><script type="text/javascript" src="//cdn.bootcss.com/fancybox/2.1.5/jquery.fancybox.pack.js" async></script><script type="text/javascript" src="/js/fancybox.js?v=0.0.0" async></script><link rel="stylesheet" type="text/css" href="/css/jquery.fancybox.css?v=0.0.0"><script>var duoshuoQuery = {short_name:'kanmars'};
(function() {
    var ds = document.createElement('script');
    ds.type = 'text/javascript';ds.async = true;
    ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
    ds.charset = 'UTF-8';
    (document.getElementsByTagName('head')[0]
        || document.getElementsByTagName('body')[0]).appendChild(ds);
})();
</script><script type="text/javascript" src="/js/codeblock-resizer.js?v=0.0.0"></script><script type="text/javascript" src="/js/smartresize.js?v=0.0.0"></script></div></body></html>