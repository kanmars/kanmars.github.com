<!DOCTYPE html><html lang="null"><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description"><title>[KANMARS原创] - (五) 从JVM源码来理解JVM中的线程种类与启动方式 | KANMARS的博客</title><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/normalize/5.0.0/normalize.min.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/pure/0.6.0/pure-min.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/pure/0.6.0/grids-responsive-min.css"><link rel="stylesheet" type="text/css" href="/css/style.css?v=0.0.0"><link rel="stylesheet" href="//cdn.bootcss.com/font-awesome/4.7.0/css/font-awesome.min.css"><script type="text/javascript" src="//cdn.bootcss.com/jquery/3.1.1/jquery.min.js"></script><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">[KANMARS原创] - (五) 从JVM源码来理解JVM中的线程种类与启动方式</h1><a id="logo" href="/.">KANMARS的博客</a><p class="description">helloword 2046。趁着，我会喜怒你会哀乐，唱几分钟情歌。</p></div><div id="nav-menu"><a href="/." class="current"><i class="fa fa-home"> 홈</i></a><a href="/archives/"><i class="fa fa-archive"> 아카이브</i></a><a href="/2016/04/23/2016-04-23-mysongs/"><i class="fa fa-user"> 소개</i></a></div></div><div id="layout" class="pure-g"><div class="pure-u-1 pure-u-md-3-4"><div class="content_container"><div class="post"><h1 class="post-title">[KANMARS原创] - (五) 从JVM源码来理解JVM中的线程种类与启动方式</h1><div class="post-meta">Feb 29, 2016</div><a data-thread-key="2016/02/29/2016-02-29-JVM_THREAD_TYPEANDRUN/" href="/2016/02/29/2016-02-29-JVM_THREAD_TYPEANDRUN/#comments" class="ds-thread-count"></a><div class="post-content"><p><br>    JVM中的线程详解<br></p><br><p><br>    在JVM的\hotsopt\src\share\vm\runtime\Thread.hpp中可以看到关于THREAD的子类结构<br></p><br><p><br>    // Class hierarchy<br><br>// - Thread<br><br>// &nbsp; - NamedThread<br><br>// &nbsp; &nbsp; - VMThread<br><br>// &nbsp; &nbsp; - ConcurrentGCThread<br><br>// &nbsp; &nbsp; - WorkerThread<br><br>// &nbsp; &nbsp; &nbsp; - GangWorker<br><br>// &nbsp; &nbsp; &nbsp; - GCTaskThread<br><br>// &nbsp; - JavaThread<br></p><br><p><br>    // &nbsp; &nbsp; -&nbsp;LowMemoryDetectorThread<br></p><br><p><br>    // &nbsp; &nbsp; - CompilerThread<br></p><br><p><br>    // &nbsp; - WatcherThread<br><br>Thread是最基础的基类<br></p><br><p><br>    重要属性如下：<br></p><br><p><br>    OSThread<em> _osthread;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;<br></em></p><br><p><br>    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp; 在OSThread内部set_thread_id方法可以设置为操作系统级的线程ID &nbsp;pthreadid<br></p><br><p><br>    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp; 在JVM的线程管理中,THREAD是一个数据结构，THREAD中含有抽象的OSThread数据结构，OSThread中的pthreadid或者threadid指向的是操作系统内核级别的线程id<br></p><br><p><br>    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp; 关于操作系统内核级别的线程，大家可以阅读原生C语言的多线程编程接口POSIX threads 简称pthread库<br></p><br><p><br>    重要函数如下：<br></p><br><p><br>    virtual void run();&nbsp; &nbsp; 为最终的线程运行方法<br></p><br><p><br>    <br><br></p><br><p><br>    此外有一个工具性质的类Th<span>r</span>eads<br></p><br><p><br>    重要属性如下：<br></p><br><p><br>    &nbsp; static JavaThread _thread_list;<br><br>&nbsp; static int &nbsp; &nbsp; &nbsp; &nbsp; _number_of_threads;<br><br>&nbsp; static int &nbsp; &nbsp; &nbsp; &nbsp; _number_of_non_daemon_threads;<br><br>&nbsp; static int &nbsp; &nbsp; &nbsp; &nbsp; _return_code;<br></p><br><p><br>    储存了所有正在运行的Java线程<br></p><br><p><br>    <br><br></p><br><p><br>    <br><br></p><br><p><br>    <br><br></p><br><p><br>    ————————————————————————————————————————————————————————————————<br></p><br><p><br>    可以看到，线程粗分为三类：<br><br>NamedThread、JavaThread、WatcherThread<br></p><br><p><br>    这三类中<br></p><br><p><br>    <span style="color:#E53333;background-color:#000000;">NamedThread</span>是一个大类<br></p><br><p><br>    <br><br></p><br><p><br>    按照源码中的注释：<br></p><br><p><br>    // Name support for threads. &nbsp;non-JavaThread subclasses with multiple<br><br>// uniquely named instances should derive from this.<br><br>max_name_len = 64，最大名称长度为64个字符<br></p><br><p><br>    重要属性为<br></p><br><p><br>    char<em> _name;<br></em></p><br><p><br>    JavaThread _processed_thread;<br></p><br><p><br>    也就是说NamedThread中可以有OSThread也可以有JavaThread<br></p><br><div><br>    <span style="line-height:1.5;"></span><br></div><br><p><br>    <br><br></p><br><p><br>    <span style="color:#E53333;background-color:#000000;">JavaThread</span>是JAVA线程<br></p><br><p><br>    重要属性如下：<br></p><br><p><br>    JavaThread<em> &nbsp; &nbsp;_next;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp; //&nbsp;The next thread in the Threads list<br></em></p><br><p><br>    oop &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;_threadObj;&nbsp; &nbsp; //&nbsp;The Java level thread object<br></p><br><p><br>    int _java_call_counter;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // java调用次数<br></p><br><p><br>    JavaFrameAnchor _anchor; // JavaFrame锚点<br></p><br><p><br>    ThreadFunction _entry_point;<br></p><br><p><br>    JNIEnv &nbsp; &nbsp; &nbsp; &nbsp;_jni_environment;<br></p><br><p><br>    vframeArray &nbsp;_vframe_array_head;<br></p><br><p><br>    vframeArray<em> &nbsp;_vframe_array_last;<br></em></p><br><p><br>    GrowableArray&lt;jvmtiDeferredLocalVariableSet&gt;<em> _deferred_locals_updates;&nbsp; &nbsp; 本地变量表<br></em></p><br><p><br>    oop &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; _vm_result; &nbsp; &nbsp;// Used to pass back an oop result into Java code, GC-preserved<br></p><br><p><br>    oop &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; _vm_result_2; &nbsp;// Used to pass back an oop result into Java code, GC-preserved<br></p><br><p><br>    ThreadSafepointState _safepoint_state;<br></p><br><p><br>    address &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; _saved_exception_pc;<br></p><br><p><br>    volatile oop &nbsp; &nbsp; _exception_oop;<br></p><br><p><br>    volatile address _exception_pc;<br></p><br><p><br>    volatile address _exception_handler_pc;<br></p><br><p><br>    volatile int &nbsp; &nbsp; _exception_stack_size;<br></p><br><p><br>    volatile int &nbsp; &nbsp; _is_method_handle_return;<br></p><br><p><br>    <br><br></p><br><p><br>    重要方法如下：<br></p><br><p><br>    void java_suspend();<br></p><br><p><br>    void java_resume();<br></p><br><p><br>    int &nbsp;java_suspend_self();<br></p><br><p><br>    virtual void run();<br></p><br><p><br>    <span style="color:#E53333;background-color:#000000;"></span><span><span style="color:#E53333;background-color:#000000;">WatcherThread</span>是用来模拟时间中断</span><br></p><br><p><br>    <span>重要属性如下：</span><br></p><br><p><br>    <span>static WatcherThread<em> _watcher_thread;</em></span><br></p><br><p><br>    <span>volatile static bool _should_terminate;</span><br></p><br><p><br>    <span><span>————————————————————————————————————————————————————————————————</span><br><br></span><br></p><br><p><br>    <span><span><span><span>// &nbsp; - NamedThread</span><br><br><span>// &nbsp; &nbsp; - VMThread</span><br><br><span>// &nbsp; &nbsp; - ConcurrentGCThread</span><br><br><span>// &nbsp; &nbsp; - WorkerThread</span><br><br><span>// &nbsp; &nbsp; &nbsp; - GangWorker</span><br><br><span>// &nbsp; &nbsp; &nbsp; - GCTaskThread</span></span></span></span><br></p><br><p><br>    <span><span><span><span>NameThread下分为三大类VMTh<span>r</span>ead,ConcurrentGCThread,WorkerThread</span></span></span></span><br></p><br><p><br>    <span style="color:#E53333;background-color:#000000;">首先看VMThread</span><br></p><br><p><br>    VMThread位于\hotspot\src\share\vm\runtime\vmThread.hpp中<br></p><br><p><br>    重要属性如下:<br></p><br><p><br>    static VM_Operation &nbsp; &nbsp; _cur_vm_operation;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp; 当前正在执行的VM操作<br></p><br><p><br>    static VMOperationQueue<em> _vm_queue;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp; 所有VM操作的对象<br></em></p><br><p><br>    static VMThread &nbsp; &nbsp; _vm_thread;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp; 单例模式的VMThread<br></p><br><p><br>    重要方法如下：<br></p><br><p><br>    void evaluate_operation(VM_Operation<em> op);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp; 执行一个VM操作<br></em></p><br><p><br>    bool is_VM_thread() const &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;{ return true; }&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp; //默认为VMThread<br><br>bool is_GC_thread() const &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;{ return true; }&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp; //默认为GCThread<br></p><br><p><br>    与VMThread配套使用的是VMOperationQueue和VM_Operation<br></p><br><p><br>    <span><span style="color:#E53333;background-color:#000000;">VMOperationQueue</span>位于</span><span>\hotspot\src\share\vm\runtime\vmThread.hpp中</span><br></p><br><p><br>    重要属性如下：<br></p><br><p><br>    int &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; _queue_length[nof_priorities];<br></p><br><p><br>    VM_Operation _queue &nbsp; &nbsp; &nbsp; [nof_priorities];<br></p><br><p><br>    int &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; _queue_counter;<br></p><br><p><br>    VM_Operation<em> _drain_list;<br></em></p><br><p><br>    <span style="color:#E53333;background-color:#000000;"></span><span><span style="color:#E53333;background-color:#000000;">VM_Operation</span>位于</span><span></span><span>\hotspot\src\share\vm\runtime\Vm_operations.hpp中</span><br></p><br><p><br>    重要属性如下：<br></p><br><p><br>    Thread &nbsp; &nbsp; &nbsp; &nbsp; _calling_thread;<br></p><br><p><br>    VM_Operation<em> &nbsp; _next;<br></em></p><br><p><br>    VM_Operation &nbsp; _prev;<br></p><br><p><br>    void evaluate();<br></p><br><p><br>    virtual void doit()<br></p><br><p><br>    virtual bool doit_prologue()<br></p><br><p><br>    virtual void doit_epilogue()<br></p><br><p><br>    VM_ThreadStop<span>位于</span><span></span><span></span><span>\hotspot\src\share\vm\runtime\Vm_operations.hpp中</span><br></p><br><p><br>    重要属性如下<br></p><br><p><br>    oop &nbsp; &nbsp; _thread;<br></p><br><p><br>    oop &nbsp; &nbsp; _throwable;<br></p><br><p><br>    此外和VMThread相关联的VM_Operation还有<br></p><br><p><br>    VM_ForceSafepoint<br></p><br><p><br>    VM_ForceAsyncSafepoint<br></p><br><p><br>    VM_Deoptimize<br></p><br><p><br>    VM_DeoptimizeFrame<br></p><br><p><br>    VM_HandleFullCodeCache<br></p><br><p><br>    VM_DeoptimizeAll<br></p><br><p><br>    VM_ZombieAll<br></p><br><p><br>    VM_Verify<br></p><br><p><br>    VM_PrintThreads<br></p><br><p><br>    VM_PrintJNI<br></p><br><p><br>    VM_FindDeadlocks<br></p><br><p><br>    VM_ThreadDump<br></p><br><p><br>    VM_Exit<br></p><br><p><br>    可从名称中看到其用途<br></p><br><p><br>    举个简单的栗子，<span>VM_PrintJNI</span><br></p><br><p><br>    <span>void VM_Operation::evaluate() {<br><br>&nbsp; ResourceMark rm;<br><br>&nbsp; if (TraceVMOperation) {<br><br>&nbsp; &nbsp; tty-&gt;print(“[“);<br><br>&nbsp; &nbsp; NOT_PRODUCT(print();)<br><br>&nbsp; }<br><br>&nbsp; doit();<br><br>&nbsp; if (TraceVMOperation) {<br><br>&nbsp; &nbsp; tty-&gt;print_cr(“]”);<br><br>&nbsp; }<br><br>}<br><br></span><br></p><br><p><br>    <span>void VM_PrintJNI::doit() {<br><br>&nbsp; JNIHandles::print_on(_out);<br><br>}</span><br></p><br><p><br>    <span>—————————————————————-</span><br></p><br><p><br>    <span><span style="color:#E53333;background-color:#000000;">Concurr</span><span style="color:#E53333;background-color:#000000;">entGCThread</span>位于\hotspot\src\share\vm\gc_implementation\shared\concurrentGCThread.hpp中</span><br></p><br><p><br>    <span>含义如其名称，并发垃圾回收线程</span><br></p><br><p><br>    <span><br><br></span><br></p><br><p><br>    <span><br><br></span><br></p><br><p><br>    <span><span style="color:#E53333;background-color:#000000;">WorkerT</span><span><span style="color:#E53333;background-color:#000000;">hread</span><span style="color:#E53333;background-color:#000000;">有两个子类：</span></span><span style="color:#E53333;background-color:#000000;">GangWorker、</span><span style="color:#E53333;background-color:#000000;">GCTaskT</span><span style="color:#E53333;background-color:#000000;">hread</span></span><br></p><br><p><br>    <span>子类极多。启动过程有很大区别，例如</span><br></p><br><p><br>    <span>GangWorker在WorkGang::initialize_workers()中GangWorker<em> new_worker = allocate_worker(worker);中创建</em></span><br></p><br><p><br>    <span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp; 例如FlexibleWorkGang &nbsp;&nbsp;_workers-&gt;initialize_workers();<br><br></span><br></p><br><p><br>    <span>GCTaskThread的初始化与启动在</span><br></p><br><p><br>    <span>ParallelScavengeHeap::initialize()</span><br></p><br><p><br>    <span>_gc_task_manager = GCTaskManager::create(ParallelGCThreads);</span><br></p><br><p><br>    <span>在构造函数中调用:initialize();<br><br></span><br></p><br><p><br>    <span>GCTaskManager::initialize()</span><br></p><br><p><br>    <span>&nbsp;&nbsp;&nbsp;&nbsp;set_thread(t, GCTaskThread::create(this, t, processor_assignment[t]));</span><br></p><br><p><br>    <span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;new GCTaskThread(manager, which, processor_id)</span><br></p><br><p><br>    <span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;os::create_thread(this, os::pgc_thread)</span><br></p><br><p><br>    <span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span>&nbsp;&nbsp;&nbsp;&nbsp;osthread-&gt;set_thread_type(thr_type);</span><br><br></span><br></p><br><p><br>    <span><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;thread-&gt;run();</span></span><br></p><br><p><br>    <span><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span>GCTaskT</span><span>hread-&gt;run();</span><br><br></span></span><br></p><br><p><br>    <span><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;GCTask task = manager()-&gt;get_task(which());&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp; 即：任何一个进程，只要在manager的任务队列中放入task，后续将会立刻执行</span></span><br></p><br><p><br>    <span><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;task-&gt;do_it(manager(), which());&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp; <br><br></span></span><br></p><br><p><br>    <span>从这段描述中可以看到，WorkerThread本身即为垃圾回收线程，大致分为两类：</span><br></p><br><p><br>    <span>1、GangWorker，作用于SharedHeap，在ShareHeap创建成功后，等待AbstractWorkGang-&gt;AbstractGangTask<em> _task中获取到task，然后执行</em></span><br></p><br><p><br>    <span>2、<span>GCTaskT</span><span>hread，作用于</span>parallelscavenge,在<span>ParallelScavengeHeap创建成功后，生成</span><span>GCTaskManager，进而生成任务队列</span>SynchronizedGCTaskQueue &nbsp;_queue，等待有程序将任务放入队列，然后执行</span><br></p><br><p><br>    <br><br></p><br><p><br>    <span style="line-height:1.5;"><span>—————————————————————-</span></span><br></p><br><p><br>    <span style="line-height:1.5;">下文我们来看一下VMThread的启动过程</span><br></p><br><p><br>    <span>VMThread是用于JVM虚拟机操作 </span><br></p><br><p><br>    <span>其启动过程为随着JVM虚拟机java.c一起启动</span><br></p><br><p><br>    <span>调用堆栈序列为:</span><br></p><br><p><br>    <span>java.c:main-&gt;javaMain-&gt;InitializeJVM-&gt;CreateJavaVM-&gt;JNI_CreateJavaVM-&gt;Threads::create_vm</span><br></p><br><p><br>    <span>&nbsp;&nbsp;&nbsp;&nbsp;VMThread::create();&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp; 生成单例模式的_vm_thread</span><br></p><br><p><br>    <span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;_vm_thread = new VMThread();</span><br></p><br><p><br>    <span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;_vm_queue = new VMOperationQueue();</span><br></p><br><p><br>    <span>&nbsp;&nbsp;&nbsp;&nbsp;os::create_thread(vmthread, os::vm_thread)&nbsp; &nbsp; 给VMThread创建真实线程</span><br></p><br><p><br>    <span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;OSThread<em> osthread = new OSThread(NULL, NULL);</em></span><br></p><br><p><br>    <span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;pd_initialize();</span><br></p><br><p><br>    <span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;_startThread_lock = new Monitor(Mutex::event, “startThread_lock”, true); &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;锁监视器，第一个和第三个参数均没有用，只有第二个参数会作为Monitor的名名称</span><br></p><br><p><br>    <span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp; 内部具有_LockWord关键字，同时具有CASPTR宏Atomic::cmpxchg_ptr用来对数据进行原子性操作，底层采用AMD64汇编指令cmpxchgq来完成原子性操作<br><br></span><br></p><br><p><br>    <span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Monitor::Monitor() { ClearMonitor(this); }</span><br></p><br><p><br>    <span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;void Monitor::ClearMonitor (Monitor  m, const char <em>name) {<br><br>&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;m-&gt;_owner &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; = NULL ;<br><br>&nbsp; <span>&nbsp; &nbsp;&nbsp;</span><span>&nbsp;&nbsp;&nbsp;&nbsp;</span><span>&nbsp;&nbsp;&nbsp;&nbsp;</span><span>&nbsp;&nbsp;&nbsp;&nbsp;</span><span>&nbsp;&nbsp;&nbsp;&nbsp;</span><span>&nbsp;&nbsp;&nbsp;&nbsp;</span><span>&nbsp;&nbsp;&nbsp;&nbsp;</span><span>&nbsp; &nbsp;&nbsp;</span>m-&gt;_snuck &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; = false ;<br><br><span>&nbsp; &nbsp;&nbsp;</span><span>&nbsp;&nbsp;&nbsp;&nbsp;</span><span>&nbsp;&nbsp;&nbsp;&nbsp;</span><span>&nbsp;&nbsp;&nbsp;&nbsp;</span><span>&nbsp;&nbsp;&nbsp;&nbsp;</span><span>&nbsp;&nbsp;&nbsp;&nbsp;</span><span>&nbsp;&nbsp;&nbsp;&nbsp;</span><span>&nbsp; &nbsp;&nbsp;</span>&nbsp; if (name == NULL) {<br><br>&nbsp;<span>&nbsp; &nbsp;&nbsp;</span><span>&nbsp;&nbsp;&nbsp;&nbsp;</span><span>&nbsp;&nbsp;&nbsp;&nbsp;</span><span>&nbsp;&nbsp;&nbsp;&nbsp;</span><span>&nbsp;&nbsp;&nbsp;&nbsp;</span><span>&nbsp;&nbsp;&nbsp;&nbsp;</span><span>&nbsp;&nbsp;&nbsp;&nbsp;</span><span>&nbsp; &nbsp;&nbsp;</span> &nbsp; strcpy(m-&gt;_name, “UNKNOWN”) ;<br><br>&nbsp;<span>&nbsp; &nbsp;&nbsp;</span><span>&nbsp;&nbsp;&nbsp;&nbsp;</span><span>&nbsp;&nbsp;&nbsp;&nbsp;</span><span>&nbsp;&nbsp;&nbsp;&nbsp;</span><span>&nbsp;&nbsp;&nbsp;&nbsp;</span><span>&nbsp;&nbsp;&nbsp;&nbsp;</span><span>&nbsp;&nbsp;&nbsp;&nbsp;</span><span>&nbsp; &nbsp;&nbsp;</span> } else {<br><br>&nbsp; <span>&nbsp; &nbsp;&nbsp;</span><span>&nbsp;&nbsp;&nbsp;&nbsp;</span><span>&nbsp;&nbsp;&nbsp;&nbsp;</span><span>&nbsp;&nbsp;&nbsp;&nbsp;</span><span>&nbsp;&nbsp;&nbsp;&nbsp;</span><span>&nbsp;&nbsp;&nbsp;&nbsp;</span><span>&nbsp;&nbsp;&nbsp;&nbsp;</span><span>&nbsp; &nbsp;&nbsp;</span>&nbsp; strncpy(m-&gt;_name, name, MONITOR_NAME_LEN - 1);<br><br>&nbsp; <span>&nbsp; &nbsp;&nbsp;</span><span>&nbsp;&nbsp;&nbsp;&nbsp;</span><span>&nbsp;&nbsp;&nbsp;&nbsp;</span><span>&nbsp;&nbsp;&nbsp;&nbsp;</span><span>&nbsp;&nbsp;&nbsp;&nbsp;</span><span>&nbsp;&nbsp;&nbsp;&nbsp;</span><span>&nbsp;&nbsp;&nbsp;&nbsp;</span><span>&nbsp; &nbsp;&nbsp;</span>&nbsp; m-&gt;_name[MONITOR_NAME_LEN - 1] = ‘\0’;<br><br><span>&nbsp; &nbsp;&nbsp;</span><span>&nbsp;&nbsp;&nbsp;&nbsp;</span><span>&nbsp;&nbsp;&nbsp;&nbsp;</span><span>&nbsp;&nbsp;&nbsp;&nbsp;</span><span>&nbsp;&nbsp;&nbsp;&nbsp;</span><span>&nbsp;&nbsp;&nbsp;&nbsp;</span><span>&nbsp;&nbsp;&nbsp;&nbsp;</span><span>&nbsp; &nbsp;&nbsp;</span>&nbsp; }<br><br><span>&nbsp; &nbsp;&nbsp;</span><span>&nbsp;&nbsp;&nbsp;&nbsp;</span><span>&nbsp;&nbsp;&nbsp;&nbsp;</span><span>&nbsp;&nbsp;&nbsp;&nbsp;</span><span>&nbsp;&nbsp;&nbsp;&nbsp;</span><span>&nbsp;&nbsp;&nbsp;&nbsp;</span><span>&nbsp;&nbsp;&nbsp;&nbsp;</span><span>&nbsp; &nbsp;&nbsp;</span>&nbsp; m-&gt;_LockWord.FullWord = 0 ;<br><br><span>&nbsp; &nbsp;&nbsp;</span><span>&nbsp;&nbsp;&nbsp;&nbsp;</span><span>&nbsp;&nbsp;&nbsp;&nbsp;</span><span>&nbsp;&nbsp;&nbsp;&nbsp;</span><span>&nbsp;&nbsp;&nbsp;&nbsp;</span><span>&nbsp;&nbsp;&nbsp;&nbsp;</span><span>&nbsp;&nbsp;&nbsp;&nbsp;</span><span>&nbsp; &nbsp;&nbsp;</span>&nbsp; m-&gt;_EntryList &nbsp; &nbsp; &nbsp; &nbsp; = NULL ;<br><br><span>&nbsp; &nbsp;&nbsp;</span><span>&nbsp;&nbsp;&nbsp;&nbsp;</span><span>&nbsp;&nbsp;&nbsp;&nbsp;</span><span>&nbsp;&nbsp;&nbsp;&nbsp;</span><span>&nbsp;&nbsp;&nbsp;&nbsp;</span><span>&nbsp;&nbsp;&nbsp;&nbsp;</span><span>&nbsp;&nbsp;&nbsp;&nbsp;</span><span>&nbsp; &nbsp;&nbsp;</span>&nbsp; m-&gt;_OnDeck &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= NULL ;<br><br><span>&nbsp; &nbsp;&nbsp;</span><span>&nbsp;&nbsp;&nbsp;&nbsp;</span><span>&nbsp;&nbsp;&nbsp;&nbsp;</span><span>&nbsp;&nbsp;&nbsp;&nbsp;</span><span>&nbsp;&nbsp;&nbsp;&nbsp;</span><span>&nbsp;&nbsp;&nbsp;&nbsp;</span><span>&nbsp;&nbsp;&nbsp;&nbsp;</span><span>&nbsp; &nbsp;&nbsp;</span>&nbsp; m-&gt;_WaitSet &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; = NULL ;<br><br><span>&nbsp; &nbsp;&nbsp;</span><span>&nbsp;&nbsp;&nbsp;&nbsp;</span><span>&nbsp;&nbsp;&nbsp;&nbsp;</span><span>&nbsp;&nbsp;&nbsp;&nbsp;</span><span>&nbsp;&nbsp;&nbsp;&nbsp;</span><span>&nbsp;&nbsp;&nbsp;&nbsp;</span><span>&nbsp;&nbsp;&nbsp;&nbsp;</span><span>&nbsp; &nbsp;&nbsp;</span>&nbsp; m-&gt;_WaitLock[0] &nbsp; &nbsp; &nbsp; = 0 ;<br><br><span>&nbsp; &nbsp;&nbsp;</span><span>&nbsp;&nbsp;&nbsp;&nbsp;</span><span>&nbsp;&nbsp;&nbsp;&nbsp;</span><span>&nbsp;&nbsp;&nbsp;&nbsp;</span><span>&nbsp;&nbsp;&nbsp;&nbsp;</span><span>&nbsp;&nbsp;&nbsp;&nbsp;</span><span>&nbsp;&nbsp;&nbsp;&nbsp;</span><span>&nbsp; &nbsp;&nbsp;</span>}<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp; 可看到锁的初始值是<span>m-&gt;_LockWord.FullWord = 0 ;</span></em></span><br></p><br><p><br>    <span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp; 此处需要注意:Monitor中的lockWord为SplitWord</span><br></p><br><p><br>    <span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;union SplitWord { &nbsp; // full-word with separately addressable LSB<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; volatile intptr_t FullWord ;<br><br>&nbsp; <span>&nbsp;&nbsp;</span><span>&nbsp;&nbsp;&nbsp;&nbsp;</span><span>&nbsp;&nbsp;&nbsp;&nbsp;</span><span>&nbsp;&nbsp;&nbsp;&nbsp;</span><span>&nbsp;&nbsp;&nbsp;&nbsp;</span><span>&nbsp;&nbsp;&nbsp;&nbsp;</span><span>&nbsp;&nbsp;&nbsp;&nbsp;</span><span>&nbsp;&nbsp;&nbsp;&nbsp;</span><span>&nbsp;&nbsp;&nbsp;&nbsp;</span><span>&nbsp;&nbsp;&nbsp;&nbsp;</span><span>&nbsp;&nbsp;</span>volatile void  Address ;<br><br>&nbsp; <span>&nbsp;&nbsp;</span><span>&nbsp;&nbsp;&nbsp;&nbsp;</span><span>&nbsp;&nbsp;&nbsp;&nbsp;</span><span>&nbsp;&nbsp;&nbsp;&nbsp;</span><span>&nbsp;&nbsp;&nbsp;&nbsp;</span><span>&nbsp;&nbsp;&nbsp;&nbsp;</span><span>&nbsp;&nbsp;&nbsp;&nbsp;</span><span>&nbsp;&nbsp;&nbsp;&nbsp;</span><span>&nbsp;&nbsp;&nbsp;&nbsp;</span><span>&nbsp;&nbsp;&nbsp;&nbsp;</span><span>&nbsp;&nbsp;</span>volatile jbyte Bytes [sizeof(intptr_t)] ;<br><br><span>&nbsp;&nbsp;</span><span>&nbsp;&nbsp;&nbsp;&nbsp;</span><span>&nbsp;&nbsp;&nbsp;&nbsp;</span><span>&nbsp;&nbsp;&nbsp;&nbsp;</span><span>&nbsp;&nbsp;&nbsp;&nbsp;</span><span>&nbsp;&nbsp;&nbsp;&nbsp;</span><span>&nbsp;&nbsp;&nbsp;&nbsp;</span><span>&nbsp;&nbsp;&nbsp;&nbsp;</span><span>&nbsp;&nbsp;&nbsp;&nbsp;</span><span>&nbsp;&nbsp;</span>}</span><br></p><br><p><br>    <span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp; 因此，lockWord初始值为0</span><br></p><br><p><br>    <span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp; 而ILock中代码如下intptr_t v = CASPTR (&amp;_LockWord, 0, _LBIT) ;</span><br></p><br><p><br>    <span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp; 锁定后<span>_LockWord = 1,解锁后<span>_LockWord = 0;</span></span></span><br></p><br><p><br>    <span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp; 初始值为未锁定0<br><br></span><br></p><br><p><br>    <span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp; vmthread-&gt;set_osthread(osthread);<br><br></span><br></p><br><p><br>    <span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;pthread_t tid;</span><br></p><br><p><br>    <span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int ret = pthread_create(&amp;tid, &amp;attr, (void<em> (</em>)(void<em>)) java_start, thread);</em></span><br></p><br><p><br>    <span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;osthread-&gt;set_pthread_id(tid);</span><br></p><br><p><br>    <span>&nbsp; &nbsp; &nbsp; &nbsp; 在java_start函数中<br><br></span><br></p><br><p><br>    <span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;while (osthread-&gt;get_state() == INITIALIZED) {</span><br></p><br><p><br>    <span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;sync-&gt;wait(Mutex::_no_safepoint_check_flag);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp; 开始等待<br><br></span><br></p><br><p><br>    <span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp; 等待函数的写法如下：<br><br></span><br></p><br><p><br>    <span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Thread  const Self = Thread::current() ;</span><br></p><br><p><br>    <span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;set_owner(NULL);</span><br></p><br><p><br>    <span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;wait_status = IWait (Self, timeout) ;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp; 开始等待–&gt;内部实现细节需要研究<br><br></span><br></p><br><p><br>    <span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;set_owner (Self) ;<br><br></span><br></p><br><p><br>    <span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp; }<br><br></span><br></p><br><p><br>    <span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;thread-&gt;run();&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp; 开始调用thread-&gt;run函数</span><br></p><br><p><br>    <span>&nbsp;&nbsp;&nbsp;&nbsp;os::start_thread(vmthread);&nbsp;&nbsp;&nbsp;&nbsp;</span><br></p><br><p><br>    <span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp; 调用:&nbsp;&nbsp;&nbsp;&nbsp;pd_start_thread(thread);<br><br></span><br></p><br><p><br>    <span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;调用:&nbsp;&nbsp;&nbsp;&nbsp;Monitor* sync_with_child = osthread-&gt;startThread_lock();</span><br></p><br><p><br>    <span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp; 调用:&nbsp;&nbsp;&nbsp;&nbsp;MutexLockerEx ml(sync_with_child, Mutex::_no_safepoint_check_flag);</span><br></p><br><p><br>    <span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp; 调用:&nbsp;&nbsp;&nbsp;&nbsp;sync_with_child-&gt;notify();&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp; 通知<span>java_start继续</span>运行<br><br></span><br></p><br><p><br>    <span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp; 调用:&nbsp;&nbsp;&nbsp;&nbsp;thread-&gt;run()<br><br></span><br></p><br><p><br>    <span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp; 调用:&nbsp;&nbsp;&nbsp;&nbsp;this-&gt;loop();&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br><br></span><br></p><br><p><br>    <span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp; 代码:&nbsp; &nbsp; while(true)<br><br></span><br></p><br><p><br>    <span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp; 代码:&nbsp;&nbsp;&nbsp;&nbsp;_cur_vm_operation = _vm_queue-&gt;remove_next();</span><br></p><br><p><br>    <span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp; 代码:&nbsp;&nbsp;&nbsp;&nbsp;evaluate_operation(_cur_vm_operation);<br><br></span><br></p><br><p><br>    <span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;代码:&nbsp;&nbsp;&nbsp;&nbsp;<span>_cur_vm_operation</span>-&gt;evaluate();<br><br></span><br></p><br><p><br>    <span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp; 代码:&nbsp;&nbsp;&nbsp;&nbsp;<span>_cur_vm_operation-&gt;doit();</span></span><br></p><br><p><br>    <span><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp; 在最终的doit()函数中，即执行的是VM_Operation</span>的操作。<br><br></span><br></p><br><p><br>    <span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp; 例如：<br><br></span><br></p><br><p><br>    <span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;void VM_PrintThreads::doit() {<br><br><span>&nbsp; &nbsp;&nbsp;</span><span>&nbsp;&nbsp;&nbsp;&nbsp;</span><span>&nbsp;&nbsp;&nbsp;&nbsp;</span><span>&nbsp;&nbsp;&nbsp;&nbsp;</span><span>&nbsp; &nbsp;&nbsp;</span>&nbsp; Threads::print_on(_out, true, false, _print_concurrent_locks);<br><br><span>&nbsp; &nbsp;&nbsp;</span><span>&nbsp;&nbsp;&nbsp;&nbsp;</span><span>&nbsp;&nbsp;&nbsp;&nbsp;</span><span>&nbsp;&nbsp;&nbsp;&nbsp;</span><span>&nbsp; &nbsp;&nbsp;</span>}</span><br></p><br><p><br>    <span>&nbsp; &nbsp; 这个就是VMThread的执行步骤，以及最终调用函数的过程。<br><br><br><br></span><br></p><br><p><br>    <span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br><br></span><br></p><br><p><br>    <span><br><br></span><br></p><br><p><br>    <span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br><br></span><br></p><br><p><br>    <span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br><br></span><br></p><br><p><br>    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br></p><br><p><br>    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br></p><br><p><br>    <br><br></p><br><p><br>    <br><br></p><br><p><br>    <span><br><br></span><br></p><br><p><br>    <span><br><br></span><br></p></div><script type="text/javascript" src="/js/share.js?v=0.0.0" async></script><a data-url="https://kanmars.github.io/2016/02/29/2016-02-29-JVM_THREAD_TYPEANDRUN/" data-id="ciwjetzfz002248vq6x04c2dt" class="article-share-link">공유하기</a><div class="tags"><a href="/tags/server/">server</a><a href="/tags/java/">java</a></div><div class="post-nav"><a href="/2016/03/03/2016-03-03-JVM_MAINTHREAD_START/" class="pre">[KANMARS原创] - (六) 从JVM源码来理解JavaThread类启动过程与main方法调用</a><a href="/2016/02/28/2016-02-28-JVM_GC_THREAD_CREATE/" class="next">[KANMARS原创] - (四) 从JVM源码来理解GC线程是如何创建启动触发任务的</a></div><div data-thread-key="2016/02/29/2016-02-29-JVM_THREAD_TYPEANDRUN/" data-title="[KANMARS原创] - (五) 从JVM源码来理解JVM中的线程种类与启动方式" data-url="https://kanmars.github.io/2016/02/29/2016-02-29-JVM_THREAD_TYPEANDRUN/" class="ds-share flat"><div class="ds-share-inline"><ul class="ds-share-icons-16"><li data-toggle="ds-share-icons-more"><a href="javascript:void(0);" class="ds-more">分享到：</a></li><li><a href="javascript:void(0);" data-service="weibo" class="ds-weibo">微博</a></li><li><a href="javascript:void(0);" data-service="qzone" class="ds-qzone">QQ空间</a></li><li><a href="javascript:void(0);" data-service="qqt" class="ds-qqt">腾讯微博</a></li><li><a href="javascript:void(0);" data-service="wechat" class="ds-wechat">微信</a></li></ul><div class="ds-share-icons-more"></div></div></div><div data-thread-key="2016/02/29/2016-02-29-JVM_THREAD_TYPEANDRUN/" data-title="[KANMARS原创] - (五) 从JVM源码来理解JVM中的线程种类与启动方式" data-url="https://kanmars.github.io/2016/02/29/2016-02-29-JVM_THREAD_TYPEANDRUN/" data-author-key="1" class="ds-thread"></div></div></div></div><div class="pure-u-1-4 hidden_mid_and_down"><div id="sidebar"><div class="widget"><form action="//www.baidu.com/baidu" method="get" accept-charset="utf-8" target="_blank" class="search-form"><input type="search" name="word" maxlength="20" placeholder="Search"/><input type="hidden" name="si" value="https://kanmars.github.io"/><input name="tn" type="hidden" value="bds"/><input name="cl" type="hidden" value="3"/><input name="ct" type="hidden" value="2097152"/><input name="s" type="hidden" value="on"/></form></div><div class="widget"><div class="widget-title"><i class="fa fa-folder-o"> 카테고리</i></div></div><div class="widget"><div class="widget-title"><i class="fa fa-star-o"> 태그</i></div><div class="tagcloud"><a href="/tags/jetty/" style="font-size: 15px;">jetty</a> <a href="/tags/it/" style="font-size: 15px;">it</a> <a href="/tags/architecture/" style="font-size: 15px;">architecture</a> <a href="/tags/itlife/" style="font-size: 15px;">itlife</a> <a href="/tags/rsa/" style="font-size: 15px;">rsa</a> <a href="/tags/tb/" style="font-size: 15px;">tb</a> <a href="/tags/drawline/" style="font-size: 15px;">drawline</a> <a href="/tags/life/" style="font-size: 15px;">life</a> <a href="/tags/strategy/" style="font-size: 15px;">strategy</a> <a href="/tags/tblife/" style="font-size: 15px;">tblife</a> <a href="/tags/java/" style="font-size: 15px;">java</a> <a href="/tags/linux/" style="font-size: 15px;">linux</a> <a href="/tags/spring/" style="font-size: 15px;">spring</a> <a href="/tags/server/" style="font-size: 15px;">server</a> <a href="/tags/c/" style="font-size: 15px;">c</a> <a href="/tags/c/" style="font-size: 15px;">c++</a> <a href="/tags/lua/" style="font-size: 15px;">lua</a> <a href="/tags/android/" style="font-size: 15px;">android</a> <a href="/tags/javascript/" style="font-size: 15px;">javascript</a> <a href="/tags/neuralnetwork/" style="font-size: 15px;">neuralnetwork</a> <a href="/tags/cpu/" style="font-size: 15px;">cpu</a> <a href="/tags/disk/" style="font-size: 15px;">disk</a> <a href="/tags/fidsk/" style="font-size: 15px;">fidsk</a> <a href="/tags/fstab/" style="font-size: 15px;">fstab</a> <a href="/tags/lvm/" style="font-size: 15px;">lvm</a> <a href="/tags/aix/" style="font-size: 15px;">aix</a></div></div><div class="widget"><div class="widget-title"><i class="fa fa-file-o"> 과거</i></div><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/2017/07/29/2017-07-29-half-year/">[KANMARS原创]-最近半年我的毁灭性经历</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/01/06/2017-01-06-springcloud_use_002_ssc_configserver/">[KANMARS原创]-SpringCloud-实用篇(2)-configserver</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/12/11/2016-12-11-springcloud_use_001_whatissc/">[KANMARS原创]-SpringCloud-实用篇(1)-什么是springCLoud</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/11/18/2016-11-18-springmvc_source_004_viewresolver/">[KANMARS原创]-SpringMVC源码解析(4) - 视图处理器</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/11/18/2016-11-18-springmvc_source_003_requestprocess/">[KANMARS原创]-SpringMVC源码解析(3) - 请求处理过程</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/11/17/2016-11-17-springmvc_source_002_start/">[KANMARS原创]-SpringMVC源码解析(2) - 启动过程</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/11/17/2016-11-17-springmvc_source_001_introduce/">[KANMARS原创]-SpringMVC源码解析(1) - 简介</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/11/04/2016-11-04-SomeThingAndNothing/">SomeThingAndNothing</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/10/25/2016-10-25-news-LongRoad/">news It's a Long Road</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/10/19/2016-10-19-Scale-Services/">On Designing and Deploying Internet-Scale Services</a></li></ul></div><div class="widget"><div class="comments-title"><i class="fa fa-comment-o"> 최근 댓글</i></div><div data-num-items="5" data-show-avatars="0" data-show-time="1" data-show-admin="0" data-excerpt-length="32" data-show-title="1" class="ds-recent-comments"></div></div><div class="widget"><div class="widget-title"><i class="fa fa-external-link"> 블로그롤</i></div><ul></ul><a href="http://www.linux.cn" title="Linux-CN" target="_blank">Linux-CN</a><ul></ul><a href="http://www.gome.com.cn" title="国美互联网" target="_blank">国美互联网</a><ul></ul><a href="http://jr.gome.com.cn" title="国美金融" target="_blank">国美金融</a></div></div></div><div class="pure-u-1 pure-u-md-3-4"><div id="footer">© <a href="/." rel="nofollow">KANMARS的博客.</a> Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a><a rel="nofollow" target="_blank" href="https://github.com/tufu9441/maupassant-hexo"> Theme</a> by<a rel="nofollow" target="_blank" href="https://github.com/pagecho"> Cho.</a></div></div></div><a id="rocket" href="#top" class="show"></a><script type="text/javascript" src="/js/totop.js?v=0.0.0" async></script><script type="text/javascript" src="//cdn.bootcss.com/fancybox/2.1.5/jquery.fancybox.pack.js" async></script><script type="text/javascript" src="/js/fancybox.js?v=0.0.0" async></script><link rel="stylesheet" type="text/css" href="/css/jquery.fancybox.css?v=0.0.0"><script>var duoshuoQuery = {short_name:'kanmars'};
(function() {
    var ds = document.createElement('script');
    ds.type = 'text/javascript';ds.async = true;
    ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
    ds.charset = 'UTF-8';
    (document.getElementsByTagName('head')[0]
        || document.getElementsByTagName('body')[0]).appendChild(ds);
})();
</script><script type="text/javascript" src="/js/codeblock-resizer.js?v=0.0.0"></script><script type="text/javascript" src="/js/smartresize.js?v=0.0.0"></script></div></body></html>