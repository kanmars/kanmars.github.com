<!DOCTYPE html><html lang="null"><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description"><title>lua使用手册 | KANMARS的博客</title><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/normalize/5.0.0/normalize.min.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/pure/0.6.0/pure-min.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/pure/0.6.0/grids-responsive-min.css"><link rel="stylesheet" type="text/css" href="/css/style.css?v=0.0.0"><link rel="stylesheet" href="//cdn.bootcss.com/font-awesome/4.7.0/css/font-awesome.min.css"><script type="text/javascript" src="//cdn.bootcss.com/jquery/3.1.1/jquery.min.js"></script><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">lua使用手册</h1><a id="logo" href="/.">KANMARS的博客</a><p class="description">helloword 2046。趁着，我会喜怒你会哀乐，唱几分钟情歌。</p></div><div id="nav-menu"><a href="/." class="current"><i class="fa fa-home"> Start</i></a><a href="/archives/"><i class="fa fa-archive"> Archiv</i></a><a href="/2016/04/23/2016-04-23-mysongs/"><i class="fa fa-user"> Über</i></a></div></div><div id="layout" class="pure-g"><div class="pure-u-1 pure-u-md-3-4"><div class="content_container"><div class="post"><h1 class="post-title">lua使用手册</h1><div class="post-meta">Jan 4, 2015</div><a data-thread-key="2015/01/04/2015-01-04-lua/" href="/2015/01/04/2015-01-04-lua/#comments" class="ds-thread-count"></a><div class="post-content"><p>&lt;!DOCTYPE html PUBLIC “-//W3C//DTD XHTML 1.0 Transitional//EN”&gt;</p>
<html><head><br><title>Lua 5.2 参考手册</title><br><meta http-equiv="content-type" content="text/html; charset=UTF-8"><br><br><style type="text/css"><br>HTML {<br>    BACKGROUND-COLOR: #f8f8f8<br>}<br>BODY {<br>    BORDER-BOTTOM: #a0a0a0 1px solid; TEXT-ALIGN: justify; BORDER-LEFT: #a0a0a0 1px solid; PADDING-BOTTOM: 26px; BACKGROUND-COLOR: #ffffff; MARGIN: 16px; PADDING-LEFT: 26px; PADDING-RIGHT: 26px; FONT-FAMILY: Helvetica, Arial,  Microsoft YaHei; COLOR: #000000; BORDER-TOP: #a0a0a0 1px solid; BORDER-RIGHT: #a0a0a0 1px solid; PADDING-TOP: 26px; border-radius: 20px<br>}<br>H1 {<br>    FONT-STYLE: normal; FONT-FAMILY: Helvetica, Microsoft YaHei; FONT-WEIGHT: normal<br>}<br>H2 {<br>    FONT-STYLE: normal; FONT-FAMILY:  Helvetica, Microsoft YaHei, sans-serif; FONT-WEIGHT: normal<br>}<br>H3 {<br>    FONT-STYLE: normal; FONT-FAMILY: Helvetica, Microsoft YaHei, sans-serif; FONT-WEIGHT: normal<br>}<br>H4 {<br>    FONT-STYLE: normal; FONT-FAMILY: Helvetica, Microsoft YaHei, sans-serif;  FONT-WEIGHT: normal<br>}<br>H1 {<br>    FONT-STYLE: italic<br>}<br>H2 {<br>    BORDER-BOTTOM: #000080 1px solid; BORDER-LEFT: #000080 1px solid; PADDING-BOTTOM: 0.4em; BACKGROUND-COLOR: #e0e0ff; PADDING-LEFT: 0.8em; PADDING-RIGHT: 0.8em; BORDER-TOP: #000080 1px solid; BORDER-RIGHT: #000080 1px solid; PADDING-TOP: 0.4em; border-radius: 8px<br>}<br>H3 {<br>    BORDER-LEFT: #e0e0ff 1em solid; PADDING-LEFT: 0.5em<br>}<br>TABLE H3 {<br>    BORDER-LEFT: medium none; PADDING-LEFT: 0px<br>}<br>A:link {<br>    COLOR: #000080; TEXT-DECORATION: none<br>}<br>A:visited {<br>    TEXT-DECORATION: none<br>}<br>A:hover:link {<br>    BACKGROUND-COLOR: #e0e0ff; COLOR: #000080<br>}<br>A:hover:visited {<br>    BACKGROUND-COLOR: #e0e0ff; COLOR: #000080<br>}<br>A:active {<br>    COLOR: #ff0000<br>}<br>A:active {<br>    COLOR: #ff0000<br>}<br>HR {<br>    BORDER-BOTTOM: 0px; BORDER-LEFT: 0px; BACKGROUND-COLOR: #a0a0a0; DISPLAY: none; HEIGHT: 1px; COLOR: #a0a0a0; BORDER-TOP: 0px; BORDER-RIGHT: 0px<br>}<br>TABLE HR {<br>    DISPLAY: block<br>}<br>:unknown {<br>    BORDER-BOTTOM: #a0a0a0 2px solid; BORDER-LEFT: #a0a0a0 2px solid; PADDING-BOTTOM: 8px; BACKGROUND-COLOR: #f8f8f8; PADDING-LEFT: 8px; PADDING-RIGHT: 8px; BORDER-TOP: #a0a0a0 2px solid; BORDER-RIGHT: #a0a0a0 2px solid; PADDING-TOP: 8px<br>}<br>.footer {<br>    COLOR: gray; FONT-SIZE: x-small<br>}<br>INPUT[type=text] {<br>    BACKGROUND-IMAGE: url(images/search.png); BORDER-BOTTOM: #a0a0a0 2px solid; BORDER-LEFT: #a0a0a0 2px solid; PADDING-LEFT: 20px; BACKGROUND-REPEAT: no-repeat; BACKGROUND-POSITION: 4px center; HEIGHT: 2em; BORDER-TOP: #a0a0a0 2px solid; BORDER-RIGHT: #a0a0a0 2px solid; border-radius: 2em; -moz-border-radius: 2em<br>}<br><br><br><br>H1 {<br>    FONT-STYLE: normal<br>}<br>H3 CODE {<br>    FONT-FAMILY: inherit<br>}<br>PRE {<br>    FONT-SIZE: 12pt<br>}<br>CODE {<br>    FONT-SIZE: 12pt<br>}<br>SPAN.apii {<br>    FONT-STYLE: normal; FONT-FAMILY: inherit; FLOAT: right; COLOR: gray; FONT-SIZE: small<br>}<br>P + H1 {<br>    PADDING-BOTTOM: 0.4em; BACKGROUND-COLOR: #e0e0ff; PADDING-LEFT: 16px; MARGIN-LEFT: -16px; PADDING-TOP: 0.4em; border-radius: 8px<br>}<br>UL + H1 {<br>    PADDING-BOTTOM: 0.4em; BACKGROUND-COLOR: #e0e0ff; PADDING-LEFT: 16px; MARGIN-LEFT: -16px; PADDING-TOP: 0.4em; border-radius: 8px<br>}<br><br><br></style><br><br></head><br><br><body><br><br><hr><br><h1><br><a href="http://www.lua.org/home.html" target="_blank" rel="external"><img src="data:image/gif;base64,R0lGODdhgACAAPcAAAAAcgAAdgAAegAAfQcHfgkJf29vb3FxcXZ2dnp6en9/fwEBgAQEgQgIgwsLhA4Ogg8PhQ4OhhERhRYWhxERiBUVihkZihoajB0dix0djSEhjiUljyIikCUlkSkpkiwskzU1lzExlTU1mTExmDo6mjo6nD8/nUJCn0REnkJCoEVFoUpKo0hIpExMo01NpVBQp1RUplFRqFdXq1lZqlparFxcq15erWBgr2NjsWdnsWlps2pqs29vt2xstHFxt3Z2u3R0uXl5u3t7vX9/v35+vYKCgoWFhYiIiI6OjpCQkJWVlZubm52dnYCAv6GhoaWlpampqa2trbOzs7e3t7m5ub29vYODwYeHwomJw4uLxY6OxpCQx5KSyJWVypmZy5mZzJ+fz6Ghz6Ki0aWl0qmp06mp1K2t1q+v17Gx17Gx2LW12ru73by83cPDw8fHx8rKyszMzMDA39LS0tXV1djY2N3d3cHB4MfH48fH5MnJ5MrK5c7O5tDQ59PT6dXV6tjY69ra7N3d7uHh4eXl5eDg7+rq6u7u7uLi8Obm8+jo8+np9O7u9vHx8fDw9/X19fPz+ff3+/n5+fv7/f///wAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAACwAAAAAgACAAAAI/gAnCRxIsKDBgwgTKlzIsKHDhxAjSpxIsaLFixgzatzIsaPHjyBDihxJsqTJkyhTqlzJsqXLlzBjypxJE6Gkm5Nw1rQYiVGhOoYIGhrEKFJKSTsbGh1IR4FTBFMIRkFQpMiRQR4RmSFyQwYOK2oaCUSatKAjOlOSIFk6iREcQYUMsW37U04VRgMdMZlSZy7EPTIgCAhAmLCACjsClTXIBEESKXMuOpKCxCmViJB2DAgwYAGDz58XbG5wpawjgoKCcmTUBg5ERCMCeB7Qmbbozgw2v4A0MxKcI0xURnmTUJGHALlFK69d23OAFTLdGFEQBWvKKAmMuPE7qQXyBcvD/odnEMBHzpdQopxmyWgKgigFvSBvTv+2cuUC2CxOaUi1wEcaMBdec8vZJsAJKjkyhX87IRWGbAMOWF9td6BER1WF7DfJCwJEWJ+E5AlxHklSHBAFdzVFokGHHhYY4YEmOaKEHBfppNBNZE1ESAO0TSjehwJokGNZQw4kySOIHBLIIYg8UuRYEfVhG4E+fjhABY8QSZAkfpAhhAwkcFCBAw185kAFHJAggxBj+DHkkwj5MWGVHmIZUhWuSZTjIWDIEGBhAgjQ46CBDsZZBjKAcchrPE4JHp0CCtDBnQYQN9EiYKTQAGG2hQaei+CFNoChDKTwhSJGKtQBiwJC+qkA/tB9RMUBND5Elh87UBCAoJ525uKcyn02agAS6ODHjZPYMN99kNZGXmlwWkTHAZFF5IcMBHD2aI/bMithhI9yJkMfCqHBqn10LkcAuR5FYt1DiuSQ7QAMfNosuHPiNuoAOSCSUAjntiggeTC8RNYXEnBWr6PpAuvqZhB0ASVBZgiQHMMCF8AuS0gdooLCGD8ssIfObpaCYjkilcN8Di9HnhYdsYbiQUiZkfDCIufc4n2eCSBBGSOOtcJ33Po6cAA7eASFAus1JISg9o6sc5VFFy3ADwZJIoPCj6I7WwBYdwTHAXU4pDXRIUuttoCegVavfeTFwFtBXSTcqaiDZXCG/keFIHBZQ4+cQPTahNPna26GAjobbeSZIFaqiljRwWaAMiBCF1l6RIcTMxf0CAksFy56c4M5UEIORFzxgwwcbGY0eSIsQnMfY2RxhRZmKDbxSpCYsOzooosWQAdc+FuQJHrk0ECHuAVAQuap2vSSC8umPTXJohGQRco4EgRICkSTF2vWOEZ7ElI9DH59zp0JYAEeu2ct0A+yMR6ADiwZUvZCSIER+vqEE80EjmW+LU2CCPVzjsQK+JEoHKEhe+BR1ABItW0NYA1BYwhSZgCh7OmhIYLIE0YMkQARJkQSIGAe8ER2n/Jk0CGKsADpQjA3hbwBAQyqiBQeiCwEXmyF/tijUgVQpadJaKF+9ApAEBpyBClgJBIKaAND9kCAQQHRRwMij3kYWJwKGG0BBPjgQtzANIwIomkJWcG5KBhE+wjADhXZ4O8EoAKGOKIIJgyJubzGRisxqwKPmwhSuhC6BQgAaAuRS0lIwKIrCoxAhhSBRZDCBub5SgAgkEnFHOkqF8EKI1KyV/vI8MKNREIOaEQICizJyTa2b3wVCaVtwCMAE4hEEAh4F0L00KpW+tFAkozjJOygwlkKoEILeUOGJEIFHiokfQvrWh+/RZ8LQK+I/vthEnNQSoIU4W8RUQJ8FPIIDBjOlz9C1wCQWRFl5YZKFpCdQqSgBIk4AgG1/kpIGiz5xWme83VK7CbgzDnB9plhIXIoI0R8gxfprSw5fEQnqAaQAXlGBClfgBDDyHMDgbYFAXTwiCQ8UExpYnF9PgpAEzyakEdsoKS+MmQHGDiHhnJESgyjEjWDZ6UwsvR4k9BBAv85gD0cZRJgWKNJ8TU6PwZpUVw8DxdgyizyeOGnHEGKULWp03/y9FeG3AAg4gdUI1KVOdvE6kMMgYQcGsQErDSa4Xo5ta7iRwJi2FL5BqKIGTTypIYkAUM6dxA6JMCmB4FEBmLKNkNeARF/0AMEivZV6wWgBGaoIUECQYSE3aaCorGAZg3iCCSE1CFwMAJhD9EoRwUrAGAQ/sgiKNDPwtl1lgwIlAViQIQvgGELPSgBeVjYIwboLiFFsFRDquDMXXLrV+SJ7SRmy0awytVohQEUvdZGOnYiBAlVeEgbgqOQNSi1OdGVLW2lKTXA0jVUbnvb9QyphoU8ZqEnnEQZhppF2Kp3vi2rLVr7SJ68mg8K4KzRJB4UTcOld7rrDWBEeTZBF8VXvmojzxfUihGMVq+/0qWubUM24LQZMruGsaDAyLPAknj4nRF6sIjXBgEKUKC1A4qAjd8ZqQF84AZW2AIXmmCDVZ11PAFocUaGkl8xfJg+Ml5vJwWABt7Qr8G30UOWaKA+AbhAjMezgwiO7Cz/RrUhUUjC/kI2Sc0oC/hF+jngk0XzB4Hc4Du0xAJDXPDXbwUAaOarwzIbQgU1KyQOVH1tiKX8SEPG2YcROlaylhUAG5xHEmoYAg+A0AWUTeIQkx2ZADCoECQ40SFtaO5BcNpm/0L4vfXJj0Agbbg6T+LOPDbqdH2X3QFw4TwxQCLJdJ0QJEgRtQkgrCJC7Vr7LZqFspazNulsZ6JxgCw6AEB8B1AA3QlhzkaDgPEQEgkj5FEhhZACYSexqoKKxs3s9VG0aV2gsd76OwIQASQWkYgAfZZe81ZfeARwbYUYAgH72wifvabo/6rN0bMGt61xzTgbS2CWbVtAAOAobWDRcSEKQqyC/r8N4y/CW20Bx3JnJl694tImcXQkC72hDDYOZwQp+2z1sx+e8gnZG9ddO/GVRvACHnDBDkhBig+xKICDqoS1lL3NyV2VcgmxHMaCYoEY+mBRAw5B4EZrwHE3MogTLQSuS03izqf8aIkLBAd4DpJ3B7KIPViBDxGfdvsE6xFBHECXQG3Chxv+6ojGuu1YFo293RlaTy/CDD94wQi8CADEgyig5iuEE0TeEO0sZA85fberRcx2gQieqw1Y1L3rleRJGGULEjAU1AYQ56/rXTR5GKMC1n0QJ5BXISmE7ugZXSC0QnwSpx+QBuZGcbELRAwAwM2njj9z/ISAIb6fyBuM/oCsI0aT8DOevvhfFefTozcAMzgPrglOFj7jzEC57ziS9Wy+SBTBDRNxhFsNgoiLt0rGsTcoAmhF0TYGLHNJ+oEU6zcpAqFGMOYcmYQUVnCAn/UAhLAQg2AEg/YRWyVXMsYBNWZjIjiCFAABtOR0LtVBAwAAYaOA8yEBRNQFAEAA2xIAHuBpCOQAX6RxHWVHI9EHVVQ06YUUi1CERniERRgJdpBE5mEUfiAC+1IBvwYJugN0ApAG5/EDPCIoFxAE8oQUBhhXtEFsLeGCGJZbsXVmsiQBUCUQfrAGd5A5V0AEAsF4AsB3SJEIdsAGe5A5dwBokxAHVvA24BEANVAS/oWgXAnxB40idWbmEKyWb0RkEDKoZ6vXPjYQLWMwACiwWTy2AA2wMSIxBwewgfITBE/2ASpwAinQiq74iq6oAlCIHxaQBYDAG5KACGqgAoLSASqgAjLUNQLwAYoCCZIACYQwBiUgKANABJnDBp9CHmGDblPAewyBBONETi8lSoXSjd74jQyDHBngAR0gGKwSKBgzGA2gAR/AAZtiMbQkAR+gAVinAV2HEFJQBBnxBofFEDnnWtEYKgIpfsb3TujYLaL0I4VyXaKBjr4SAE6nEIygAIpoEUdwbAvRgV4FQBVGWb00fR9iL+TBTQwhBaqlEYrEEJAAMOxVfE1lPelk/kUk0z4fcE0JkQQYiRJ+8ABy1Uq25S0mJhoPQC5cFAnW2BE4N3u+pDNgJTCHZHMrMUho85PV1TKf9TJQ6RFLgH/8MwlXMJXEdUXu1SkqhVUpKSsJsH9ANYEY9jDT1EahEgB0yEUTmU8fkQRL0BBIoQVQE0B95F4NmQVqtQRIMBJ9k5P5VQYEYDEwCWuV5ZK5RQBjoFZVkEskQQeAl196oAFgx1QUhEXOkQEVElUTyZU0QYTB1pMBBjwSUhsB4AKocmaTUAhHyRIIo4KeuUL1wXoQsGEaIhBnZDaTgAgyECgIuZpheUkCEANt+JtG4AS2IhBxsIwdwmO/9JP1Eigi/hBnEEEFmXkSg4AAUDARaUCd22VFU9KYjpIbu4JZExEFf+cSgpAATwAROWIHNAABuyJ9HdkieBMAEEADHCcRUIAAggATdXBqFKEIYKACgrGfuBEa9TKhojIsAgABKvAF4yYR7nGgv9mVAqEIZgAEJeBFibMrgZJdgkIBJQAEZjCJslkQhfCdH0ozntMHZqAFP4ADMeACLMACL3ADP4A7fVhWNfoQUYCYFyVIMVoQNEoTbXAAT1CbN6ITZNE9T/QECsB5OyEI05FwZXEhRgCm+xEJUFAtZYFLZnekv+kubHoQcGCaLREJavmmA9EGCGAEb0ClpgQHRVBPdiqRUpAAeoaGElVQBAogBXUaqAPBCKeFElNABanEqA4hBUngBk8qEYVQBeFFqRhBB09gBAlwBFz6EJEQqgpQBArqqRgxCHs6EIOABEwQBVOAppNQB1VABVGwBB7qelLQBpnKqiM0BVDABEeQYIeKl04QrMLarM76rNAardLqEQEBADs=%0A" alt="官网" border="0"></a><br><br><br>Lua 5.2 参考手册</h1><br><br>by Roberto Ierusalimschy, Luiz Henrique de Figueiredo, Waldemar Celes<br><p><br><small><br>Copyright © 2011–2013 Lua.org, PUC-Rio.<br>Freely available under the terms of the<br><a href="http://www.lua.org/license.html" target="_blank" rel="external">Lua license</a>.<br></small><br></p><hr><br><p><br>keyring (译)   keyrings@163.com<br><!-- ====================================================================== --><br></p><p><br><br><!-- $Id: manual.of,v 1.103 2013/03/14 18:51:56 roberto Exp $ --><br><br></p><p><br><a href="#1">开始</a><br>·<br><a href="#contents">目录</a><br>·<br><a href="#index">索引</a><br>·<br><a href="http://www.photoneray.com/Lua-5.2-Reference-Manual-ZH_CN/ManualEN.htm" target="_blank" rel="external">英文版</a><br>·<br><a href="https://github.com/keyring/Lua-5.2-Reference-Manual-ZH_CN/tree/gh-pages" target="_blank" rel="external">Github</a><br></p><hr><br><br><h2><a name="contents">目录</a></h2><br><ul style="padding: 0"><br><li><a href="#1">1 – 简介</a><br><p><br></p></li><li><a href="#2">2 – 基本概念</a><br><ul><br><li><a href="#2.1">2.1 – 值与类型</a><br></li><li><a href="#2.2">2.2 – 环境与全局变量</a><br></li><li><a href="#2.3">2.3 – 错误处理</a><br></li><li><a href="#2.4">2.4 – 元表与元方法</a><br></li><li><a href="#2.5">2.5 – 垃圾回收</a><br><ul><br><li><a href="#2.5.1">2.5.1 – 垃圾回收元方法</a><br></li><li><a href="#2.5.2">2.5.2 – 弱表</a><br></li></ul><br></li><li><a href="#2.6">2.6 – 协程</a><br></li></ul><br><p><br></p></li><li><a href="#3">3 – 语言</a><br><ul><br><li><a href="#3.1">3.1 – 词法约定</a><br></li><li><a href="#3.2">3.2 – 变量</a><br></li><li><a href="#3.3">3.3 – 语句</a><br><ul><br><li><a href="#3.3.1">3.3.1 – 语句块</a><br></li><li><a href="#3.3.2">3.3.2 – 程序块</a><br></li><li><a href="#3.3.3">3.3.3 – 赋值</a><br></li><li><a href="#3.3.4">3.3.4 – 控制结构</a><br></li><li><a href="#3.3.5">3.3.5 – For 语句</a><br></li><li><a href="#3.3.6">3.3.6 – 函数调用作语句</a><br></li><li><a href="#3.3.7">3.3.7 – 局部声明</a><br></li></ul><br></li><li><a href="#3.4">3.4 – 表达式</a><br><ul><br><li><a href="#3.4.1">3.4.1 – 数学运算符</a><br></li><li><a href="#3.4.2">3.4.2 – 强制转换</a><br></li><li><a href="#3.4.3">3.4.3 – 关系运算符</a><br></li><li><a href="#3.4.4">3.4.4 – 逻辑运算符</a><br></li><li><a href="#3.4.5">3.4.5 – 连接操作</a><br></li><li><a href="#3.4.6">3.4.6 – 取长度运算符</a><br></li><li><a href="#3.4.7">3.4.7 – 优先级</a><br></li><li><a href="#3.4.8">3.4.8 – 表的构造器</a><br></li><li><a href="#3.4.9">3.4.9 – 函数调用</a><br></li><li><a href="#3.4.10">3.4.10 – 函数定义</a><br></li></ul><br></li><li><a href="#3.5">3.5 – 可见性规则</a><br></li></ul><br><p><br></p></li><li><a href="#4">4 – 应用程序接口</a><br><ul><br><li><a href="#4.1">4.1 – 栈</a><br></li><li><a href="#4.2">4.2 – 栈的大小</a><br></li><li><a href="#4.3">4.3 – 有效索引与合法索引</a><br></li><li><a href="#4.4">4.4 – C 闭包</a><br></li><li><a href="#4.5">4.5 – 注册表</a><br></li><li><a href="#4.6">4.6 – C 中的错误处理</a><br></li><li><a href="#4.7">4.7 – C 中的挂起处理</a><br></li><li><a href="#4.8">4.8 – 函数与类型</a><br></li><li><a href="#4.9">4.9 – 调试接口</a><br></li></ul><br><p><br></p></li><li><a href="#5">5 – The Auxiliary Library</a><br><ul><br><li><a href="#5.1">5.1 – Functions and Types</a><br></li></ul><br><p><br></p></li><li><a href="#6">6 – Standard Libraries</a><br><ul><br><li><a href="#6.1">6.1 – Basic Functions</a><br></li><li><a href="#6.2">6.2 – Coroutine Manipulation</a><br></li><li><a href="#6.3">6.3 – Modules</a><br></li><li><a href="#6.4">6.4 – String Manipulation</a><br><ul><br><li><a href="#6.4.1">6.4.1 – Patterns</a><br></li></ul><br></li><li><a href="#6.5">6.5 – Table Manipulation</a><br></li><li><a href="#6.6">6.6 – Mathematical Functions</a><br></li><li><a href="#6.7">6.7 – Bitwise Operations</a><br></li><li><a href="#6.8">6.8 – Input and Output Facilities</a><br></li><li><a href="#6.9">6.9 – Operating System Facilities</a><br></li><li><a href="#6.10">6.10 – The Debug Library</a><br></li></ul><br><p><br></p></li><li><a href="#7">7 – Lua Standalone</a><br><p><br></p></li><li><a href="#8">8 – Incompatibilities with the Previous Version</a><br><ul><br><li><a href="#8.1">8.1 – Changes in the Language</a><br></li><li><a href="#8.2">8.2 – Changes in the Libraries</a><br></li><li><a href="#8.3">8.3 – Changes in the API</a><br></li></ul><br><p><br></p></li><li><a href="#9">9 – The Complete Syntax of Lua</a><br></li></ul><br><br><h2><a name="index">索引</a></h2><br><table width="100%"><br><tbody><tr valign="top"><br><td><br><h3><a name="functions">Lua functions</a></h3><br><p><br><a href="#pdf-_G">_G</a><br><br><a href="#pdf-_VERSION">_VERSION</a><br><br><br></p><p><br><a href="#pdf-assert">assert</a><br><br><a href="#pdf-collectgarbage">collectgarbage</a><br><br><a href="#pdf-dofile">dofile</a><br><br><a href="#pdf-error">error</a><br><br><a href="#pdf-getmetatable">getmetatable</a><br><br><a href="#pdf-ipairs">ipairs</a><br><br><a href="#pdf-load">load</a><br><br><a href="#pdf-loadfile">loadfile</a><br><br><a href="#pdf-next">next</a><br><br><a href="#pdf-pairs">pairs</a><br><br><a href="#pdf-pcall">pcall</a><br><br><a href="#pdf-print">print</a><br><br><a href="#pdf-rawequal">rawequal</a><br><br><a href="#pdf-rawget">rawget</a><br><br><a href="#pdf-rawlen">rawlen</a><br><br><a href="#pdf-rawset">rawset</a><br><br><a href="#pdf-require">require</a><br><br><a href="#pdf-select">select</a><br><br><a href="#pdf-setmetatable">setmetatable</a><br><br><a href="#pdf-tonumber">tonumber</a><br><br><a href="#pdf-tostring">tostring</a><br><br><a href="#pdf-type">type</a><br><br><a href="#pdf-xpcall">xpcall</a><br><br><br></p><p><br><a href="#pdf-bit32.arshift">bit32.arshift</a><br><br><a href="#pdf-bit32.band">bit32.band</a><br><br><a href="#pdf-bit32.bnot">bit32.bnot</a><br><br><a href="#pdf-bit32.bor">bit32.bor</a><br><br><a href="#pdf-bit32.btest">bit32.btest</a><br><br><a href="#pdf-bit32.bxor">bit32.bxor</a><br><br><a href="#pdf-bit32.extract">bit32.extract</a><br><br><a href="#pdf-bit32.lrotate">bit32.lrotate</a><br><br><a href="#pdf-bit32.lshift">bit32.lshift</a><br><br><a href="#pdf-bit32.replace">bit32.replace</a><br><br><a href="#pdf-bit32.rrotate">bit32.rrotate</a><br><br><a href="#pdf-bit32.rshift">bit32.rshift</a><br><br><br></p><p><br><a href="#pdf-coroutine.create">coroutine.create</a><br><br><a href="#pdf-coroutine.resume">coroutine.resume</a><br><br><a href="#pdf-coroutine.running">coroutine.running</a><br><br><a href="#pdf-coroutine.status">coroutine.status</a><br><br><a href="#pdf-coroutine.wrap">coroutine.wrap</a><br><br><a href="#pdf-coroutine.yield">coroutine.yield</a><br><br><br></p><p><br><a href="#pdf-debug.debug">debug.debug</a><br><br><a href="#pdf-debug.getuservalue">debug.getuservalue</a><br><br><a href="#pdf-debug.gethook">debug.gethook</a><br><br><a href="#pdf-debug.getinfo">debug.getinfo</a><br><br><a href="#pdf-debug.getlocal">debug.getlocal</a><br><br><a href="#pdf-debug.getmetatable">debug.getmetatable</a><br><br><a href="#pdf-debug.getregistry">debug.getregistry</a><br><br><a href="#pdf-debug.getupvalue">debug.getupvalue</a><br><br><a href="#pdf-debug.setuservalue">debug.setuservalue</a><br><br><a href="#pdf-debug.sethook">debug.sethook</a><br><br><a href="#pdf-debug.setlocal">debug.setlocal</a><br><br><a href="#pdf-debug.setmetatable">debug.setmetatable</a><br><br><a href="#pdf-debug.setupvalue">debug.setupvalue</a><br><br><a href="#pdf-debug.traceback">debug.traceback</a><br><br><a href="#pdf-debug.upvalueid">debug.upvalueid</a><br><br><a href="#pdf-debug.upvaluejoin">debug.upvaluejoin</a><br><br><br></p><p><br><a href="#pdf-file:close">file:close</a><br><br><a href="#pdf-file:flush">file:flush</a><br><br><a href="#pdf-file:lines">file:lines</a><br><br><a href="#pdf-file:read">file:read</a><br><br><a href="#pdf-file:seek">file:seek</a><br><br><a href="#pdf-file:setvbuf">file:setvbuf</a><br><br><a href="#pdf-file:write">file:write</a><br><br><br></p><p><br><a href="#pdf-io.close">io.close</a><br><br><a href="#pdf-io.flush">io.flush</a><br><br><a href="#pdf-io.input">io.input</a><br><br><a href="#pdf-io.lines">io.lines</a><br><br><a href="#pdf-io.open">io.open</a><br><br><a href="#pdf-io.output">io.output</a><br><br><a href="#pdf-io.popen">io.popen</a><br><br><a href="#pdf-io.read">io.read</a><br><br><a href="#pdf-io.stderr">io.stderr</a><br><br><a href="#pdf-io.stdin">io.stdin</a><br><br><a href="#pdf-io.stdout">io.stdout</a><br><br><a href="#pdf-io.tmpfile">io.tmpfile</a><br><br><a href="#pdf-io.type">io.type</a><br><br><a href="#pdf-io.write">io.write</a><br><br><br></p></td><br><td><br><h3>&nbsp;</h3><br><p><br><a href="#pdf-math.abs">math.abs</a><br><br><a href="#pdf-math.acos">math.acos</a><br><br><a href="#pdf-math.asin">math.asin</a><br><br><a href="#pdf-math.atan">math.atan</a><br><br><a href="#pdf-math.atan2">math.atan2</a><br><br><a href="#pdf-math.ceil">math.ceil</a><br><br><a href="#pdf-math.cos">math.cos</a><br><br><a href="#pdf-math.cosh">math.cosh</a><br><br><a href="#pdf-math.deg">math.deg</a><br><br><a href="#pdf-math.exp">math.exp</a><br><br><a href="#pdf-math.floor">math.floor</a><br><br><a href="#pdf-math.fmod">math.fmod</a><br><br><a href="#pdf-math.frexp">math.frexp</a><br><br><a href="#pdf-math.huge">math.huge</a><br><br><a href="#pdf-math.ldexp">math.ldexp</a><br><br><a href="#pdf-math.log">math.log</a><br><br><a href="#pdf-math.max">math.max</a><br><br><a href="#pdf-math.min">math.min</a><br><br><a href="#pdf-math.modf">math.modf</a><br><br><a href="#pdf-math.pi">math.pi</a><br><br><a href="#pdf-math.pow">math.pow</a><br><br><a href="#pdf-math.rad">math.rad</a><br><br><a href="#pdf-math.random">math.random</a><br><br><a href="#pdf-math.randomseed">math.randomseed</a><br><br><a href="#pdf-math.sin">math.sin</a><br><br><a href="#pdf-math.sinh">math.sinh</a><br><br><a href="#pdf-math.sqrt">math.sqrt</a><br><br><a href="#pdf-math.tan">math.tan</a><br><br><a href="#pdf-math.tanh">math.tanh</a><br><br><br></p><p><br><a href="#pdf-os.clock">os.clock</a><br><br><a href="#pdf-os.date">os.date</a><br><br><a href="#pdf-os.difftime">os.difftime</a><br><br><a href="#pdf-os.execute">os.execute</a><br><br><a href="#pdf-os.exit">os.exit</a><br><br><a href="#pdf-os.getenv">os.getenv</a><br><br><a href="#pdf-os.remove">os.remove</a><br><br><a href="#pdf-os.rename">os.rename</a><br><br><a href="#pdf-os.setlocale">os.setlocale</a><br><br><a href="#pdf-os.time">os.time</a><br><br><a href="#pdf-os.tmpname">os.tmpname</a><br><br><br></p><p><br><a href="#pdf-package.config">package.config</a><br><br><a href="#pdf-package.cpath">package.cpath</a><br><br><a href="#pdf-package.loaded">package.loaded</a><br><br><a href="#pdf-package.loadlib">package.loadlib</a><br><br><a href="#pdf-package.path">package.path</a><br><br><a href="#pdf-package.preload">package.preload</a><br><br><a href="#pdf-package.searchers">package.searchers</a><br><br><a href="#pdf-package.searchpath">package.searchpath</a><br><br><br></p><p><br><a href="#pdf-string.byte">string.byte</a><br><br><a href="#pdf-string.char">string.char</a><br><br><a href="#pdf-string.dump">string.dump</a><br><br><a href="#pdf-string.find">string.find</a><br><br><a href="#pdf-string.format">string.format</a><br><br><a href="#pdf-string.gmatch">string.gmatch</a><br><br><a href="#pdf-string.gsub">string.gsub</a><br><br><a href="#pdf-string.len">string.len</a><br><br><a href="#pdf-string.lower">string.lower</a><br><br><a href="#pdf-string.match">string.match</a><br><br><a href="#pdf-string.rep">string.rep</a><br><br><a href="#pdf-string.reverse">string.reverse</a><br><br><a href="#pdf-string.sub">string.sub</a><br><br><a href="#pdf-string.upper">string.upper</a><br><br><br></p><p><br><a href="#pdf-table.concat">table.concat</a><br><br><a href="#pdf-table.insert">table.insert</a><br><br><a href="#pdf-table.pack">table.pack</a><br><br><a href="#pdf-table.remove">table.remove</a><br><br><a href="#pdf-table.sort">table.sort</a><br><br><a href="#pdf-table.unpack">table.unpack</a><br><br><br></p></td><br><td><br><h3>C API</h3><br><p><br><a href="#lua_Alloc">lua_Alloc</a><br><br><a href="#lua_CFunction">lua_CFunction</a><br><br><a href="#lua_Debug">lua_Debug</a><br><br><a href="#lua_Hook">lua_Hook</a><br><br><a href="#lua_Integer">lua_Integer</a><br><br><a href="#lua_Number">lua_Number</a><br><br><a href="#lua_Reader">lua_Reader</a><br><br><a href="#lua_State">lua_State</a><br><br><a href="#lua_Unsigned">lua_Unsigned</a><br><br><a href="#lua_Writer">lua_Writer</a><br><br><br></p><p><br><a href="#lua_absindex">lua_absindex</a><br><br><a href="#lua_arith">lua_arith</a><br><br><a href="#lua_atpanic">lua_atpanic</a><br><br><a href="#lua_call">lua_call</a><br><br><a href="#lua_callk">lua_callk</a><br><br><a href="#lua_checkstack">lua_checkstack</a><br><br><a href="#lua_close">lua_close</a><br><br><a href="#lua_compare">lua_compare</a><br><br><a href="#lua_concat">lua_concat</a><br><br><a href="#lua_copy">lua_copy</a><br><br><a href="#lua_createtable">lua_createtable</a><br><br><a href="#lua_dump">lua_dump</a><br><br><a href="#lua_error">lua_error</a><br><br><a href="#lua_gc">lua_gc</a><br><br><a href="#lua_getallocf">lua_getallocf</a><br><br><a href="#lua_getctx">lua_getctx</a><br><br><a href="#lua_getfield">lua_getfield</a><br><br><a href="#lua_getglobal">lua_getglobal</a><br><br><a href="#lua_gethook">lua_gethook</a><br><br><a href="#lua_gethookcount">lua_gethookcount</a><br><br><a href="#lua_gethookmask">lua_gethookmask</a><br><br><a href="#lua_getinfo">lua_getinfo</a><br><br><a href="#lua_getlocal">lua_getlocal</a><br><br><a href="#lua_getmetatable">lua_getmetatable</a><br><br><a href="#lua_getstack">lua_getstack</a><br><br><a href="#lua_gettable">lua_gettable</a><br><br><a href="#lua_gettop">lua_gettop</a><br><br><a href="#lua_getupvalue">lua_getupvalue</a><br><br><a href="#lua_getuservalue">lua_getuservalue</a><br><br><a href="#lua_insert">lua_insert</a><br><br><a href="#lua_isboolean">lua_isboolean</a><br><br><a href="#lua_iscfunction">lua_iscfunction</a><br><br><a href="#lua_isfunction">lua_isfunction</a><br><br><a href="#lua_islightuserdata">lua_islightuserdata</a><br><br><a href="#lua_isnil">lua_isnil</a><br><br><a href="#lua_isnone">lua_isnone</a><br><br><a href="#lua_isnoneornil">lua_isnoneornil</a><br><br><a href="#lua_isnumber">lua_isnumber</a><br><br><a href="#lua_isstring">lua_isstring</a><br><br><a href="#lua_istable">lua_istable</a><br><br><a href="#lua_isthread">lua_isthread</a><br><br><a href="#lua_isuserdata">lua_isuserdata</a><br><br><a href="#lua_len">lua_len</a><br><br><a href="#lua_load">lua_load</a><br><br><a href="#lua_newstate">lua_newstate</a><br><br><a href="#lua_newtable">lua_newtable</a><br><br><a href="#lua_newthread">lua_newthread</a><br><br><a href="#lua_newuserdata">lua_newuserdata</a><br><br><a href="#lua_next">lua_next</a><br><br><a href="#lua_pcall">lua_pcall</a><br><br><a href="#lua_pcallk">lua_pcallk</a><br><br><a href="#lua_pop">lua_pop</a><br><br><a href="#lua_pushboolean">lua_pushboolean</a><br><br><a href="#lua_pushcclosure">lua_pushcclosure</a><br><br><a href="#lua_pushcfunction">lua_pushcfunction</a><br><br><a href="#lua_pushfstring">lua_pushfstring</a><br><br><a href="#lua_pushglobaltable">lua_pushglobaltable</a><br><br><a href="#lua_pushinteger">lua_pushinteger</a><br><br><a href="#lua_pushlightuserdata">lua_pushlightuserdata</a><br><br><a href="#lua_pushliteral">lua_pushliteral</a><br><br><a href="#lua_pushlstring">lua_pushlstring</a><br><br><a href="#lua_pushnil">lua_pushnil</a><br><br><a href="#lua_pushnumber">lua_pushnumber</a><br><br><a href="#lua_pushstring">lua_pushstring</a><br><br><a href="#lua_pushthread">lua_pushthread</a><br><br><a href="#lua_pushunsigned">lua_pushunsigned</a><br><br><a href="#lua_pushvalue">lua_pushvalue</a><br><br><a href="#lua_pushvfstring">lua_pushvfstring</a><br><br><a href="#lua_rawequal">lua_rawequal</a><br><br><a href="#lua_rawget">lua_rawget</a><br><br><a href="#lua_rawgeti">lua_rawgeti</a><br><br><a href="#lua_rawgetp">lua_rawgetp</a><br><br><a href="#lua_rawlen">lua_rawlen</a><br><br><a href="#lua_rawset">lua_rawset</a><br><br><a href="#lua_rawseti">lua_rawseti</a><br><br><a href="#lua_rawsetp">lua_rawsetp</a><br><br><a href="#lua_register">lua_register</a><br><br><a href="#lua_remove">lua_remove</a><br><br><a href="#lua_replace">lua_replace</a><br><br><a href="#lua_resume">lua_resume</a><br><br><a href="#lua_setallocf">lua_setallocf</a><br><br><a href="#lua_setfield">lua_setfield</a><br><br><a href="#lua_setglobal">lua_setglobal</a><br><br><a href="#lua_sethook">lua_sethook</a><br><br><a href="#lua_setlocal">lua_setlocal</a><br><br><a href="#lua_setmetatable">lua_setmetatable</a><br><br><a href="#lua_settable">lua_settable</a><br><br><a href="#lua_settop">lua_settop</a><br><br><a href="#lua_setupvalue">lua_setupvalue</a><br><br><a href="#lua_setuservalue">lua_setuservalue</a><br><br><a href="#lua_status">lua_status</a><br><br><a href="#lua_toboolean">lua_toboolean</a><br><br><a href="#lua_tocfunction">lua_tocfunction</a><br><br><a href="#lua_tointeger">lua_tointeger</a><br><br><a href="#lua_tointegerx">lua_tointegerx</a><br><br><a href="#lua_tolstring">lua_tolstring</a><br><br><a href="#lua_tonumber">lua_tonumber</a><br><br><a href="#lua_tonumberx">lua_tonumberx</a><br><br><a href="#lua_topointer">lua_topointer</a><br><br><a href="#lua_tostring">lua_tostring</a><br><br><a href="#lua_tothread">lua_tothread</a><br><br><a href="#lua_tounsigned">lua_tounsigned</a><br><br><a href="#lua_tounsignedx">lua_tounsignedx</a><br><br><a href="#lua_touserdata">lua_touserdata</a><br><br><a href="#lua_type">lua_type</a><br><br><a href="#lua_typename">lua_typename</a><br><br><a href="#lua_upvalueid">lua_upvalueid</a><br><br><a href="#lua_upvalueindex">lua_upvalueindex</a><br><br><a href="#lua_upvaluejoin">lua_upvaluejoin</a><br><br><a href="#lua_version">lua_version</a><br><br><a href="#lua_xmove">lua_xmove</a><br><br><a href="#lua_yield">lua_yield</a><br><br><a href="#lua_yieldk">lua_yieldk</a><br><br><br></p></td><br><td><br><h3>auxiliary library</h3><br><p><br><a href="#luaL_Buffer">luaL_Buffer</a><br><br><a href="#luaL_Reg">luaL_Reg</a><br><br><br></p><p><br><a href="#luaL_addchar">luaL_addchar</a><br><br><a href="#luaL_addlstring">luaL_addlstring</a><br><br><a href="#luaL_addsize">luaL_addsize</a><br><br><a href="#luaL_addstring">luaL_addstring</a><br><br><a href="#luaL_addvalue">luaL_addvalue</a><br><br><a href="#luaL_argcheck">luaL_argcheck</a><br><br><a href="#luaL_argerror">luaL_argerror</a><br><br><a href="#luaL_buffinit">luaL_buffinit</a><br><br><a href="#luaL_buffinitsize">luaL_buffinitsize</a><br><br><a href="#luaL_callmeta">luaL_callmeta</a><br><br><a href="#luaL_checkany">luaL_checkany</a><br><br><a href="#luaL_checkint">luaL_checkint</a><br><br><a href="#luaL_checkinteger">luaL_checkinteger</a><br><br><a href="#luaL_checklong">luaL_checklong</a><br><br><a href="#luaL_checklstring">luaL_checklstring</a><br><br><a href="#luaL_checknumber">luaL_checknumber</a><br><br><a href="#luaL_checkoption">luaL_checkoption</a><br><br><a href="#luaL_checkstack">luaL_checkstack</a><br><br><a href="#luaL_checkstring">luaL_checkstring</a><br><br><a href="#luaL_checktype">luaL_checktype</a><br><br><a href="#luaL_checkudata">luaL_checkudata</a><br><br><a href="#luaL_checkunsigned">luaL_checkunsigned</a><br><br><a href="#luaL_checkversion">luaL_checkversion</a><br><br><a href="#luaL_dofile">luaL_dofile</a><br><br><a href="#luaL_dostring">luaL_dostring</a><br><br><a href="#luaL_error">luaL_error</a><br><br><a href="#luaL_execresult">luaL_execresult</a><br><br><a href="#luaL_fileresult">luaL_fileresult</a><br><br><a href="#luaL_getmetafield">luaL_getmetafield</a><br><br><a href="#luaL_getmetatable">luaL_getmetatable</a><br><br><a href="#luaL_getsubtable">luaL_getsubtable</a><br><br><a href="#luaL_gsub">luaL_gsub</a><br><br><a href="#luaL_len">luaL_len</a><br><br><a href="#luaL_loadbuffer">luaL_loadbuffer</a><br><br><a href="#luaL_loadbufferx">luaL_loadbufferx</a><br><br><a href="#luaL_loadfile">luaL_loadfile</a><br><br><a href="#luaL_loadfilex">luaL_loadfilex</a><br><br><a href="#luaL_loadstring">luaL_loadstring</a><br><br><a href="#luaL_newlib">luaL_newlib</a><br><br><a href="#luaL_newlibtable">luaL_newlibtable</a><br><br><a href="#luaL_newmetatable">luaL_newmetatable</a><br><br><a href="#luaL_newstate">luaL_newstate</a><br><br><a href="#luaL_openlibs">luaL_openlibs</a><br><br><a href="#luaL_optint">luaL_optint</a><br><br><a href="#luaL_optinteger">luaL_optinteger</a><br><br><a href="#luaL_optlong">luaL_optlong</a><br><br><a href="#luaL_optlstring">luaL_optlstring</a><br><br><a href="#luaL_optnumber">luaL_optnumber</a><br><br><a href="#luaL_optstring">luaL_optstring</a><br><br><a href="#luaL_optunsigned">luaL_optunsigned</a><br><br><a href="#luaL_prepbuffer">luaL_prepbuffer</a><br><br><a href="#luaL_prepbuffsize">luaL_prepbuffsize</a><br><br><a href="#luaL_pushresult">luaL_pushresult</a><br><br><a href="#luaL_pushresultsize">luaL_pushresultsize</a><br><br><a href="#luaL_ref">luaL_ref</a><br><br><a href="#luaL_requiref">luaL_requiref</a><br><br><a href="#luaL_setfuncs">luaL_setfuncs</a><br><br><a href="#luaL_setmetatable">luaL_setmetatable</a><br><br><a href="#luaL_testudata">luaL_testudata</a><br><br><a href="#luaL_tolstring">luaL_tolstring</a><br><br><a href="#luaL_traceback">luaL_traceback</a><br><br><a href="#luaL_typename">luaL_typename</a><br><br><a href="#luaL_unref">luaL_unref</a><br><br><a href="#luaL_where">luaL_where</a><br><br><br></p></td><br></tr><br></tbody></table><br><br><hr><br><br><h1>1 – <a name="1">简介</a></h1><br><br><p><br>Lua 是一门扩展型程序设计语言，用于辅助一般的过程式编程。当然，它也对面向对象编程、函数式编程和数据驱动式编程提供良好的支持。Lua<br>作为一门强大、轻量、可嵌入式的脚本语言能供任何需要的程序使用。Lua 是由 clean<br>C（标准&nbsp;C和C++的一个共通子集）实现的一个库。<br><br></p><p><br>作为一门扩展型语言，Lua没有“main”程序的概念：它只能<em>嵌入</em>宿主程序，宿主程序被称为 <em>embedding program</em> 或者简称 <em>host</em>。宿主程序可以调用函数执行一段 Lua 代码，可以读写 Lua 变量，甚至可以注册 C&nbsp;函数以在Lua代码中调用。通过对 C&nbsp;函数的使用，Lua足以应付各种领域，完全可以共享一个句法框架而定制不同的程序语言。Lua官方发布版包含一个叫 <code>lua</code> 的宿主程序示例，它是一个利用Lua库写成的完整独立的Lua解释器，一般用于交互和批处理。<br><br><br></p><p><br>Lua 作为自由软件,就像license里面所说，使用它是不需要抵押品的 :)。本手册所描述的实现可以在 Lua 官方网站 <code>www.lua.org</code> 中找到。<br><br><br></p><p><br>就像任何参考手册一样，这份文档某些地方有点枯燥。关于 Lua 背后设计思想的探讨，可以看看 Lua 官方网站上的技术论文。至于Lua编程的详细介绍，请参阅Roberto的书， <em>Programming in Lua</em>（当前最新是第三版）。<br><br><br></p><h1>2 – <a name="2">基本概念</a></h1><br><br><p><br>本章节介绍 Lua 语言里的基本概念。<br><br></p><h2>2.1 – <a name="2.1">值与类型</a></h2><br><br><p><br>Lua 是一门<em>动态类型语言</em>。这意味着变量没有类型，只有值。Lua 没有类型定义，由值本身携带自己的类型信息。<br><br></p><p><br>Lua 中的所有值均是 <em>first-class values（第一类值）</em>。这意味着所有的值均可存于变量中，也可作为参数传递给其他函数，也可作为函数结果被返回。<br><br></p><p><br>Lua中有八种基本类型：<br><em>nil（空）</em>、<em>boolean（布尔）</em>、<em>number（数字）</em>、<em>string（字符串）</em>、<em>function（函数）</em>、<em>userdata（用户数据）</em>、<em>thread（线程）</em>和 <em>table（表）</em>。<br><br></p><p><br><em>Nil</em> 类型只有值 <b>nil</b>，主要用于标识与其他值的不同；通常代表无意义的值。<br><br></p><p><br><em>Boolean</em> 类型只有两种值 <b>false</b> 和 <b>true</b>。<br><b>nil</b> 和 <b>false</b> 都表示条件为假；而其他任何值均表示为真。<br><br></p><p><br><em>Number</em> 表示实数（双精度浮点数）。数字间的运算操作与底层C实现遵循相同的规则，一般就是IEEE754标准。（使用内部其他数字类型如单精度浮点或长整型重新编译一个Lua解释器也非常容易；参见<code> luaconf.h </code>文件。）<br><br></p><p><br><em>String</em> 代表字节串。Lua is 8-bit clean：字符串可以包含任意8-bit值，包括 ‘<code>\0</code>‘ 。<br><br></p><p><br>Lua 可以调用（操作）由&nbsp;Lua&nbsp;和&nbsp;C&nbsp;写成的<em> Function </em>（参见 <a href="#3.4.9">§3.4.9</a>）。<br><br></p><p><br><em>userdata</em> 类型用来将任意&nbsp;C&nbsp;数据保存在&nbsp;Lua&nbsp;变量中。<br>一个&nbsp;userdata&nbsp;类型的值就是一块原生内存的指针。 &nbsp;userdata&nbsp;分两类：full userdata 和 light userdata ，前者的内存块由 Lua 管理；后者的内存块由 host 管理。<br>Userdata 在 Lua 中除了赋值与鉴定测试便没有其他预定义操作了。但是通过使用<em> metatables（元表）</em>，程序员可以为 full userdata 类型的值自定义操作（参见 <a href="#2.4">§2.4</a>）。<br>Userdata 类型的值不能在 Lua 中创建与修改，只能通过 C&nbsp;API。这样保证了宿主程序能完全掌管其中的数据。<br><br></p><p><br><em>thread</em> 代表独立的执行线程，用于实现 coroutines（协同程序）（参见 <a href="#2.6">§2.6</a>）。不要把 Lua 线程与操作系统线程搞混。Lua 在所有系统上均支持 coroutines，即使系统并不支持 threads 。<br><br></p><p><br><em>table</em> 类型实现了关联数组。也就是说，该数组可以用任何 Lua 值（除了<b>nil</b> 和 NaN）作索引，而不仅限于数字。<br>Tables 可以包含所有类型的值（除了<b>nil</b>）。任何带 <b>nil</b> 值的键都不是 table 的一部分。相应的，任何不属于 table 的键都关联一个 <b>nil</b> 值。<br><br><br></p><p><br>Table 是 Lua 中唯一的数据组织机制，可以用于表示普通数组、序列、符号表、集合、记录、图、树等等。在表示记录时，Lua 以域作为索引。语言支持以 <code>a.name</code> 来表示 a[“name”]，这只是一种语法糖。table 的创建方式有很多种（参见 <a href="#3.4.8">§3.4.8</a>）。<br><br><br></p><p><br>我们使用 <em>序列</em> 这个词来表示一个递增表，其索引为<em> {1..n} </em>，其中的<em> n </em>表示序列的长度（参见 <a href="#3.4.6">§3.4.6</a>）。<br><br><br></p><p><br>与索引一样，table 中的域也可为任意类型。特别的，由于函数也是 first-class values （第一类值/一等公民），所以 table 的域也可包含函数。从而 table 也能携带<em> methods </em> （参见 <a href="#3.4.10">§3.4.10</a>）。（译注：这为面向对象提供了基础）<br><br><br></p><p><br>table 的索引遵循语言中定义的原生相等性。表达式 <code>a[i]</code> 与 <code>a[j]</code> 只在 <code>i</code> 与 <code>j</code> 原生相等（指无元方法的相等）时才表示同一个表元素。<br><br><br></p><p><br>Table、function、thread 和 (full) userdata 类型的值均是 <em>对象</em>：变量实际上不<em>含有 </em>值，只是<em>引用 </em>值。赋值、参数传递和函数返回等操控的只是值的引用；这些操作不会做任何性质的拷贝。<br><br><br></p><p><br>库函数<a href="#pdf-type"><code> type </code></a>可以返回一个给定值的类型（参见 <a href="#6.1">§6.1</a>）。<br><br><br></p><h2>2.2 – <a name="2.2">环境与全局变量</a></h2><br><br><p><br>就像在 <a href="#3.2">§3.2</a> 和 <a href="#3.3.3">§3.3.3</a> 讨论的那样，任何对全局名称 <code>var</code> 的引用均会被翻译成 <code>_ENV.var</code>。此外，任何在局部变量之外编译的程序块均叫作<br> <code>_ENV</code>（参见 <a href="#3.3.2">§3.3.2</a>），<br>所以 <code>_ENV</code> 本身在程序块中从来都不是全局名称。<br><br><br></p><p><br>尽管存在外部 <code>_ENV</code> 变量用于全局名称的翻译，<code>_ENV</code> 本身其实是一个完全符合命名规则的名称。你完全可以定义新的变量/参数并取这个名字。每一次使用 <code>_ENV</code> 对全局名称的引用在当时对程序是可见的，完全遵循 Lua 通用可见性规则（参见 <a href="#3.5">§3.5</a>）。<br><br><br></p><p><br>任何被存储 <code>_ENV</code> 值的表叫作 <em>environment（环境）</em>.<br><br><br></p><p><br>Lua 维持一个叫 <em>global environment（全局环境）</em>的特殊环境。这个值在 C 注册表（参见 <a href="#4.5">§4.5</a>）表示一个特殊索引。在 Lua 中，变量 <a href="#pdf-_G"><code>_G</code></a> 被初始化为相同值。<br><br><br></p><p><br>当 Lua 编译一个 chunk（程序块）时，会先将其中 <code>_ENV</code> 的值提升为全局环境（参见 <a href="#pdf-load"><code>load</code></a>）。因此，默认情况下，Lua代码中的全局变量一般指的是全局环境里的入口。此外，加载到全局环境下的所有标准库和部分函数均是在该环境下运作。你可以使用 <a href="#pdf-load"><code>load</code></a> （或者 <a href="#pdf-loadfile"><code>loadfile</code></a>）来加载一个不同环境下的 chunk。<br><!--
(In C, you have to load the chunk and then change the value
of its first upvalue.)
--><br><br></p><p><br>如果你改变了注册表中的全局环境（通过 C 代码或者 debug 库），在改变之后加载的 chunk 将获得新的环境。先前加载的 chunk 虽不受影响，但都要在自身的 <code>_ENV</code> 变量中引用到新环境去。此外，Lua 从不更新变量 <a href="#pdf-_G"><code>_G</code></a>（存于原始全局环境）。<br><br><br><br></p><h2>2.3 – <a name="2.3">错误处理</a></h2><br><br><p><br>由于 Lua 是一门嵌入式扩展语言，所有的 Lua 行为均源于宿主程序 C 代码对 Lua 库的函数调用（参见 <a href="#lua_pcall"><code>lua_pcall</code></a>）。无论何时 Lua 程序块发生编译/执行错误，控制权均会交给宿主程序，由宿主程序触发恰当的措施（比如打印一条出错信息）。<br><br><br></p><p><br>Lua 代码可以通过调用 <a href="#pdf-error"><code>error</code></a> 函数明确产生错误信息。如果需要在 Lua 中 捕捉错误，可以使用 <a href="#pdf-pcall"><code>pcall</code></a> 或 <a href="#pdf-xpcall"><code>xpcall</code></a> 来在<em> protected mode（保护模式）</em>下调用一个处理函数。<br><br><br></p><p><br>每产生一个错误，就会传播一个包含该错误信息的 <em>error object（错误对象）</em> （也叫 <em>error message（错误消息）</em>）。Lua 本身只为错误对象产生一条字符串错误信息，而程序可以为错误对象产生任何形式的错误信息。<br><br><br></p><p><br>当使用 <a href="#pdf-xpcall"><code>xpcall</code></a> 或者 <a href="#lua_pcall"><code>lua_pcall</code></a>时，可以传递一个  <em>message handler（消息处理程序）</em>以<br>在错误出现时调用。这个程序由原始错误消息调用并返回一条新的消息。它在错误离开栈之前被调用，故能收集更多关于错误的信息，比如检查堆栈和创建堆栈回<br>溯。这个消息处理程序在保护模式下被调用，自身也处在保护中，因此，消息处理中出现错误的话将再次调用消息处理（也就是自己）。如果发生了这种循环，将由<br> Lua 中断并返回一段恰当的消息。<br><br><br><br></p><h2>2.4 – <a name="2.4">元表与元方法</a></h2><br><br><p><br>Lua 中的每个值均能拥有一个<em>metatable（元表）</em>。这个 <em>metatable</em> 就是普通的 Lua table，然后定义了一些原始值在特定操作下的行为。你可以通过在一个值的元表中设置特定的域来改变操作行为。例如，当一个非数字的值要做加法操作，Lua 会查询该值的元表中 “<code><strong>add</strong></code>“ 域中的函数，如果找到一个函数，Lua 则调用该函数来执行加法。<br><br><br></p><p><br>元表中的键命名为 <em>event（事件）</em>；对应的值叫 <em>metamethods（元方法）</em>。在刚才的例子中，事件是<br> <code>“add”</code>，元方法则是那个执行加法操作的函数。<br><br><br></p><p><br>你可以使用 <a href="#pdf-getmetatable"><code>getmetatable</code></a> 函数来查询任何值的 metatable（元表）。<br><br></p><p><br>你可以使用 <a href="#pdf-setmetatable"><code>setmetatable</code></a> 函数来替换 table 的 metatable 。但不能在 Lua 中改变其他类型（比如 number、string类型）的 metatable（除非使用 debug 库），必须得使用 C&nbsp;API。<br><br><br></p><p><br>每个 table 和 full userdata 拥有独立的 metatable（虽然多个 table 和 userdata 也可共享它们的<br>metatable）。而所有其他类型的值，一种类型只有一个 metatable；意味着所有数字只有一个<br>metatable，所有字符串也一样，等等。默认情况下，单个值是没有 metatable 的，但字符串库为 string 类型设置了一个<br>metatable（参见 <a href="#6.4">§6.4</a>）。<br><br><br></p><p><br>一个 metatable  控制着一个对象在数学运算、比较、连接、取长和索引等操作的行为表现。它也能定义函数，让 userdata 或者<br>table 做垃圾收集时调用。当 Lua 需要对某个值执行其中一种操作时，会先检查值的 metatable<br>中是否有对应的事件。如果有，键对应的值（metamethod 元方法）将决定 Lua 如何执行操作。<br><br><br></p><p><br><br>Metatable 能控制的操作全列在了下面。各种操作用对应的名字区分。每种操作的键都是操作名前面加上两个下划线 （ ‘<code></code>‘ ）的字符串。比如 “add” 操作的键就是字符串 “<code><strong>add</strong></code>“。<br><br><br></p><p><br>这些操作的含义由 Lua 函数来解释更准确，毕竟函数展示了解释器内部如何执行该操作。这里的 Lua 代码仅用作解释说明，实际的行为已经硬编码在解释器中，自然也比这些模拟代码高效。在下面代码使用到的 <a href="#pdf-rawget"><code>rawget</code></a>, <a href="#pdf-tonumber"><code>tonumber</code></a> 等等函数可在 <a href="#6.1">§6.1</a> 找到。注意，我们使用下面一行表达式来从给定对象中提取元方法<br><br></p><pre>     metatable(obj)[event]<br></pre><p><br>可被解读成<br><br></p><pre>     rawget(getmetatable(obj) or {}, event)<br></pre><p><br>这意味着访问一个元方法不会调用其他元方法，而且访问没有 metatable 的对象也不会失败（仅仅导致 <b>nil</b>）。<br><br></p><p><br>对于一元操作符 <code>-</code> 和 <code>#</code>，元方法由虚拟的第二参数调用。这个额外的参数仅用于简化 Lua 的内建对象；在将来的版本中可能被移除，因此我们不会在下面讨论。（其实额外参数的大部分使用都是无关紧要的。）<br><br><br></p><ul><br><br><li><a name="add"><b>“add”: </b></a><br><code><b>+</b></code> 操作。<br><br><p><br>下面的 <code>getbinhandler</code> 函数定义了 Lua 如何为二元运算选择处理方法。Lua 首先测试第一个操作数，如果它的类型没有为该运算操作定义处理方法，Lua 就会测试第二个操作数。<br><br></p><pre>     function getbinhandler (op1, op2, event)<br>       return metatable(op1)[event] or metatable(op2)[event]<br>     end<br></pre><p><br>通过这个函数，<code>op1 + op2</code> 的行为就是<br><br></p><pre>     function add_event (op1, op2)<br>       local o1, o2 = tonumber(op1), tonumber(op2)<br>       if o1 and o2 then  – 两个操作数均为数字？<br>         return o1 + o2   – 这里的 ‘+’ 就是基本加法（ ‘add’）<br>       else  – 至少有一个操作数不是数字<br>         local h = getbinhandler(op1, op2, “add”)<br>         if h then<br>           – 以两个操作数调用处理方法<br>           return (h(op1, op2))<br>         else  – 没有处理方法：默认行为<br>           error(···)<br>         end<br>       end<br>     end<br></pre><p><br></p></li><br><br><li><b>“sub”：</b><br><code><b>-</b></code> 操作，<br><br>行为类似 <a href="#add">“add”</a> 操作。<br></li><br><br><li><b>“mul”：</b><br><code><b><em></em></b></code> 操作，<br><br>行为类似 <a href="#add">“add”</a> 操作。<br></li><br><br><li><b>“div”： </b><br><code><b>/</b></code> 操作，<br><br>行为类似 <a href="#add">“add”</a> 操作。<br></li><br><br><li><b>“mod”：</b><br><code><b>%</b></code> 操作，<br><br>行为类似 <a href="#add">“add”</a> 操作，原始操作是 <code>o1 - floor(o1/o2)o2</code>。<br></li><br><br><li><b>“pow”：</b><br><code><b>^</b></code> （幂）操作。<br><br>行为类似 <a href="#add">“add”</a> 操作，原始操作是 <code>pow</code>  函数（来自 C&nbsp;math 库）。<br></li><br><br><li><b>“unm”：</b><br>一元 <code><b>-</b></code> 操作。<br><br><pre>     function unm_event (op)<br>       local o = tonumber(op)<br>       if o then  – operand is numeric?<br>         return -o  – ‘-‘ here is the primitive ‘unm’<br>       else  – the operand is not numeric.<br>         – Try to get a handler from the operand<br>         local h = metatable(op).<strong>unm<br>         if h then<br>           – call the handler with the operand<br>           return (h(op))<br>         else  – no handler available: default behavior<br>           error(···)<br>         end<br>       end<br>     end<br></strong></pre><p><br></p></li><br><br><li><b>“concat”：</b><br><code><b>..</b></code> （连接）操作。<br><br><br><pre>     function concat_event (op1, op2)<br>       if (type(op1) == “string” or type(op1) == “number”) and<br>          (type(op2) == “string” or type(op2) == “number”) then<br>         return op1 .. op2  – primitive string concatenation<br>       else<br>         local h = getbinhandler(op1, op2, “concat”)<br>         if h then<br>           return (h(op1, op2))<br>         else<br>           error(···)<br>         end<br>       end<br>     end<br></pre><p><br></p></li><br><br><li><b>“len”：</b><br><code><b>#</b></code> 操作。<br><br><br><pre>     function len_event (op)<br>       if type(op) == “string” then<br>         return strlen(op)      – primitive string length<br>       else<br>         local h = metatable(op).<strong>len<br>         if h then<br>           return (h(op))       – call handler with the operand<br>         elseif type(op) == “table” then<br>           return #op              – primitive table length<br>         else  – no handler available: error<br>           error(···)<br>         end<br>       end<br>     end<br></strong></pre><p><br>关于 table 的长度请参阅 <a href="#3.4.6">§3.4.6</a>。<br></p></li><br><br><li><b>“eq”：</b><br><code><b>==</b></code> 操作。<br><br>函数 <code>getequalhandler</code> 定义了 Lua 如何选择元方法进行相等操作。只有当两个被比较的值类型相同，而且在当前操作下拥有相同的元方法，而且不属于 table 或 full userdata 间的一种时，被选出的元方法才会有效。<br><br><br><pre>     function getequalhandler (op1, op2)<br>       if type(op1) ~= type(op2) or<br>          (type(op1) ~= “table” and type(op1) ~= “userdata”) then<br>         return nil     – different values<br>       end<br>       local mm1 = metatable(op1).eq<br>       local mm2 = metatable(op2).<strong>eq<br>       if mm1 == mm2 then return mm1 else return nil end<br>     end<br></strong></pre><p><br>“eq” 事件定义如下：<br><br></p><pre>     function eq_event (op1, op2)<br>       if op1 == op2 then   – primitive equal?<br>         return true   – values are equal<br>       end<br>       – try metamethod<br>       local h = getequalhandler(op1, op2)<br>       if h then<br>         return not not h(op1, op2)<br>       else<br>         return false<br>       end<br>     end<br></pre><p><br>注意结果常为 boolean 值。<br></p></li><br><br><li><b>“lt”：</b><br><code><b>&lt;</b></code> 操作。<br><br><br><pre>     function lt_event (op1, op2)<br>       if type(op1) == “number” and type(op2) == “number” then<br>         return op1 &lt; op2   – numeric comparison<br>       elseif type(op1) == “string” and type(op2) == “string” then<br>         return op1 &lt; op2   – lexicographic comparison<br>       else<br>         local h = getbinhandler(op1, op2, “lt”)<br>         if h then<br>           return not not h(op1, op2)<br>         else<br>           error(···)<br>         end<br>       end<br>     end<br></pre><p><br>注意结果常为 boolean 值。<br></p></li><br><br><li><b>“le”: </b><br><code><b>&lt;=</b></code> 操作。<br><br><br><pre>     function le_event (op1, op2)<br>       if type(op1) == “number” and type(op2) == “number” then<br>         return op1 &lt;= op2   – numeric comparison<br>       elseif type(op1) == “string” and type(op2) == “string” then<br>         return op1 &lt;= op2   – lexicographic comparison<br>       else<br>         local h = getbinhandler(op1, op2, “<strong>le”)<br>         if h then<br>           return not not h(op1, op2)<br>         else<br>           h = getbinhandler(op1, op2, “</strong>lt”)<br>           if h then<br>             return not h(op2, op1)<br>           else<br>             error(···)<br>           end<br>         end<br>       end<br>     end<br></pre><p><br>注意，缺少 “le” 元方法时，Lua 就尝试 “lt”，并假定 <code>a &lt;= b</code> 等价于 <code>not (b &lt; a)</code>。<br><br><br></p><p><br>就像其他比较运算符，其结果常为 boolean 值。<br></p></li><br><br><li><b>“index”：</b><br>索引操作用于访问 <code>table[key]</code>。注意仅当 <code>key</code> 不在 <code>table</code> 中时，才会尝试元方法。（当 <code>table</code> 不是表时，里面没有键，所以会一直尝试元方法。）<br><br><br><pre>     function gettable_event (table, key)<br>       local h<br>       if type(table) == “table” then<br>         local v = rawget(table, key)<br>         – if key is present, return raw value<br>         if v ~= nil then return v end<br>         h = metatable(table).<strong>index<br>         if h == nil then return nil end<br>       else<br>         h = metatable(table).</strong>index<br>         if h == nil then<br>           error(···)<br>         end<br>       end<br>       if type(h) == “function” then<br>         return (h(table, key))     – call the handler<br>       else return h[key]           – or repeat operation on it<br>       end<br>     end<br></pre><p><br></p></li><br><br><li><b>“newindex”：</b><br>赋值给索引 <code>table[key] = value</code>。注意仅当 <code>key</code> 不在 <code>table</code> 中时，才会尝试元方法。<br><br><br><pre>     function settable_event (table, key, value)<br>       local h<br>       if type(table) == “table” then<br>         local v = rawget(table, key)<br>         – if key is present, do raw assignment<br>         if v ~= nil then rawset(table, key, value); return end<br>         h = metatable(table).<strong>newindex<br>         if h == nil then rawset(table, key, value); return end<br>       else<br>         h = metatable(table).</strong>newindex<br>         if h == nil then<br>           error(···)<br>         end<br>       end<br>       if type(h) == “function” then<br>         h(table, key,value)           – call the handler<br>       else h[key] = value             – or repeat operation on it<br>       end<br>     end<br></pre><p><br></p></li><br><br><li><b>“call”：</b><br>当 Lua 调用一个值时调用。<br><br><br><pre>     function function_event (func, …)<br>       if type(func) == “function” then<br>         return func(…)   – primitive call<br>       else<br>         local h = metatable(func).<strong>call<br>         if h then<br>           return h(func, …)<br>         else<br>           error(···)<br>         end<br>       end<br>     end<br></strong></pre><p><br></p></li><br><br></ul><br><br><br><br><br><h2>2.5 – <a name="2.5">垃圾收集</a></h2><br><br><p><br>Lua 实行自动内存管理。意味着你不用担心创建新对象时的内存分配，也不用担心对象不再需要时的内存释放。Lua 运行一个 <em>garbage collector（垃圾收集器）</em> 来自动管理内存，收集 <em>dead objects（死亡对象）</em>（指 Lua 不再访问的对象）。Lua 中使用的所有内存（对象）均被自动管理：strings、tables、userdata、functions、threads、internal structures 等等。<br><br><br></p><p><br>Lua 实现了一个增量标记-清除收集器。它使用两个数字来控制垃圾收集周期： <em>garbage-collector pause</em> 和<br> <em>garbage-collector step multiplier</em>。两者均使用百分点作为计数单元（比如，100在内在表示 为1个百分点）。<br><br></p><p><br>garbage-collector pause 控制着收集器在开始新周期前的停顿时长。数字越大收集器越不积极，停顿时间越长。小于100意味着收集器不停顿即开始新周期。200表示收集器在内存使用量达到原来的两倍时才会开启新的周期。<br><br><br></p><p><br>garbage-collector step multiplier<br>控制收集器与内存分配的相对速度。数字越大收集器越积极，增加的收集量也越大。小于100会让收集器工作的非常慢，甚至造成收集器永远无法结束当前周期。<br>默认值为200，表示收集器以内存分配的两倍速度运行着。<br><br><br></p><p><br>如果你将 step multiplier 设置的非常大（比程序中可能使用到的最大字节数还要大10%），收集器的行为将类似<br>stop-the-world 收集器（即为了完成一个完整的垃圾收集周期而暂停与主程序的交互）。如果你同时又将 pause<br>设成200，那收集器就像老版本的Lua一样，等内存使用量达到 Lua 本身使用量的两倍才会做一次完全的垃圾回收。<br><br><br></p><p><br>你可以通过在 C 中调用 <a href="#lua_gc"><code>lua_gc</code></a> 或者在 Lua 中调用 <a href="#pdf-collectgarbage"><code>collectgarbage</code></a> 来改变这些数字。你也可以通过这些函数来直接控制垃圾收集器（比如关闭、重启之类）。<br><br><br></p><p><br>作为 Lua 5.2 中的一个实验特性，你可以改变收集器的操作模式，从 incremental 改成<em>generational</em>。<em>generational collector</em><br><br>假设大部分对象存活时间很短，因此收集器只会检测最近创建的新对象。这种行为能降低收集器的使用时间，但会增加内存使用量（逐渐累积老死的对象）。要解决<br>第二个问题，可以让 generational collector 时常执行完整的回收。记住，这只是处于实验阶段的特性，欢迎尝试，看看效果咋样。<br><br><br><br></p><h3>2.5.1 – <a name="2.5.1">垃圾收集元方法</a></h3><br><br><p><br>你可以为 table 设置垃圾收集元方法，也可使用 C API 为 full  userdata 设置（参见 <a href="#2.4">§2.4</a>）。这些元方法也叫 <em>finalizers（析构器）</em>。析构器允许外部资源管理（比如关闭文件、关闭网络、关闭数据库连接或者释放自己的内存）配合 Lua 的垃圾收集。<br><br><br></p><p><br>对象（table 或者 userdata）需要被析构回收时，你必须 <em>标记</em> 它为可析构。只需为对象设置一张有 “<code>gc</code> 域的元表即可标记对象为可析构。注意一点，如果你为对象先设置了一张没有 <code><strong>gc</strong></code> 域的元表，然后在元表中新建一个 <code>gc</code> 域，这个对象是没法被标记的。而在对象被标记后，你可以随意改变元表中的 <code><strong>gc</strong></code> 域 。<br><br><br></p><p><br>当被标记对象变成垃圾时，垃圾收集器不会立马将它回收，而是由 Lua 将之放进一个列表中。收集结束后，Lua 对列表中每个对象执行下面函数的等价操作：<br><br></p><pre>     function gc_event (obj)<br>       local h = metatable(obj).gc<br>       if type(h) == “function” then<br>         h(obj)<br>       end<br>     end<br></pre><br><br><p><br>每个垃圾收集周期的结尾，当前周期内收集到的垃圾对象会以被标记顺序的 <b>反序</b> 调用析构器。这意味着程序里最后被标记的对象最先析构。析构器的执行可能发生在普通代码执行期间的任何时候。<br><br><br></p><p><br>由于被回收了的对象还要被析构器使用，该对象会由 Lua <em>resurrected（复活）</em>。当然，这个复活是短暂的，而且对象的内存会在下一个垃圾收集周期释放掉。然而，如果析构器将对象存在某些全局位置（比如一个全局变量里面），那这就变成永久性复活了。总之，对象的内存只有在完全不可访问的情况下才能被释放；它的析构器也从不会被调用两次。<br><br></p><p><br>当关闭一个状态（参见 <a href="#lua_close"><code>lua_close</code></a>），Lua将对所有被标记为可析构的对象以标记的反序来调用析构器。如果刚好有新对象在这个阶段被标记，新对象是不会被析构的。<br><br><br><br></p><h3>2.5.2 – <a name="2.5.2">弱表</a></h3><br><br><p><br><em>weak table</em> 指表中元素被 <em>weak references（弱引用）</em>。而垃圾收集器会忽略弱引用，换言之，如果一个对象只有弱引用，垃圾收集器会将之回收。<br><br></p><p><br>弱表的键与值均可为 weak。拥有弱键的表，键会被回收而对应的值不会。而键与值都 weak 的话，收集器会将键与值都回收掉。而且，无论键与值谁被回收了，对应的键值对都会从表中移除。table 的 weak 性质受元表的 <code><strong>mode</strong></code> 域控制。如果 <code>mode</code> 域是一个含有字符&nbsp;’<code>k</code>‘ 的字符串，则 table 中的键就是 weak 的；相应的，如果 <code><strong>mode</strong></code> 域含有字符  ‘<code>v</code>‘，table 中的值就是 weak 的。<br><br><br></p><p><br>拥有弱键与强值的表也叫 <em>ephemeron table（短命表）</em>。在这种表中，值的可访问性只依赖对应键的可访问性。尤其是键的唯一引用来自它的值时，这个键值对将被移除。<br><br><br></p><p><br>对表的 weak 性质做任何改变只会对下一个垃圾收集周期产生影响。而且，如果你改成更 strong（强）的模式，Lua 在更改真正生效之前仍然会回收表中某些项。<br><br></p><p>只有那些明确说明的对象才会从弱表中移除。数字和轻量 C 函数之类不受垃圾收集管理，因此不会从弱表中移除（除非它的关联值已被回收了）。虽然字符串受垃圾收集管理，但它们没有明确说明，因此也不会从弱表中移除。<br><br><br></p><p><br>复活的对象（指那些即将析构且只能由析构器访问的对象）在弱表中有一种特殊行为。它们在运行自身析构器之前会从弱值中移除，但只能在下一个垃圾收集周期从弱键中移除，此时才是真正的对象释放。这种行为就允许析构器在弱表中访问与对象相关的属性。<br><br><br></p><p><br>如果一个弱表在当前回收周期位于一个复活对象中，那只能在下一个周期里才能正确清除掉。<br><br><br><br><br><br><br></p><h2>2.6 – <a name="2.6">协程</a></h2><br><br><p><br>Lua 支持 coroutines（协程），也叫 <em>collaborative multithreading（协同多线程）</em>。Lua 中的每个协程都在各自独立的线程中执行。不像多线程系统中的线程，协程只会在显示调用 yield 函数时挂起。<br><br><br></p><p><br>调用 <a href="#pdf-coroutine.create"><code>coroutine.create</code></a> 会创建一个协程，其参数就是协程的主函数。<br>这个 <code>create</code> 函数仅仅创建新的协程并返回句柄（一个类型为 <em>thread</em> 的对象），而不会启动协程。<br><br><br></p><p><br>调用 <a href="#pdf-coroutine.resume"><code>coroutine.resume</code></a> 就开始执行协程。当你首次调用 <a href="#pdf-coroutine.resume"><code>coroutine.resume</code></a>，需传入的第一个参数就是<a href="#pdf-coroutine.create"><code>coroutine.create</code></a> 返回的 thread。然后协程从它的主函数第一行开始执行。接下来传入 <a href="#pdf-coroutine.resume"><code>coroutine.resume</code></a> 的其他参数均会传递给协程的主函数。协程一旦运行，直到终止或者挂起。<br><br><br></p><p><br>协程有两种方式终止执行：正常退出和异常退出，前者指由它的主函数返回退出（无论最后有没有显示 return），这时<a href="#pdf-coroutine.resume"><code>coroutine.resume</code></a> 返回 <b>true</b>，并附带协程主函数的返回值；后者指发生未预防的错误，这时 <a href="#pdf-coroutine.resume"><code>coroutine.resume</code></a> 返回 <b>false</b>，并附加一条错误消息。<br><br><br></p><p><br>调用 <a href="#pdf-coroutine.yield"><code>coroutine.yield</code></a> 能使协程挂起。当协程发生挂起时，相应的 <a href="#pdf-coroutine.resume"><code>coroutine.resume</code></a> 会立刻返回，即使挂起发生在内层函数调用中（这意味着不限于在主函数之内，其他受主函数直接/间接调用的函数之内也能发生）。协程的挂起，使<a href="#pdf-coroutine.resume"><code>coroutine.resume</code></a> 同样返回 <b>true</b>，并附带那些传递给 <a href="#pdf-coroutine.yield"><code>coroutine.yield</code></a> 的参数值。再次调用 <a href="#pdf-coroutine.yield"><code>coroutine.yield</code></a> 将恢复该协程，并从挂起的断点处继续执行，其返回值则是传递给 <a href="#pdf-coroutine.resume"><code>coroutine.resume</code></a> 的参数值。<br><br><br></p><p><br>类似 <a href="#pdf-coroutine.create"><code>coroutine.create</code></a>，<a href="#pdf-coroutine.wrap"><code>coroutine.wrap</code></a> 函数也能创建协程，但返回的不是协程本身，而是一个能重新获得协程的函数。传递给 wrap 函数的任何参数都将作为 <a href="#pdf-coroutine.resume"><code>coroutine.resume</code></a> 的额外参数。 <a href="#pdf-coroutine.wrap"><code>coroutine.wrap</code></a> 返回<a href="#pdf-coroutine.resume"><code>coroutine.resume</code></a> 返回值中除第一个（boolean型错误代码）之外其他所有值。与 <a href="#pdf-coroutine.resume"><code>coroutine.resume</code></a>不同的是， <a href="#pdf-coroutine.wrap"><code>coroutine.wrap</code></a> 不捕获错误；任何错误都得由调用者来传递。<br><br><br></p><p><br>协程如何运作，思考下面的示例：<br><br><br></p><pre>     function foo (a)<br>       print(“foo”, a)<br>       return coroutine.yield(2<em>a)<br>     end<br><br>     co = coroutine.create(function (a,b)<br>           print(“co-body”, a, b)<br>           local r = foo(a+1)<br>           print(“co-body”, r)<br>           local r, s = coroutine.yield(a+b, a-b)<br>           print(“co-body”, r, s)<br>           return b, “end”<br>     end)<br><br>     print(“main”, coroutine.resume(co, 1, 10))<br>     print(“main”, coroutine.resume(co, “r”))<br>     print(“main”, coroutine.resume(co, “x”, “y”))<br>     print(“main”, coroutine.resume(co, “x”, “y”))<br></em></pre><p><br>运行结果如下：<br><br></p><pre>     co-body 1       10<br>     foo     2<br>     main    true    4<br>     co-body r<br>     main    true    11      -9<br>     co-body x       y<br>     main    true    10      end<br>     main    false   cannot resume dead coroutine<br></pre><br><br><p><br>你也可以通过 C API 来创建和操作协程：参阅 <a href="#lua_newthread"><code>lua_newthread</code></a>、<a href="#lua_resume"><code>lua_resume</code></a>、<a href="#lua_yield"><code>lua_yield</code></a> 等函数。<br><br><br><br><br><br></p><h1>3 – <a name="3">语言</a></h1><br><br><p><br>本章介绍 Lua 的词法、语法和句法。换言之，这一章介绍哪些 token（符号）是合法的，它们如何组合，以及组合后的含义。<br><br><br></p><p><br>语言的结构由常用的扩展BNF范式来表示，即 {<em>a</em>} 表示0或多个 a，[<em>a</em>] 表示 a 为可选项。非终结符（一般是语言里的语法成分）保持不变，关键字类似 <b>kword</b>，其余的终结符（语言字符集的基本字符）要像这样 ‘<b>=</b>’ 位于引号中。完整的 Lua 语法可在本手册最末处 <a href="#9">§9</a> 找到。<br><br><br><br></p><h2>3.1 – <a name="3.1">词法规定</a></h2><br><br><p><br>Lua 是门 free-form 语言。除了名字与关键字间的分隔符，它将忽略词法元素（符号）之间的空白（包括换行）和注释。<br><br><br><br></p><p><br>Lua 中的 <em>Names（名字）</em> （也叫 <em>identifiers（标识符）</em>）可以是任何字母、数字、下划线组成的非数字开头的字符串。标识符用于命名变量、表的域和标签。<br><br><br></p><p><br>下面是 Lua 保留的 <em>keywords（关键字）</em>，不能用作名字：<br><br><br></p><pre>     and       break     do        else      elseif    end<br>     false     for       function  goto      if        in<br>     local     nil       not       or        repeat    return<br>     then      true      until     while<br></pre><br><br><p><br>Lua 区分大小写： <code>and</code> 是保留字，但 <code>And</code> 和 <code>AND</code> 则是两个不同的合法名字。一般约定，以下划线开头接大写字母的名字（比如 <a href="#pdf-_VERSION"><code>_VERSION</code></a>）被保留用于 Lua 内部变量。<br><br><br></p><p><br>下面是其他符号：<br><br></p><pre>     +     -          /     %     ^     #<br>     ==    ~=    &lt;=    &gt;=    &lt;     &gt;     =<br>     (     )     {     }     [     ]     ::<br>     ;     :     ,     .     ..    …<br></pre><br><br><p><br><em>Literal strings（文字串）</em> 可以放在单双引号内，其中也可包含类似 C 中的转义序列： ‘<code>\a</code>‘ (响铃)，<br>‘<code>\b</code>‘ (退格)，<br>‘<code>\f</code>‘ (换页)，<br>‘<code>\n</code>‘ (换行)，<br>‘<code>\r</code>‘ (回车)，<br>‘<code>\t</code>‘ (横向制表)，<br>‘<code>\v</code>‘ (纵向制表)，<br>‘<code>\</code>‘ (反斜线)，<br>‘<code>\”</code>‘ (双引号)，<br>和 ‘<code>\’</code>‘ (单引号)。<br>一个反斜线后跟一个换行符（\n）会让字符串中产生一个换行符号（\n）。转义序列 ‘<code>\z</code>‘ 会跳过后面的空白字符，包括换行符；这个在将一段很长的文字串截成多行时非常有用。<br><br><br></p><p><br>文字串中的字节也可通过数字表示出来。使用转义序列 <code>\x<em>XX</em></code>即可办到， <em>XX</em> 是两个十六进制数字；或者使用转义序列 <code>\<em>ddd</em></code>，<em>ddd</em> 表示最多三个十进制数字的序列。（注意，如果要在转义之后跟一个数字，那斜线后必须写满三个数字，否则会有歧义。）Lua 中的字符串可以包含任意8-bit值，包括 ‘<code>\0</code>‘ 表示的零；<br><br><br></p><p><br>文字串也可由<em>长括号</em>的形式定义。左长括号由两个左方括号（[[）表示，在两个方括号之间可以有 <em>n</em> 个等号（=），等号代表级别。于是，0级左长括号就写作 <code>[[</code>，1级就写作 <code>[=[</code>。相对应的右长括号就是 <code>]]</code> 和 <code>]=]</code>。这主要用于长文字串，在相同等级（就是等号一样多）的左右长括号之内，可输入任何文本，不处理转义符，不受分行限制，忽略所有不对等级的嵌套长括号。任何行尾符（回车、换行、回车加换行、换行加回车）统统变成简单的换行。<br><br><br></p><p><br>Any byte in a literal string not<br>explicitly affected by the previous rules represents itself.<br>However, Lua opens files for parsing in text mode,<br>and the system file functions may have problems with<br>some control characters.<br>So, it is safer to represent<br>non-text data as a quoted literal with<br>explicit escape sequences for non-text characters.<br><br><br></p><p><br>为了方便，左长括号后面紧跟的那个换行符将被忽略。例如，一个使用 ASCII 码的系统中（ ‘<code>a</code>‘ 编码为 97，\n 编码为 10， ‘<code>1</code>‘  编码为 49），下面五种形式表示相同的字符串：<br><br><br></p><pre>     a = ‘alo\n123”‘<br>     a = “alo\n123\””<br>     a = ‘\97lo\10\04923”‘<br>     a = [[alo<br>     123”]]<br>     a = [==[<br>     alo<br>     123”]==]<br></pre><br><br><p><br><em>numerical constant（数值常量）</em> 可以写成普通形式，也可以写成科学计数法（指数部分由字母  ‘<code>e</code>‘ 或 ‘<code>E</code>‘ 标记）。Lua 也支持十六进制常量，只需前面加上 <code>0x</code> 或者 <code>0X</code>。十六进制也接受二进制指数形式的小数（用字母 ‘<code>p</code>‘ 或 ‘<code>P</code> 标记）。以下是一些合法的数值常量写法：<br><br></p><pre>     3     3.0     3.1416     314.16e-2     0.31416E1<br>     0xff  0x0.1E  0xA23p-4   0X1.921FB54442D18P+1<br></pre><br><br><p><br><em>comment（注释）</em> 由两横开始 (<code>–</code>)，可以出现在字符串之外的任何地方。如果跟在 <code>–</code> 后面的不是一个左长括号，这就是一个 <em>短注释</em>，作用范围直到行末。否则就是一个 <em>长注释</em>，作用范围是同等级的右长括号。长注释常用于临时屏蔽代码块。<br><br><br><br></p><h2>3.2 – <a name="3.2">变量</a></h2><br><br><p><br>变量是存储值的地方。Lua 中有三种：全局变量、局部变量和表的域。<br><br><br></p><p><br>一个单独的名字可以表示为一个全局变量或者一个局部变量（或者一个函数参数，这也是一种局部变量）：<br><br><br></p><pre>    var ::= Name<br></pre><p><br>Name 就是 <a href="#3.1">§3.1</a>所定义的标识符。<br><br><br></p><p><br>任何没有显示声明为 local （参见 <a href="#3.3.7">§3.3.7</a>）的变量名均可假定为全局变量。局部变量的 <em>lexically scoped（作用域）</em>：定义在函数作用域（参见 <a href="#3.5">§3.5</a>）的局部变量可被其自由访问。<br><br></p><p><br>变量首次赋值前，默认值均为 <b>nil</b>。<br><br><br></p><p><br>方括号用于索引表：<br><br></p><pre>    var ::= prefixexp ‘<b>[</b>’ exp ‘<b>]</b>’<br></pre><p><br>访问表的域的含义能被元表更改。而访问被索引的变量 <code>t[i]</code> 等价于调用 <code>gettable_event(t,i)</code>。（参见 <a href="#2.4">§2.4</a> 获取 <code>gettable_event</code> 函数的完整描述。该函数未在 Lua 中定义，也不能调用。这里仅仅用于阐述原理。）<br><br><br></p><p><br>语法 <code>var.Name</code> 也仅是<br><code>var[“Name”]</code> 的语法糖：<br><br></p><pre>    var ::= prefixexp ‘<b>.</b>’ Name<br></pre><br><br><p><br>对全局变量 <code>x</code> 的访问等价于访问 <code>_ENV.x</code>。<br>由于按程序块编译所以，<code>_ENV</code> 本身并不是一个全局名称 （参见 <a href="#2.2">§2.2</a>）。<br><br><br><br></p><h2>3.3 – <a name="3.3">语句</a></h2><br><br><p><br>Lua 支持的常见语句类似Pascal或者C。包括赋值语句、控制语句、函数调用和变量声明。<br><br><br></p><h3>3.3.1 – <a name="3.3.1">语句块</a></h3><br><br><p><br>一个语句块就是一堆按顺序执行的语句：<br><br></p><pre>    block ::= {stat}<br></pre><p><br>Lua 允许 <em>empty statements（空语句）</em>，可以用分号隔开语句，也可用一个或者连续两个分号来作空语句块。<br><br></p><pre>    stat ::= ‘<b>;</b>’<br></pre><br><br><p><br>左括号表示函数调用和赋值语句。这有时会让 Lua 的语法产生歧义。比如下面这段代码：<br><br></p><pre>     a = b + c<br>     (print or io.write)(‘done’)<br></pre><p><br>有两种语法分析方式：<br><br></p><pre>     a = b + c(print or io.write)(‘done’)<br><br>     a = b + c; (print or io.write)(‘done’)<br></pre><p><br>现今的语法分析器经常以第一种方式解析这类写法。即把左括号解释成函数调用。要避免这种歧义，最好是在那些括号开头的语句前面写个分号：<br></p><pre>     ;(print or io.write)(‘done’)<br></pre><br><br><p><br>一个语句块也可以用下面的方式写成一条语句（写在 do 和 end 之间）：<br><br></p><pre>    stat ::= <b>do</b> block <b>end</b><br></pre><p><br>显示的语句块对控制变量的作用域很有用。有时也用于在其他语句块中插入 <b>return</b> 语句（参见see <a href="#3.3.4">§3.3.4</a>）。<br><br><br><br></p><h3>3.3.2 – <a name="3.3.2">程序块</a></h3><br><br><p><br><em>chunk（程序块）</em>就是 Lua 中的编译单元。从语法上讲，程序块就是简单的语句块。<br><br></p><pre>    chunk ::= block<br></pre><br><br><p><br>Lua 将程序块当作一个拥有可变参数的匿名函数来处理（参见 <a href="#3.4.10">§3.4.10</a>）。所以，程序块可以定义局部变量、接收参数并返回值。此外，这样的匿名函数被编译在一个叫 <code>_ENV</code> （参见 <a href="#2.2">§2.2</a>）的外部局部变量的作用域内。产生的函数常用 <code>_ENV</code> 作为唯一的自由变量，即便根本没用它。（译者注：说白了就是程序块相当于匿名函数，这些函数默认处于 <code>_ENV</code> 的命名空间中，使用时要写成 <code>_ENV.<strong>*</strong></code>。）<br><br><br></p><p><br>程序块可以存在单独的文件中，也可直接写在宿主程序的一个字符串中。执行程序块时，Lua 现将它预编译成虚拟机指令，然后由虚拟机的解释器来执行这些指令。<br><br><br></p><p><br>程序块也可被预编译成二进制形式；详情查阅程序 <code>luac</code>。源码形式和二进制形式的程序可以相互转换；Lua 会自动识别文件类型并做正确处理。<br><br><br><br><br></p><h3>3.3.3 – <a name="3.3.3">赋值</a></h3><br><br><p><br>Lua 允许多重赋值。因此，赋值的语法规定等号左边是一串变量，右边是一串表达式。串中的元素用等号隔开：<br><br></p><pre>    stat ::= varlist ‘<b>=</b>’ explist<br>    varlist ::= var {‘<b>,</b>’ var}<br>    explist ::= exp {‘<b>,</b>’ exp}<br></pre><p><br>表达式放在 <a href="#3.4">§3.4</a> 讨论。<br><br><br></p><p><br>赋值之前，会先根据左边变量的数量对右边值的数量进行调整。值多了，多余的将被丢弃；值少了，用 <b>nil</b> 补齐。如果右边最后是一个函数调用结尾，则在数量对齐之前用该函数的全部返回值替换它（除非函数调用位于括号内：参见 <a href="#3.4">§3.4</a>）。<br><br><br></p><p><br>赋值语句会首先执行所有表达式（两边），然后做纯粹的赋值。因此，下面这段代码<br><br></p><pre>     i = 3<br>     i, a[i] = i+1, 20<br></pre><p><br>把 <code>a[3]</code> 赋值为20而不是影响 <code>a[4]</code>，因为 <code>a[i]</code> 中的 <code>i</code> 在赋值为4之前已经确定（为3）。同样，这一行<br><br><br></p><pre>     x, y = y, x<br></pre><p><br>能用来交换 <code>x</code> 和 <code>y</code>的值，而且<br><br></p><pre>     x, y, z = y, z, x<br></pre><p><br>能循环交换 <code>x</code>，<code>y</code>，<code>z</code> 的值。<br><br><br></p><p><br>对全局变量和表的域赋值的含义能通过元表进行更改。对索引变量赋值，即 <code>t[i] = val</code> 等价于 <code>settable_event(t,i,val)</code>。（参见 <a href="#2.4">§2.4</a> 获取 <code>settable_event</code> 函数的完整描述。Lua 中并没有定义该函数，也不能调用。这里仅用于阐述原理。）<br><br><br></p><p><br>对全局变量赋值 <code>x = val</code> 等价于 <code>_ENV.x = val</code> （参见 <a href="#2.2">§2.2</a>）。<br><br><br><br></p><h3>3.3.4 – <a name="3.3.4">控制结构</a></h3><p><br><b>if</b>、<b>while</b> 和 <b>repeat</b> 等结构的意义和语法都很常见：<br><br><br></p><pre>    stat ::= <b>while</b> exp <b>do</b> block <b>end</b><br>    stat ::= <b>repeat</b> block <b>until</b> exp<br>    stat ::= <b>if</b> exp <b>then</b> block {<b>elseif</b> exp <b>then</b> block} [<b>else</b> block] <b>end</b><br></pre><p><br>Lua 也有 <b>for</b> 语句，并有两种形式（参见 <a href="#3.3.5">§3.3.5</a>）。<br><br><br></p><p><br>控制结构中的条件表达式可以返回任何值。只有 <b>false</b> 和 <b>nil</b> 才被当作条件假。其他任何值都被当作条件真（尤其注意数字 0 和空字符串也为真）。<br><br><br></p><p><br>在 <b>repeat</b>–<b>until</b> 循环中，内部语句不在 <b>until</b> 关键字处结束，而是在条件后面结束。所以，条件中可以使用循环体内声明的局部变量。<br><br><br></p><p><br><b>goto</b> 语句能将程序控制转移到一个标签处。从语法上讲，Lua 中的标签也被当作是语句：<br><br><br></p><pre>    stat ::= <b>goto</b> Name<br>    stat ::= label<br>    label ::= ‘<b>::</b>’ Name ‘<b>::</b>’<br></pre><br><br><p><br>标签在被定义的语句块内全部可见，除非在某个嵌套语句块的嵌套函数内定义了一个同名的标签。一个 goto 只要不进入局部变量作用域，它能跳转到任意可见的标签上。<br><br><br></p><p><br>标签可空语句叫作 <em>void statements</em>，表示它们本身没有任何行为。<br><br><br></p><p><br><b>break</b> 语句用于终止<br><b>while</b>、<b>repeat</b> 或 <b>for</b> 循环，并忽略循环体中剩下的语句：<br><br><br></p><pre>    stat ::= <b>break</b><br></pre><p><br><b>break</b> 能结束内层循环。<br><br><br></p><p><br><b>return</b> 语句用于从函数或程序块（伪装成函数）中返回值。<br><br>函数可以返回多个值。所以 <b>return</b> 语句的语法是：<br><br></p><pre>    stat ::= <b>return</b> [explist] [‘<b>;</b>’]<br></pre><br><br><p><br><b>return</b> 语句只能写作语句块的最后一句。如果在语句块中间确实需要 <b>return</b>，得显示使用内部语句块。习惯写成 <code>do return end</code>，于是这个<b>return</b> 在内层语句块中成了最后一句（这完全符合前面的规定）。<br><br><br><br><br><br></p><h3>3.3.5 – <a name="3.3.5">For 语句</a></h3><br><br><p><br><br><b>for</b> 语句有两种形式：数字形式和一般形式。<br><br><br></p><p><br>数字形式的 <b>for</b> 循环，控制量以等差数列变化来重复运行代码块。语法如下：<br><br></p><pre>    stat ::= <b>for</b> Name ‘<b>=</b>’ exp ‘<b>,</b>’ exp [‘<b>,</b>’ exp] <b>do</b> block <b>end</b><br></pre><p><br><br><em>block</em> 从 <em>name</em> 等于第一个 <em>exp</em> 开始重复运行。不断以第三个 <em>exp</em> 作为步长直到等于第二个 <em>exp</em> 才停止循环。更准确的说，一条 <b>for</b> 语句类似于：<br><br></p><pre>     for v = <em>e1</em>, <em>e2</em>, <em>e3</em> do <em>block</em> end<br></pre><p><br>等价于如下代码：<br><br></p><pre>     do<br>       local <em>var</em>, <em>limit</em>, <em>step</em> = tonumber(<em>e1</em>), tonumber(<em>e2</em>), tonumber(<em>e3</em>)<br>       if not (<em>var</em> and <em>limit</em> and <em>step</em>) then error() end<br>       while (<em>step</em> &gt; 0 and <em>var</em> &lt;= <em>limit</em>) or (<em>step</em> &lt;= 0 and <em>var</em> &gt;= <em>limit</em>) do<br>         local v = <em>var</em><br>         <em>block</em><br>         <em>var</em> = <em>var</em> + <em>step</em><br>       end<br>     end<br></pre><p><br>注意事项：<br><br></p><ul><br><br><li><br>所有三个控制表达式在循环前仅被求值一次。它们的结果必须为数字。<br></li><br><br><li><br><code><em>var</em></code>、<code><em>limit</em></code> 和 <code><em>step</em></code> 都是不可见变量。这里的名字仅用作解释说明。<br></li><br><br><li><br>如果省略第三个表达式（步长），则步长默认为 1.<br></li><br><br><li><br>可以使用 <b>break</b> 来跳出 <b>for</b> 循环。<br></li><br><br><li><br>循环量 <code>v</code> 是循环内部的局部变量：不能在 <b>for</b> 循环结束或跳出后继续使用它的值。如果确实需要该值，请在循环退出或跳出之前把值赋给另外的变量。<br></li><br><br></ul><br><br><p><br>一般形式的 <b>for</b> 语句通过叫 <em>iterators（迭代器）</em> 的函数工作。每一次迭代，都会调用迭代器来产生一个新值。当新值为 <b>nil</b> 时，循环停止。一般形式的 <b>for</b> 循环语法如下：<br><br></p><pre>    stat ::= <b>for</b> namelist <b>in</b> explist <b>do</b> block <b>end</b><br>    namelist ::= Name {‘<b>,</b>’ Name}<br></pre><p><br>一条 <b>for</b> 语句类似于<br><br></p><pre>     for <em>var_1</em>, ···, <em>var_n</em> in <em>explist</em> do <em>block</em> end<br></pre><p><br>等价于如下代码：<br><br></p><pre>     do<br>       local <em>f</em>, <em>s</em>, <em>var</em> = <em>explist</em><br>       while true do<br>         local <em>var_1</em>, ···, <em>var_n</em> = <em>f</em>(<em>s</em>, <em>var</em>)<br>         if <em>var_1</em> == nil then break end<br>         <em>var</em> = <em>var_1</em><br>         <em>block</em><br>       end<br>     end<br></pre><p><br>注意事项：<br><br></p><ul><br><br><li><br><code><em>explist</em></code> 仅被求值一次。其结果有三：一个 <em>iterator（迭代器）</em> 函数，一个 <em>state（状态）</em>和首个 <em>iterator variable（迭代量）</em>的初始值。<br></li><br><br><li><br><code><em>f</em></code>、<code><em>s</em></code> 和 <code><em>var</em></code> 都是不可见变量。这里的名字仅用作解释说明。<br></li><br><br><li><br>可以使用 <b>break</b> 来跳出 <b>for</b> 循环。<br></li><br><br><li><br>循环量 <code><em>var_i</em></code> 是循环体内的局部变量：不能在 <b>for</b> 循环结束后继续使用它的值。如果确实需要该值，请在循环退出或跳出之前把值赋给另外的变量。<br></li><br><br></ul><br><br><br><br><br><h3>3.3.6 – <a name="3.3.6">函数调用作为语句</a></h3><p><br>为了允许使用可能的副作用，函数调用可当作语句执行：<br><br></p><pre>    stat ::= functioncall<br></pre><p><br>这种情况下，所有的返回值均被丢弃。关于函数调用的说明在 <a href="#3.4.9">§3.4.9</a>。<br><br><br><br><br><br></p><h3>3.3.7 – <a name="3.3.7">局部声明</a></h3><p><br>局部变量可在语句块内任何地方声明。声明的同时可以进行初始化赋值操作：<br><br></p><pre>    stat ::= <b>local</b> namelist [‘<b>=</b>’ explist]<br></pre><p><br>如果做了，初始化赋值操作在语法上等同于多重赋值（see <a href="#3.3.3">§3.3.3</a>）。否则，所有变量均被初始化为 <b>nil</b>。<br><br><br></p><p><br>程序块也是语句块（参见 <a href="#3.3.2">§3.3.2</a>），因此局部变量可在任何显示语句块之外的程序块中声明。<br><br><br></p><p><br>局部变量的可见性规则在 <a href="#3.5">§3.5</a> 说明。<br><br><br><br><br></p><h2>3.4 – <a name="3.4">表达式</a></h2><br><br><p><br>Lua 中的基本表达式如下：<br><br></p><pre>    exp ::= prefixexp<br>    exp ::= <b>nil</b> | <b>false</b> | <b>true</b><br>    exp ::= Number<br>    exp ::= String<br>    exp ::= functiondef<br>    exp ::= tableconstructor<br>    exp ::= ‘<b>…</b>’<br>    exp ::= exp binop exp<br>    exp ::= unop exp<br>    prefixexp ::= var | functioncall | ‘<b>(</b>’ exp ‘<b>)</b>’<br></pre><br><br><p><br>数字和文字串的说明在 <a href="#3.1">§3.1</a>；<br>变量的说明在 <a href="#3.2">§3.2</a>；<br>函数定义的介绍在 <a href="#3.4.10">§3.4.10</a>；<br>函数调用的说明在 <a href="#3.4.9">§3.4.9</a>；<br>表的构造器在 <a href="#3.4.8">§3.4.8</a>。<br>由三点（’<code>…</code>‘）表示的可变参数表达式只能用于有可变参数的函数中：详见 <a href="#3.4.10">§3.4.10</a>。<br><br><br></p><p><br>二元运算包括算术运算（<a href="#3.4.1">§3.4.1</a>）、关系运算（<a href="#3.4.3">§3.4.3</a>）、逻辑运算（<a href="#3.4.4">§3.4.4</a>）以及连接运算（<a href="#3.4.5">§3.4.5</a>）。一元运算包括取负（<a href="#3.4.1">§3.4.1</a>）、<b>not</b>（<a href="#3.4.4">§3.4.4</a>）和 <em>取长度</em> （<a href="#3.4.6">§3.4.6</a>）。<br><br><br></p><p><br>函数调用和参数可变的表达式均可返回多个值。如果将函数调用作为一条语句使用（参见<a href="#3.3.6">§3.3.6</a>），则其返回值列表与0对齐，即丢弃所有返回值。如果一个表达式是一串表达式中最后的/唯一的元素，则不会有对齐操作（除非该表达式位于括号内）。在其他情况，Lua 会将返回结果表与1对齐，即丢弃第一个返回值外的其他值；如果没有返回值，Lua 自动添加一个 <b>nil</b>。<br><br><br></p><p><br>以下是一些示例：<br><br></p><pre>     f()                – 调整成 返回0 个结果<br>     g(f(), x)          – f() 被调整成返回 1 个结果<br>     g(x, f())          – g 被传入 x 和所有 f() 返回值<br>     a,b,c = f(), x     – f() 被调整成返回 1 个结果（c 就成了 nil）<br>     a,b = …          – a 被赋值为可变参数中的第一个，<br>                        – b 为第二个（如果可变参数没有对应参数，a 和 b 都为 nil ）<br><br>     a,b,c = x, f()     – f() 被调整成返回 2 个结果<br>     a,b,c = f()        – f() 被调整成返回 3 个结果<br>     return f()         – 返回 f() 所有结果<br>     return …         – 返回可变参数接收到的所有参数<br>     return x,y,f()     – 返回 x、y、和所有 f() 返回值<br>     {f()}              – 为 f() 的所有返回值创建一个列表<br>     {…}              – 为可变参数接收到的所有参数创建一个列表<br>     {f(), nil}         – f() 被调整成返回 1 个结果<br></pre><br><br><p><br>任何由括号括起来的表达式只被当成一个值。因此，<code>(f(x,y,z))</code> 永远都只能是个单值，即使 <code>f</code> 返回了多个值。（<code>(f(x,y,z))</code> 的值是 <code>f</code> 返回的第一个值；如果 <code>f</code> 没有返回值，则为 <b>nil</b>。）<br><br><br><br></p><h3>3.4.1 – <a name="3.4.1">算术运算符</a></h3><p><br>Lua 支持常用算术运算符： <code>+</code>（加）、<code>-</code>（减）、<code><em></em></code>（乘）、<code>/</code>（除）、<code>%</code>（取模）和  <code>^</code>（幂）；还有一元<code>-</code>（取负）操作。如果运算对象是数字，或是可转换为数字的字符串（参见 <a href="#3.4.2">§3.4.2</a>），那就是单纯的数学运算。求幂操作可用于任何指数，比如 <code>x^(-0.5)</code> 计算出 <code>x</code> 平方根的倒数。取模操作的定义是<br><br></p><pre>     a % b == a - math.floor(a/b)b<br></pre><p><br>That is, it is the remainder of a division that rounds<br>the quotient towards minus infinity.<br><br><br><br><br><br></p><h3>3.4.2 – <a name="3.4.2">强制转换</a></h3><br><br><p><br>Lua 在运行时提供字符串与数字之见的自动转换。在 Lua<br>的词法分析下，任何适用字符串的算术运算都会尝试把字符串转化为数字。（字符串首尾可能有空白和标记。）反过来，任何需要字符串的时候，数字就会被转化成<br>字符串。想要完全掌控数字转化字符串，可以使用 string 库中的 <code>format</code> 函数（参见 <a href="#pdf-string.format"><code>string.format</code></a>）。<br><br><br><br></p><h3>3.4.3 – <a name="3.4.3">关系运算符</a></h3><p><br>Lua 中的关系运算符有<br></p><pre>     ==    ~=    &lt;     &gt;     &lt;=    &gt;=<br></pre><p><br>运算结果为 <b>false</b> 或者 <b>true</b>.<br><br><br></p><p><br>相等判断（<code>==</code>）首先比较运算对象的类型。如果类型不同，则结果为 <b>false</b>。否则才比较对象的值。数字、字<br>符串用常规方式比较。而表、用户数据和线程得靠引用来比较：两个对象只在指向（引用）同一个对象才判为相等。每一次创建的新对象（表、用户数据或者线程）<br>都与前面存在的对象不同。对相同引用的闭包互相相等。而任何可检测出不同（行为不同、定义不同）的闭包自然也不相等。<br><br><br></p><p><br>当然，你可以使用 “eq” 元方法（参见 <a href="#2.4">§2.4</a>）来改变表与用户数据的比较操作。<br><br><br></p><p><br> <a href="#3.4.2">§3.4.2</a> 的转换规则不适用于相等性判断操作。因此， <code>“0”==0</code> 值为 <b>false</b>。<code>t[0]</code> 和 <code>t[“0”]</code> 代表的是表中不同的元素。<br><br><br></p><p><br><code>~=</code> 操作符刚好与 <code>==</code> 意义相反。<br><br><br></p><p><br>大小比较的规则如下：如果比较参数都为数字，则做数字比较；如果都为字符串，则按字符串比较规则进行；否则，Lua 就尝试使用 “lt” 或 “le” 元方法（参见 <a href="#2.4">§2.4</a>）。<code>a &gt; b</code> 被翻译成 <code>b &lt; a</code>，<code>a &gt;= b</code> 被翻译成 <code>b &lt;= a</code>。<br><br><br><br></p><h3>3.4.4 – <a name="3.4.4">逻辑运算符</a></h3><p><br>Lua 中的逻辑运算符有 <b>and</b>、<b>or</b>、和 <b>not</b>。类似控制结构（参见 <a href="#3.3.4">§3.3.4</a>），所有的逻辑操作符只将 <b>false</b> 和 <b>nil</b> 当作假，其他所有情况都为真。<br><br><br></p><p><br>取反操作 <b>not</b> 只返回 <b>false</b> 或者 <b>true</b>。与操作 <b>and</b> 在第一个参数为 <b>false</b> 或 <b>nil</b> 时返回第一个参数，否则返回第二个参数。或操作 <b>or</b> 在第一个参数不是 <b>nil</b> 和 <b>false</b> 时返回第一个参数。否则返回第二个参数。<b>and</b> 和 <b>or</b> 都使用短路求值法；意思是第二个参数只在必要时才求值。下面是些例子：<br><br></p><pre>     10 or 20            –&gt; 10<br>     10 or error()       –&gt; 10<br>     nil or “a”          –&gt; “a”<br>     nil and 10          –&gt; nil<br>     false and error()   –&gt; false<br>     false and nil       –&gt; false<br>     false or nil        –&gt; nil<br>     10 and 20           –&gt; 20<br></pre><p><br>（本手册中的 <code>–&gt;</code> 符号指代前面表达式的结果。）<br><br><br><br><br><br></p><h3>3.4.5 – <a name="3.4.5">连接操作</a></h3><p><br>Lua 使用两个点（’<code>..</code>‘）表示字符串连接操作。如果操作对象是字符串和数字，则会按照 <a href="#3.4.2">§3.4.2</a> 提到的规则将他们转化为字符串。不然就调用 <code>concat</code> 元方法（参见 <a href="#2.4">§2.4</a>）。<br><br><br><br><br><br></p><h3>3.4.6 – <a name="3.4.6">取长度操作符</a></h3><br><br><p><br>取长度的操作符是一元运算符 <code>#</code>。字符串的长度是其字节数（就是一个字符表示一个字节算出的长度）。<br><br><br></p><p><br>程序里可通过 <code><strong>len</strong></code> 元方法（参见 <a href="#2.4">§2.4</a>）来修改除字符串外所有值的取长度操作行为。<br><br><br></p><p><br>除了已知的 <code>len</code> 元方法，表 <code>t</code> 的长度只在它是<em>顺序</em>表时有定义。而且其键值要按 <em>{1..n}</em> 递增，则整数 <em>n</em> 就是长度。注意像下面这样的表<br><br></p><pre>     {10, 20, nil, 40}<br></pre><p><br>不是顺序表，因为它有第 <code>4</code> 个键，却没有第 <code>3</code> 个键。而非数字键则不影响判断表是否为顺序表。<br><br><br><br><br></p><h3>3.4.7 – <a name="3.4.7">优先级</a></h3><p><br>Lua 中操作符优先级如下表所示，从低到高排列：<br><br></p><pre>     or<br>     and<br>     &lt;     &gt;     &lt;=    &gt;=    ~=    ==<br>     ..<br>     +     -<br>     <em>     /     %<br>     not   #     - (unary)<br>     ^<br></em></pre><p><br>通常，可以在表达式中使用括号来改变优先级。连接符（’<code>..</code>‘）和求幂（’<code>^</code>‘）从右往左结合。其他二元运算符是从左往右的。<br><br><br><br><br><br></p><h3>3.4.8 – <a name="3.4.8">表的构造器</a></h3><p><br>表的构造器是一对用于创建表的表达式。每执行一次构造器就创建一张新表。构造器可用于创建空表或者创建的同时初始化一些域。构造器的语法如下：<br><br></p><pre>    tableconstructor ::= ‘<b>{</b>’ [fieldlist] ‘<b>}</b>’<br>    fieldlist ::= field {fieldsep field} [fieldsep]<br>    field ::= ‘<b>[</b>’ exp ‘<b>]</b>’ ‘<b>=</b>’ exp | Name ‘<b>=</b>’ exp | exp<br>    fieldsep ::= ‘<b>,</b>’ | ‘<b>;</b>’<br></pre><br><br><p><br> 每一个 <code>[exp1] = exp2</code> 形式的域都将为新表加入一个键为 <code>exp1</code> 值为 <code>exp2</code> 的元素。<code>name = exp</code> 形式的域等价于 <code>[“name”] = exp</code>。而 <code>exp</code> 形式的域等价于 <code>[i] = exp</code>，其中的 <code>i</code> 为从 1 开始的连续整数。其他格式的域不影响计数。比如，<br><br></p><pre>     a = { [f(1)] = g; “x”, “y”; x = 1, f(x), [30] = 23; 45 }<br></pre><p><br>等价于<br><br></p><pre>     do<br>       local t = {}<br>       t[f(1)] = g<br>       t[1] = “x”         – 1st exp<br>       t[2] = “y”         – 2nd exp<br>       t.x = 1            – t[“x”] = 1<br>       t[3] = f(x)        – 3rd exp<br>       t[30] = 23<br>       t[4] = 45          – 4th exp<br>       a = t<br>     end<br></pre><br><br><p><br>如果列表中最后一个域形式为 <code>exp</code>，而且这个表达式是个函数调用或者参数可变，那么表达式的所有返回值将按顺序插入列表（参见 <a href="#3.4.9">§3.4.9</a>）。<br><br><br></p><p><br>域的列表可以有一个可选的尾部分隔符，这样方便机器生成代码。<br><br><br><br><br></p><h3>3.4.9 – <a name="3.4.9">函数调用</a></h3><p><br>Lua 中的函数调用语法如下：<br><br></p><pre>    functioncall ::= prefixexp args<br></pre><p><br>在函数调用中，首先对 prefixexp 和 args 求值。如果 prefixexp 的值的也是 <em>function（函数）</em>，则用相应参数调用该函数。否则，调用 prefixexp 的 “call” 元方法，并将 prefixexp 的值作第一个参数，再跟其他原始参数（参见 <a href="#2.4">§2.4</a>）。<br><br><br></p><p><br>这种形式<br><br></p><pre>    functioncall ::= prefixexp ‘<b>:</b>’ Name args<br></pre><p><br>可以用来调用“方法”。 <code>v.name(v,<em>args</em>)</code> 只在 <code>v</code> 仅被求值一次的时候可以写成 <code>v:name(<em>args</em>)</code>，这种写法只是语法糖便利。<br><br><br></p><p><br>参数的语法如下：<br><br></p><pre>    args ::= ‘<b>(</b>’ [explist] ‘<b>)</b>’<br>    args ::= tableconstructor<br>    args ::= String<br></pre><p><br>所有参数表达式都在函数调用之前被求值。<code>f{<em>fields</em>}</code> 形式的函数调用也只是 <code>f({<em>fields</em>})</code> 形式的语法糖写法；即参数列表是个新表。而 <code>f’<em>string</em>‘</code><br>（或者 <code>f”<em>string</em>“</code> 或者 <code>f[[<em>string</em>]]</code>）一类的调用形式也只是 <code>f(‘<em>string</em>‘)</code> 的语法糖写法；即参数表是单一的文字串。<br><br><br></p><p><br>Lua 中将 <code>return <em>functioncall</em></code> 这种形式叫 <em>tail call（尾调用）</em>。Lua 实现的是<em>完全尾调用</em>（也叫完全尾递归）：在尾调用中，被调用的函数重用调用它的函数的堆栈。因此，程序可执行的嵌套尾调用没有层数限制（即无限尾调用）。而尾调用也会删除任何关于调用它的函数的调试信息。注意，尾调用只能出现在特殊的语法下：<b>return</b> 只有一个函数作为参数；这使得调用函数能明确返回被调函数的结果。所以，下面这些都不是尾调用：<br><br></p><pre>     return (f(x))        – results adjusted to 1<br>     return 2  f(x)<br>     return x, f(x)       – additional results<br>     f(x); return         – results discarded<br>     return x or f(x)     – results adjusted to 1<br></pre><br><br><br><br><br><h3>3.4.10 – <a name="3.4.10">函数定义</a></h3><br><br><p><br>函数定义的语法如下：<br><br></p><pre>    functiondef ::= <b>function</b> funcbody<br>    funcbody ::= ‘<b>(</b>’ [parlist] ‘<b>)</b>’ block <b>end</b><br></pre><br><br><p><br>下面的语法糖写法可以简化函数的定义：<br><br></p><pre>    stat ::= <b>function</b> funcname funcbody<br>    stat ::= <b>local</b> <b>function</b> Name funcbody<br>    funcname ::= Name {‘<b>.</b>’ Name} [‘<b>:</b>’ Name]<br></pre><p><br>语句<br><br></p><pre>     function f () <em>body</em> end<br></pre><p><br>转化成<br><br></p><pre>     f = function () <em>body</em> end<br></pre><p><br>语句<br><br></p><pre>     function t.a.b.c.f () <em>body</em> end<br></pre><p><br>转化成<br><br></p><pre>     t.a.b.c.f = function () <em>body</em> end<br></pre><p><br>语句<br><br></p><pre>     local function f () <em>body</em> end<br></pre><p><br>转化成<br><br></p><pre>     local f; f = function () <em>body</em> end<br></pre><p><br>而不是转化成<br><br></p><pre>     local f = function () <em>body</em> end<br></pre><p><br>（这只在函数体内需要引用 <code>f</code> 时才有点区别。）<br><br><br></p><p><br>函数定义是一个可执行表达式，执行结果是个类型为 <em>function</em>的值。Lua 预编译 chunk（程序块）时，它的所有函数体也会被预编译。每当 Lua 执行函数定义，函数才被 <em>instantiated（实例化）</em> （也叫 <em>closed（闭合）</em>）。这个函数实例（也叫<em>closure（闭包）</em>）才是表达式最终的值。<br><br><br></p><p><br>形参（函数定义的参数）作为局部变量由实参（函数调用时传入的参数）的值初始化：<br><br></p><pre>    parlist ::= namelist [‘<b>,</b>’ ‘<b>…</b>’] | ‘<b>…</b>’<br></pre><p><br>调用函数时，实参列表会根据形参列表的长度做调整，除非遇上了形参列表以三点（’<code>…</code>‘）结尾的 <em>vararg function（变参函数）</em>。变参函数不会调整实参列表，而是收集所有额外的实参然后通过 <em>vararg expression（变参表达式）</em>（也写成 ‘<code>…</code>‘）<br>传给函数。变参表达式的值就是包含全部额外实参的列表，这类似返回多值的函数。如果变参表达式在另一个表达式中使用，或者是位于一堆表达式的中间，那么它<br>返回的值会被调整成单个元素。而若是该表达式是那堆表达式的最后一个，那就不用做调整了（除非最后的表达式位于括号之内）。<br><br></p><p><br>先看下面这个函数定义的例子：<br><br></p><pre>     function f(a, b) end<br>     function g(a, b, …) end<br>     function r() return 1,2,3 end<br></pre><p><br>然后有如下实参到形参和变参表达式的映射关系：<br><br></p><pre>     CALL            PARAMETERS<br><br>     f(3)             a=3, b=nil<br>     f(3, 4)          a=3, b=4<br>     f(3, 4, 5)       a=3, b=4<br>     f(r(), 10)       a=1, b=10<br>     f(r())           a=1, b=2<br><br>     g(3)             a=3, b=nil, … –&gt;  (nothing)<br>     g(3, 4)          a=3, b=4,   … –&gt;  (nothing)<br>     g(3, 4, 5, 8)    a=3, b=4,   … –&gt;  5  8<br>     g(5, r())        a=5, b=1,   … –&gt;  2  3<br></pre><br><br><p><br><b>return</b> 语句用于返回结果（参见 <a href="#3.3.4">§3.3.4</a>）。如果执行到函数结尾没发现一个 <b>return</b> 语句，则函数没有结果返回。<br><br><br></p><p><br>一个函数能返回的结果数量因系统不同而限制不同，但肯定大于1000。<br><br><br></p><p><br><br><em>colon（冒号）</em> 语法用于定义 <em>methods（方法）</em>。意思是函数有一个额外的隐式参数 <code>self</code>。所以，如下语句<br><br></p><pre>     function t.a.b.c:f (<em>params</em>) <em>body</em> end<br></pre><p><br>是如下写法的语法糖（简写）形式<br><br></p><pre>     t.a.b.c.f = function (self, <em>params</em>) <em>body</em> end<br></pre><br><br><br><br><br><br><br><h2>3.5 – <a name="3.5">可见性规则</a></h2><br><br><p><br>Lua 是门有词法域的语言。一个局部变量的作用域开始于声明后的第一条语句，结束于包含该声明的最内层语句块中的最后一条非空语句。思考下面的例子：<br><br></p><pre>     x = 10                – 全局变量<br>     do                    – 新语句块开始<br>       local x = x         – 新的 ‘x’，值为 10<br>       print(x)            –&gt; 10<br>       x = x+1<br>       do                  – 另一个语句块开始<br>         local x = x+1     – 另一个 ‘x’<br>         print(x)          –&gt; 12<br>       end<br>       print(x)            –&gt; 11<br>     end<br>     print(x)              –&gt; 10（此为全局的那一个）<br></pre><br><br><p><br>留心注意，类似 <code>local x = x</code> 的声明，新声明的 <code>x</code> 还不在作用域内（译者注：作用域开始于声明语句的下一句，不包括声明语句本身），所以后面的 <code>x</code> 还是指那个外层变量。<br><br><br></p><p><br>因为有词法域规则，所以函数可随意访问定义在其作用域内的局部变量。局部变量被更内层的函数使用，则称其为 <em>upvalue</em>，或者是 <em>external local variable（外层局部变量）</em>。<br><br><br></p><p><br>要注意，每执行一次 <b>local</b> 语句都会定义新的局部变量。思考下面的例子：<br><br></p><pre>     a = {}<br>     local x = 20<br>     for i=1,10 do<br>       local y = 0<br>       a[i] = function () y=y+1; return x+y end<br>     end<br></pre><p><br>这个循环创建了十个 closures（闭包，这里指十个匿名函数实例）。每一个 closure 使用的都是不同的 <code>y</code> ，相同的 <code>x</code>。<br><br><br><br><br><br></p><h1>4 – <a name="4">应用程序接口（API）</a></h1><br><br><p><br>本章描述 Lua 中的 C&nbsp;API，就是那些用于宿主程序和 Lua 通讯的 C 函数。所有 API 函数和相关的类型/常量定义都在 <a name="pdf-lua.h"><code>lua.h</code></a> 头文件中。<br><br><br></p><p><br>虽然我们说的是“函数”，但某些 API 其实是以宏的形式提供的。除非特别说明，所有这些宏对它们的参数都只使用一次（除了常为 Lua 状态机的第一个参数），所以不用担心这些宏的展开会隐藏一些副作用。<br><br><br></p><p><br>在大部分 C 库中，Lua 的 API 函数都不会检查参数的有效性和一致性。但你可以在编译 Lua 时通过内置的宏 <a name="pdf-LUA_USE_APICHECK"><code>LUA_USE_APICHECK</code></a> 来改变这个设定。<br><br><br></p><h2>4.1 – <a name="4.1">栈</a></h2><br><br><p><br>Lua 使用一个 <em>virtual stack（虚拟栈）</em> 来与 C 传递值。栈内每个元素都代表一个 Lua 值（<b>nil</b>、数字、字符串等等）。<br><br><br></p><p><br>任何时候 Lua 调用 C 函数，被调函数都会获得一个新栈。该栈独立于以前的栈，也独立于函数在 C 中的栈。这个栈初始时包含传递给 C 函数的所有参数，然后 C 函数把要返回给调用者的结果也压入其中（参见 <a href="#lua_CFunction"><code>lua_CFunction</code></a>）。<br><br><br></p><p><br>为方便起见，API 中大部分查询操作都不严格遵守常规栈的规则。而是可以通过一个 <em>index</em> 来索引栈中任意元素。一个正的索引值表示了栈中的绝对位置（从 1 开始）；负的索引值表示了相对栈顶的偏移量。具体来说，如果栈有 <em>n</em> 个元素，则索引 1 代表第一个元素（就是第一个压入栈的元素，在栈底），索引 <em>n</em> 代表最后一个元素；而索引 -1 也代表最后一个元素（就是栈顶元素），索引 <em>-n</em> 代表第一个元素。<br><br><br><br><br><br></p><h2>4.2 – <a name="4.2">栈大小</a></h2><br><br><p><br>与 Lua 交互时，要负责确保一致性。尤其要 <em>负责控制栈的溢出情况</em>。在压栈前可以使用函数 <a href="#lua_checkstack"><code>lua_checkstack</code></a> 来检查栈中是否拥有足够的位置。<br><br><br></p><p><br>Lua 无论何时调用 C，它都确保栈至少拥有 <a name="pdf-LUA_MINSTACK"><code>LUA_MINSTACK</code></a> 个位置。<code>LUA_MINSTACK</code> 被定义为 20。所以，只要不是循环压栈，通常无需担心栈空间。<br><br><br></p><p><br>调用一个返回结果数量不定的 Lua 函数（参见 <a href="#lua_call"><code>lua_call</code></a>）时，Lua 会确保栈空间足够容纳所有返回结果，但不确保还有更多额外空间。所以，在调用了这种函数后，继续压栈前最好使用 <a href="#lua_checkstack"><code>lua_checkstack</code></a> 检查一下栈空间。<br><br><br><br><br><br></p><h2>4.3 – <a name="4.3">有效索引与合格索引</a></h2><br><br><p><br>API 中的任何能接受栈索引的函数只接受 <em>valid indices（有效索引）</em> 或 <em>acceptable indices（合格索引）</em>。<br><br><br></p><p><br><em>有效索引</em> 指的是指向栈内真实位置的索引，意思是其值在 1 和栈顶之间（即<code>1 ≤ abs(index) ≤ top</code>）。通常，函数要修改某个索引项的值时就要求有效索引。<br><br><br></p><p><br>除非另有提示，任何接受有效索引的函数同时也接受 <em>pseudo-indices（伪索引）</em>，帮助 C 代码访问一些不在栈内的 Lua 值。伪索引可用于访问注册表和 C 函数的 upvalues（参见 <a href="#4.4">§4.4</a>）。<br><br><br></p><p><br>那种不需具体位置只要栈内一个值的函数（比如，查询函数）可以用合格索引进行调用。一个 <em>acceptable index（合格索引）</em> 可为任意有效索引，包括伪索引，也可为栈空间内栈顶之后的任和正索引，意味着索引值最大为栈的大小。（注意，0 从来都不是合格索引。）除非特殊说明，API 中的函数只在合格索引下有效工作。<br><br><br></p><p><br>合格索引在查询栈的时候避免了额外的栈顶判断。例如，一个 C 函数可以查询它的第三个参数而不必先检查是否存在第三个参数，意思是不必检查索引 3 是否有效。<br><br><br></p><p><br>对于那些能用合格索引调用的函数，任何无效索引都被当作成包含一个虚拟类型为 <a name="pdf-LUA_TNONE"><code>LUA_TNONE</code></a> 的值，其行为类似一个 nil 值。<br><br><br><br><br><br></p><h2>4.4 – <a name="4.4">C Closures（闭包）</a></h2><br><br><p><br>创建一个 C 函数时，可能会关联一些值，因此就创建了一个 <em>C&nbsp;closure</em>（参见 <a href="#lua_pushcclosure"><code>lua_pushcclosure</code></a>），那些值就叫 <em>upvalues</em>，并且可在函数被调用时访问到。<br><br><br></p><p><br>每当调用 C 函数时，它的 upvalue 就被放在特定的伪索引处。这些伪索引由宏 <a href="#lua_upvalueindex"><code>lua_upvalueindex</code></a> 产生。与函数相关的第一个值在 <code>lua_upvalueindex(1)</code> 处，并依此类推。当 <em>n</em> 大于当前函数中 upvalue 的数量（小于 256）时， <code>lua_upvalueindex(<em>n</em>)</code> 将产生合格但无效的索引值。<br><br><br><br><br><br></p><h2>4.5 – <a name="4.5">注册表</a></h2><br><br><p><br>Lua 提供一个 <em>registry（注册表）</em>，是一张用于 C 代码保存所需 Lua 值的预定义表。注册表位于伪索引 <a name="pdf-LUA_REGISTRYINDEX"><code>LUA_REGISTRYINDEX</code></a><br> 处，这是一个有效索引。任何 C<br>库都可以向表中保存数据，只是在选择键的时候要避免和其他库冲突。一般来说，可以用包含库名的字符串，或者用代码中一个 C 对象的地址做成的简易<br>userdata，或者用代码中创建的任意 Lua 对象。（译者注：键的形式很随意，不局限于字符串，可详细参考 table<br>类型。）与全局变量一样，以下划线开头跟大写字母的字符串键是为 Lua 保留的。<br><br><br></p><p><br>注册表内的整数键用作引用机制，在辅助库中实现时也使用一些预定义值。因此，整数键不能做他用。<br><br><br></p><p><br>创建一个新的 Lua 状态机时，它的注册表来自于一些预定义的值。这些预定义值作为常量定义在 <code>lua.h</code>，由整数键进行索引。<br>下面的常量定义：<br><br></p><ul><br><li><b><a name="pdf-LUA_RIDX_MAINTHREAD"><code>LUA_RIDX_MAINTHREAD</code></a>：</b>该索引下，注册表拥有状态机的主线程（主线程与状态机同时被创建）。<br></li><br><br><li><b><a name="pdf-LUA_RIDX_GLOBALS"><code>LUA_RIDX_GLOBALS</code></a>：</b> 该索引下，注册表拥有全局环境。<br></li><br></ul><br><br><br><br><br><h2>4.6 – <a name="4.6">C 中的错误处理</a></h2><br><br><p><br>在内部实现中，Lua 使用 C 的 <code>longjmp</code> 机制来处理错误。（如果 Lua 和 C++ 编译，也可以选择使用异常；查阅源码内的 <code>LUAI_THROW</code>。）Lua 面对任何错误（比如内存分配错误、类型错误、语法错误和运行时错误）都会产生一个错误；就是做一个 long jump。在 <em>protected environment（保护环境）</em>下使用 <code>setjmp</code> 可以设置一个恢复点；任何错误都会跳转到最近活动的恢复点上。<br><br><br></p><p><br>如果错误发生在保护环境之外，Lua 会调用一个 <em>panic 函数</em>（参见 <a href="#lua_atpanic"><code>lua_atpanic</code></a>），然后调用 <code>abort</code>来退出宿主程序。panic 函数也可以不返回来避免这种退出（比如，做一个 long jump 跳转到 Lua 之外你自己的恢复点上）。<br><br><br></p><p><br>panic 函数运行起来就像一个消息处理器（参见 <a href="#2.3">§2.3</a>）；尤其是错误消息位于栈顶时。问题在于没法保证栈的空间。向栈内压入任何东西，panic 函数都需要先检查可用空间（参见 <a href="#4.2">§4.2</a>）。<br><br><br></p><p><br>API 中大部分函数都能抛出错误，比如内存分配错误。每个函数的文档内具体指示了它是否能抛出错误。<br><br><br></p><p><br>在 C 函数内可以通过调用 <a href="#lua_error"><code>lua_error</code></a> 来抛出一个错误。<br><br><br><br><br><br></p><h2>4.7 – <a name="4.7">C 中的挂起处理</a></h2><br><br><p><br>在内部实现中，Lua 使用 C的 <code>longjmp</code> 机制来挂起协程。因此，如果函数 <code>foo</code> 调用一个 API 函数，而该 API 函数挂起了（直接或间接挂起），Lua 没法给 <code>foo</code> 返回任何东西，因为 <code>longjmp</code> 已将它的 frame 从 C 栈中移除了。<br><br><br></p><p><br>为避免这类问题，每当通过 API 调用而挂起时 Lua 都会弹出错误，只除了这三个函数：<a href="#lua_yieldk"><code>lua_yieldk</code></a>、<a href="#lua_callk"><code>lua_callk</code></a> 和 <a href="#lua_pcallk"><code>lua_pcallk</code></a>。这三个函数接收一个 <em>continuation function（继续函数）</em>（有一个参数叫 <code>k</code>）用于挂起后继续执行。<br><br><br></p><p><br>我们需要用一些术语来解释这个 continuation。首先，我们有一个由 Lua 调用的 C 函数，它叫 <em>original function（原始函数）</em>。这个原始函数随后在 C API 内调用了前面三个函数中的一个，叫 <em>callee function（被调函数）</em>，然后当前线程被挂起。（挂起可能发生在被调函数是 <a href="#lua_yieldk"><code>lua_yieldk</code></a>时，或者被调函数是 <a href="#lua_callk"><code>lua_callk</code></a> 或 <a href="#lua_pcallk"><code>lua_pcallk</code></a>二者其一而且被自己挂起。）<br><br><br></p><p><br>假定是在执行被调函数时运行的线程被挂起。等线程恢复后，它最终会结束运行被调函数。然而，被调函数此时却没法返回给原始函数，因为它在 C 栈中的 frame 在挂起时给销毁了。于是，Lua 调用当作参数传递给被调函数的 <em>continuation function（继续函数）</em>。顾名思义，继续函数可以继续原始函数的工作。<br><br><br></p><p><br>Lua 将继续函数看作原始函数。继续函数接收来源于原始函数的相同 Lua 栈，在被调函数返回后也（与原始函数）处于一样的状态。（例如，<a href="#lua_callk"><code>lua_callk</code></a> 调用一个函数后，它的参数均从栈中移除并被替换成那个函数的返回结果。）继续函数也拥有相同的 upvalue。无论继续函数返回什么值，都会被 Lua 当作是由原始函数返回的一样进行处理。<br><br><br></p><p><br>在 Lua 状态机中，原始函数与它的继续函数唯一的不同就是 <a href="#lua_getctx"><code>lua_getctx</code></a> 返回结果的不同。<br><br><br><br><br><br></p><h2>4.8 – <a name="4.8">函数与类型</a></h2><br><br><p><br>我们在这儿按字母顺序列出 C API 中所有的函数与类型。每一个函数都有一个类似右边这样的标记：<span class="apii">[-o, +p, <em>x</em>]</span><br><br><br></p><p><br>第一个字段，<code>o</code>，表示函数从栈中弹出多少个元素。<br></p><p><br>第二个字段，<code>p</code>，表示函数向栈压入多少个元素。（所有函数都会在弹出参数后再压入结果。）形如 <code>x|y</code> 这样的字段表示函数可以压入（弹出） <code>x</code> 或 <code>y</code> 个元素，由具体情况决定；而问号 ‘<code>?</code>‘ 表示我们无法只通过观察参数来得知函数弹出/压入多少个元素（比如，它们依赖与栈中的内容）。<br></p><p><br>第三个字段，<code>x</code>，用于告知函数是否抛出错误： ‘<code>-</code>‘ 表示从不抛出任何错误；’<code>e</code>‘ 表示可能抛出错误；’<code>v</code>‘ 表示有目的地抛出一个错误。<br><br><br></p><hr><h3><a name="lua_absindex"><code>lua_absindex</code></a></h3><p><br><span class="apii">[-0, +0, –]</span><br></p><pre>int lua_absindex (lua_State <em>L, int idx);</em></pre><br><br><p><br>将可用的索引值 <code>idx</code> 转化为一个绝对索引值（不依赖栈顶）。<br><br><br><br><br><br><br></p><hr><h3><a name="lua_Alloc"><code>lua_Alloc</code></a></h3><br><pre>typedef void  (<em>lua_Alloc) (void </em>ud,<br>                             void <em>ptr,<br>                             size_t osize,<br>                             size_t nsize);</em></pre><br><br><p><br>Lua states 使用的内存分配函数的类型。该分配函数必须提供类似 <code>realloc</code> 的功能，但不必完全相同。其参数有 <code>ud</code>，传递给 <a href="#lua_newstate"><code>lua_newstate</code></a> 的不透明指针；<code>ptr</code>，指向一块分配/再分配/释放的内存的指针；<code>osize</code>，该内存块的原始大小或者是分配的内容；<code>nsize</code>，该内存块新的大小。<br><br><br></p><p><br>当 <code>ptr</code> 不为 <code>NULL</code> 时，<code>osize</code> 就是 <code>ptr</code> 所指内存块的大小，意味着，其大小在分配/再分配时就提供了。<br><br><br></p><p><br>当 <code>ptr</code> 为 <code>NULL</code> 时，<code>osize</code> 编码处理 Lua 分配的各类对象。<code>osize</code> 只在 Lua 创建某类新对象时，可以为 <a href="#pdf-LUA_TSTRING"><code>LUA_TSTRING</code></a>, <a href="#pdf-LUA_TTABLE"><code>LUA_TTABLE</code></a>, <a href="#pdf-LUA_TFUNCTION"><code>LUA_TFUNCTION</code></a>,<br><a href="#pdf-LUA_TUSERDATA"><code>LUA_TUSERDATA</code></a>, or <a href="#pdf-LUA_TTHREAD"><code>LUA_TTHREAD</code></a> 中的任意对象。当 <code>osize</code> 为其他值时，Lua 将为其分配内存。<br><br><br></p><p><br>Lua 假设下述行为由分配器的函数负责：<br><br><br></p><p><br>当 <code>nsize</code> 为 0 时，分配器行为应该类似 <code>free</code>，且返回 <code>NULL</code>。<br><br><br></p><p><br>当 <code>nsize</code> 不为 0 时，分配器行为应该类似 <code>realloc</code>。分配器只在无法满足请求时返回 <code>NULL</code>。Lua 假设分配器在 <code>osize &gt;= nsize</code> 时，永不失败。<br><br><br></p><p><br>这有个简单的分配器函数实现。它被 <a href="#luaL_newstate"><code>luaL_newstate</code></a> 用于辅助库中。<br><br></p><pre>     static void l_alloc (void <em>ud, void </em>ptr, size_t osize,<br>                                                size_t nsize) {<br>       (void)ud;  (void)osize;  /<em> not used </em>/<br>       if (nsize == 0) {<br>         free(ptr);<br>         return NULL;<br>       }<br>       else<br>         return realloc(ptr, nsize);<br>     }<br></pre><p><br>注意，标准&nbsp;C 保证 <code>free(NULL)</code> 无副作用而且 <code>realloc(NULL, size)</code> 等价 <code>malloc(size)</code>。该代码假设 <code>realloc</code> 缩小内存块时也不会失败。（虽然，标准&nbsp;C 并未明确此行为，但看起来是个安全的假定。）<br><br><br><br><br><br></p><hr><h3><a name="lua_arith"><code>lua_arith</code></a></h3><p><br><span class="apii">[-(2|1), +1, <em>e</em>]</span><br></p><pre>void lua_arith (lua_State <em>L, int op);</em></pre><br><br><p><br>在栈顶执行两个值（负数的话可以是一个）的数学运算，弹出两个值然后将结果压栈。该函数遵循Lua操作符的语义一致性（就是可可以调用元方法）。<br><br><br></p><p><br><code>op</code> 只能是以下常量之一：<br><br></p><ul><br><br><li><b><a name="pdf-LUA_OPADD"><code>LUA_OPADD</code></a>: </b> 加法 (<code>+</code>)</li><br><li><b><a name="pdf-LUA_OPSUB"><code>LUA_OPSUB</code></a>: </b> 减法 (<code>-</code>)</li><br><li><b><a name="pdf-LUA_OPMUL"><code>LUA_OPMUL</code></a>: </b> 乘法 (<code></code>)</li><br><li><b><a name="pdf-LUA_OPDIV"><code>LUA_OPDIV</code></a>: </b> 除法 (<code>/</code>)</li><br><li><b><a name="pdf-LUA_OPMOD"><code>LUA_OPMOD</code></a>: </b> 求模 (<code>%</code>)</li><br><li><b><a name="pdf-LUA_OPPOW"><code>LUA_OPPOW</code></a>: </b> 乘方 (<code>^</code>)</li><br><li><b><a name="pdf-LUA_OPUNM"><code>LUA_OPUNM</code></a>: </b> 取负 (unary <code>-</code>)</li><br><br></ul><br><br><br><br><br><hr><h3><a name="lua_atpanic"><code>lua_atpanic</code></a></h3><p><br><span class="apii">[-0, +0, –]</span><br></p><pre>lua_CFunction lua_atpanic (lua_State <em>L, lua_CFunction panicf);</em></pre><br><br><p><br>设置新的无理函数并返回旧的 (参阅 <a href="#4.6">§4.6</a>).<br><br><br><br><br><br></p><hr><h3><a name="lua_call"><code>lua_call</code></a></h3><p><br><span class="apii">[-(nargs+1), +nresults, <em>e</em>]</span><br></p><pre>void lua_call (lua_State L, int nargs, int nresults);</pre><br><br><p><br>调用一个函数。<br><br><br></p><p><br>调用函数必须遵循下列协议：<br>首先，被调函数需已在栈中；然后，函数参数需按顺序压栈，即第一个参数最先压栈；最后，调用 <a href="#lua_call"><code>lua_call</code></a>，<code>nargs</code> 为压入栈中的参数个数。该函数被调用时，所有压栈的参数和函数本身均被弹出。而在函数返回时，其结果又被压入栈中。结果的数量自适应 <code>nresults</code>，除非 <code>nresults</code> 是 <a name="pdf-LUA_MULTRET"><code>LUA_MULTRET</code></a>，这样所有的结果均会压栈。Lua 很注意压栈的结果适应栈的大小。函数结果也是按顺序压栈的（第一个结果最先压栈），所以调用结束后，最后的结果位于栈顶。<br><br><br></p><p><br>函数调用过程中，发生的任何错误均会向上传递（触发一个 <code>longjmp</code>）。<br><br><br></p><p><br>下述示例展示了主机程序如何做到这行Lua代码等价的事情：<br><br></p><pre>     a = f(“how”, t.x, 14)<br></pre><p><br>这是主机&nbsp;C 代码：<br><br></p><pre>     lua_getglobal(L, “f”);                  /<em> function to be called </em>/<br>     lua_pushstring(L, “how”);                        /<em> 1st argument </em>/<br>     lua_getglobal(L, “t”);                    /<em> table to be indexed </em>/<br>     lua_getfield(L, -1, “x”);        /<em> push result of t.x (2nd arg) </em>/<br>     lua_remove(L, -2);                  /<em> remove ‘t’ from the stack </em>/<br>     lua_pushinteger(L, 14);                          /<em> 3rd argument </em>/<br>     lua_call(L, 3, 1);     /<em> call ‘f’ with 3 arguments and 1 result </em>/<br>     lua_setglobal(L, “a”);                         /<em> set global ‘a’ </em>/<br></pre><p><br>注意，上述代码是”平衡”的：其结尾处，栈回归原始配置。这是良好的编程实践。<br><br><br><br><br></p><hr><h3><a name="lua_callk"><code>lua_callk</code></a></h3><p><br><span class="apii">[-(nargs + 1), +nresults, <em>e</em>]</span><br></p><pre>void lua_callk (lua_State <em>L, int nargs, int nresults, int ctx,<br>                lua_CFunction k);</em></pre><br><br><p><br>该函数行为类似 <a href="#lua_call"><code>lua_call</code></a>，但允许被调函数挂起 (参阅 <a href="#4.7">§4.7</a>)。<br><br><br><br><br><br></p><hr><h3><a name="lua_CFunction"><code>lua_CFunction</code></a></h3><br><pre>typedef int (lua_CFunction) (lua_State <em>L);</em></pre><br><br><p><br> C&nbsp;函数类型。<br><br><br></p><p><br>为了和Lua妥善的交流，C 函数必须采用如下规范，其定义了参数与结果的传递方式：C函数从栈中按顺序（第一个参数最先压栈）接收参数。所以，函数开始执行时，<code>lua_gettop(L)</code> 返回的数函数接收的参数个数。第一个参数（有的话）索引为 1 ，最后一个参数索引为 <code>lua_gettop(L)</code>。向Lua返回值时，C 函数只需将其按顺序压栈，然后返回结果的数量。栈中位于结果之下的其他值将被Lua妥善丢弃。与Lua函数一样，C 函数也可以返回多个结果。<br><br><br></p><p><br>举个例子，下述函数接收一串数值参数并返回他们的平均值与和：<br></p><pre>     static int foo (lua_State L) {<br>       int n = lua_gettop(L);    /<em> number of arguments </em>/<br>       lua_Number sum = 0;<br>       int i;<br>       for (i = 1; i &lt;= n; i++) {<br>         if (!lua_isnumber(L, i)) {<br>           lua_pushstring(L, “incorrect argument”);<br>           lua_error(L);<br>         }<br>         sum += lua_tonumber(L, i);<br>       }<br>       lua_pushnumber(L, sum/n);        /<em> first result </em>/<br>       lua_pushnumber(L, sum);         /<em> second result </em>/<br>       return 2;                   /<em> number of results </em>/<br>     }<br></pre><br><br><br><br><br><hr><h3><a name="lua_checkstack"><code>lua_checkstack</code></a></h3><p><br><span class="apii">[-0, +0, –]</span><br></p><pre>int lua_checkstack (lua_State <em>L, int extra);</em></pre><br><br><p><br>确保栈中至少有 <code>extra</code> 大小的空间。请求失败会返回错误，原因可能是栈空间已超出固定的最大尺寸（至少几千元素），或者是无法申请新的栈空间。该函数永远不会缩小栈，如果栈比新尺寸大，它也不会变。<br><br><br><br><br></p><hr><h3><a name="lua_close"><code>lua_close</code></a></h3><p><br><span class="apii">[-0, +0, –]</span><br></p><pre>void lua_close (lua_State L);</pre><br><br><p><br>销毁所给Lua<br>state中的所有对象（如果可能，还会调用相应的垃圾收集元方法）并释放所有该state使用的动态内存。在大部分平台，你不需要调用该函数，因为所有<br>的资源会在主机程序结束时自动释放。换句话说，在那些长时间运行并创建了多个state的程序中，比如后台程序或者网络服务器，可能需要在不需要的时候来<br>手动关闭state。<br><br><br><br></p><hr><h3><a name="lua_compare"><code>lua_compare</code></a></h3><p><br><span class="apii">[-0, +0, <em>e</em>]</span><br></p><pre>int lua_compare (lua_State <em>L, int index1, int index2, int op);</em></pre><br><br><p><br>比较两个Lua值。如果 <code>index1</code> 的值与 <code>index2</code> 相比较满足 <code>op</code> 的条件时，返回 1。否则返回 0。如果任意索引非法也返回 0。<br><br></p><p><br><code>op</code> 的值必须是下述常量之一：<br><br></p><ul><br><br><li><b><a name="pdf-LUA_OPEQ"><code>LUA_OPEQ</code></a>: </b> compares for equality (<code>==</code>)</li><br><li><b><a name="pdf-LUA_OPLT"><code>LUA_OPLT</code></a>: </b> compares for less than (<code>&lt;</code>)</li><br><li><b><a name="pdf-LUA_OPLE"><code>LUA_OPLE</code></a>: </b> compares for less or equal (<code>&lt;=</code>)</li><br><br></ul><br><br><br><br><br><hr><h3><a name="lua_concat"><code>lua_concat</code></a></h3><p><br><span class="apii">[-n, +1, <em>e</em>]</span><br></p><pre>void lua_concat (lua_State L, int n);</pre><br><br><p><br>连接栈顶 n 个值，弹出它们并将结果压入栈顶。如果 n 为 1，结果即为栈中的单值（即该函数不做任何事）；如果 n 为 0，结果为空字符串。连接操作遵循Lua的通用语义(参阅 <a href="#3.4.5">§3.4.5</a>).<br><br><br><br><br><br></p><hr><h3><a name="lua_copy"><code>lua_copy</code></a></h3><p><br><span class="apii">[-0, +0, –]</span><br></p><pre>void lua_copy (lua_State <em>L, int fromidx, int toidx);</em></pre><br><br><p><br>将 <code>fromidx</code> 的元素移至 <code>toidx</code><br>without shifting any element<br>(therefore replacing the value at that position).<br><br><br><br><br><br></p><hr><h3><a name="lua_createtable"><code>lua_createtable</code></a></h3><p><br><span class="apii">[-0, +1, <em>e</em>]</span><br></p><pre>void lua_createtable (lua_State L, int narr, int nrec);</pre><br><br><p><br>Creates a new empty table and pushes it onto the stack.<br>Parameter <code>narr</code> is a hint for how many elements the table<br>will have as a sequence;<br>parameter <code>nrec</code> is a hint for how many other elements<br>the table will have.<br>Lua may use these hints to preallocate memory for the new table.<br>This pre-allocation is useful for performance when you know in advance<br>how many elements the table will have.<br>Otherwise you can use the function <a href="#lua_newtable"><code>lua_newtable</code></a>.<br><br><br><br><br><br></p><hr><h3><a name="lua_dump"><code>lua_dump</code></a></h3><p><br><span class="apii">[-0, +0, <em>e</em>]</span><br></p><pre>int lua_dump (lua_State <em>L, lua_Writer writer, void </em>data);</pre><br><br><p><br>Dumps a function as a binary chunk.<br>Receives a Lua function on the top of the stack<br>and produces a binary chunk that,<br>if loaded again,<br>results in a function equivalent to the one dumped.<br>As it produces parts of the chunk,<br><a href="#lua_dump"><code>lua_dump</code></a> calls function <code>writer</code> (see <a href="#lua_Writer"><code>lua_Writer</code></a>)<br>with the given <code>data</code><br>to write them.<br><br><br></p><p><br>The value returned is the error code returned by the last<br>call to the writer;<br>0&nbsp;means no errors.<br><br><br></p><p><br>This function does not pop the Lua function from the stack.<br><br><br><br><br><br></p><hr><h3><a name="lua_error"><code>lua_error</code></a></h3><p><br><span class="apii">[-1, +0, <em>v</em>]</span><br></p><pre>int lua_error (lua_State <em>L);</em></pre><br><br><p><br>Generates a Lua error.<br>The error message (which can actually be a Lua value of any type)<br>must be on the stack top.<br>This function does a long jump,<br>and therefore never returns<br>(see <a href="#luaL_error"><code>luaL_error</code></a>).<br><br><br><br><br><br></p><hr><h3><a name="lua_gc"><code>lua_gc</code></a></h3><p><br><span class="apii">[-0, +0, <em>e</em>]</span><br></p><pre>int lua_gc (lua_State L, int what, int data);</pre><br><br><p><br>Controls the garbage collector.<br><br><br></p><p><br>This function performs several tasks,<br>according to the value of the parameter <code>what</code>:<br><br></p><ul><br><br><li><b><code>LUA_GCSTOP</code>: </b><br>stops the garbage collector.<br></li><br><br><li><b><code>LUA_GCRESTART</code>: </b><br>restarts the garbage collector.<br></li><br><br><li><b><code>LUA_GCCOLLECT</code>: </b><br>performs a full garbage-collection cycle.<br></li><br><br><li><b><code>LUA_GCCOUNT</code>: </b><br>returns the current amount of memory (in Kbytes) in use by Lua.<br></li><br><br><li><b><code>LUA_GCCOUNTB</code>: </b><br>returns the remainder of dividing the current amount of bytes of<br>memory in use by Lua by 1024.<br></li><br><br><li><b><code>LUA_GCSTEP</code>: </b><br>performs an incremental step of garbage collection.<br>The step “size” is controlled by <code>data</code><br>(larger values mean more steps) in a non-specified way.<br>If you want to control the step size<br>you must experimentally tune the value of <code>data</code>.<br>The function returns 1 if the step finished a<br>garbage-collection cycle.<br></li><br><br><li><b><code>LUA_GCSETPAUSE</code>: </b><br>sets <code>data</code> as the new value<br>for the <em>pause</em> of the collector (see <a href="#2.5">§2.5</a>).<br>The function returns the previous value of the pause.<br></li><br><br><li><b><code>LUA_GCSETSTEPMUL</code>: </b><br>sets <code>data</code> as the new value for the <em>step multiplier</em> of<br>the collector (see <a href="#2.5">§2.5</a>).<br>The function returns the previous value of the step multiplier.<br></li><br><br><li><b><code>LUA_GCISRUNNING</code>: </b><br>returns a boolean that tells whether the collector is running<br>(i.e., not stopped).<br></li><br><br><li><b><code>LUA_GCGEN</code>: </b><br>changes the collector to generational mode<br>(see <a href="#2.5">§2.5</a>).<br></li><br><br><li><b><code>LUA_GCINC</code>: </b><br>changes the collector to incremental mode.<br>This is the default mode.<br></li><br><br></ul><br><br><p><br>For more details about these options,<br>see <a href="#pdf-collectgarbage"><code>collectgarbage</code></a>.<br><br><br><br><br><br></p><hr><h3><a name="lua_getallocf"><code>lua_getallocf</code></a></h3><p><br><span class="apii">[-0, +0, –]</span><br></p><pre>lua_Alloc lua_getallocf (lua_State <em>L, void **ud);</em></pre><br><br><p><br>Returns the memory-allocation function of a given state.<br>If <code>ud</code> is not <code>NULL</code>, Lua stores in <code>ud</code> the<br>opaque pointer passed to <a href="#lua_newstate"><code>lua_newstate</code></a>.<br><br><br><br><br><br></p><hr><h3><a name="lua_getctx"><code>lua_getctx</code></a></h3><p><br><span class="apii">[-0, +0, –]</span><br></p><pre>int lua_getctx (lua_State <em>L, int </em>ctx);</pre><br><br><p><br>This function is called by a continuation function (see <a href="#4.7">§4.7</a>)<br>to retrieve the status of the thread and a context information.<br><br><br></p><p><br>When called in the original function,<br><a href="#lua_getctx"><code>lua_getctx</code></a> always returns <a href="#pdf-LUA_OK"><code>LUA_OK</code></a><br>and does not change the value of its argument <code>ctx</code>.<br>When called inside a continuation function,<br><a href="#lua_getctx"><code>lua_getctx</code></a> returns <a href="#pdf-LUA_YIELD"><code>LUA_YIELD</code></a> and sets<br>the value of <code>ctx</code> to be the context information<br>(the value passed as the <code>ctx</code> argument<br>to the callee together with the continuation function).<br><br><br></p><p><br>When the callee is <a href="#lua_pcallk"><code>lua_pcallk</code></a>,<br>Lua may also call its continuation function<br>to handle errors during the call.<br>That is, upon an error in the function called by <a href="#lua_pcallk"><code>lua_pcallk</code></a>,<br>Lua may not return to the original function<br>but instead may call the continuation function.<br>In that case, a call to <a href="#lua_getctx"><code>lua_getctx</code></a> will return the error code<br>(the value that would be returned by <a href="#lua_pcallk"><code>lua_pcallk</code></a>);<br>the value of <code>ctx</code> will be set to the context information,<br>as in the case of a yield.<br><br><br><br><br><br></p><hr><h3><a name="lua_getfield"><code>lua_getfield</code></a></h3><p><br><span class="apii">[-0, +1, <em>e</em>]</span><br></p><pre>void lua_getfield (lua_State <em>L, int index, const char </em>k);</pre><br><br><p><br>Pushes onto the stack the value <code>t[k]</code>,<br>where <code>t</code> is the value at the given index.<br>As in Lua, this function may trigger a metamethod<br>for the “index” event (see <a href="#2.4">§2.4</a>).<br><br><br><br><br><br></p><hr><h3><a name="lua_getglobal"><code>lua_getglobal</code></a></h3><p><br><span class="apii">[-0, +1, <em>e</em>]</span><br></p><pre>void lua_getglobal (lua_State <em>L, const char </em>name);</pre><br><br><p><br>Pushes onto the stack the value of the global <code>name</code>.<br><br><br><br><br><br></p><hr><h3><a name="lua_getmetatable"><code>lua_getmetatable</code></a></h3><p><br><span class="apii">[-0, +(0|1), –]</span><br></p><pre>int lua_getmetatable (lua_State <em>L, int index);</em></pre><br><br><p><br>Pushes onto the stack the metatable of the value at the given index.<br>If the value does not have a metatable,<br>the function returns&nbsp;0 and pushes nothing on the stack.<br><br><br><br><br><br></p><hr><h3><a name="lua_gettable"><code>lua_gettable</code></a></h3><p><br><span class="apii">[-1, +1, <em>e</em>]</span><br></p><pre>void lua_gettable (lua_State L, int index);</pre><br><br><p><br>Pushes onto the stack the value <code>t[k]</code>,<br>where <code>t</code> is the value at the given index<br>and <code>k</code> is the value at the top of the stack.<br><br><br></p><p><br>This function pops the key from the stack<br>(putting the resulting value in its place).<br>As in Lua, this function may trigger a metamethod<br>for the “index” event (see <a href="#2.4">§2.4</a>).<br><br><br><br><br><br></p><hr><h3><a name="lua_gettop"><code>lua_gettop</code></a></h3><p><br><span class="apii">[-0, +0, –]</span><br></p><pre>int lua_gettop (lua_State <em>L);</em></pre><br><br><p><br>Returns the index of the top element in the stack.<br>Because indices start at&nbsp;1,<br>this result is equal to the number of elements in the stack<br>(and so 0&nbsp;means an empty stack).<br><br><br><br><br><br></p><hr><h3><a name="lua_getuservalue"><code>lua_getuservalue</code></a></h3><p><br><span class="apii">[-0, +1, –]</span><br></p><pre>void lua_getuservalue (lua_State L, int index);</pre><br><br><p><br>Pushes onto the stack the Lua value associated with the userdata<br>at the given index.<br>This Lua value must be a table or <b>nil</b>.<br><br><br><br><br><br></p><hr><h3><a name="lua_insert"><code>lua_insert</code></a></h3><p><br><span class="apii">[-1, +1, –]</span><br></p><pre>void lua_insert (lua_State <em>L, int index);</em></pre><br><br><p><br>Moves the top element into the given valid index,<br>shifting up the elements above this index to open space.<br>This function cannot be called with a pseudo-index,<br>because a pseudo-index is not an actual stack position.<br><br><br><br><br><br></p><hr><h3><a name="lua_Integer"><code>lua_Integer</code></a></h3><br><pre>typedef ptrdiff_t lua_Integer;</pre><br><br><p><br>The type used by the Lua API to represent signed integral values.<br><br><br></p><p><br>By default it is a <code>ptrdiff_t</code>,<br>which is usually the largest signed integral type the machine handles<br>“comfortably”.<br><br><br><br><br><br></p><hr><h3><a name="lua_isboolean"><code>lua_isboolean</code></a></h3><p><br><span class="apii">[-0, +0, –]</span><br></p><pre>int lua_isboolean (lua_State L, int index);</pre><br><br><p><br>Returns 1 if the value at the given index is a boolean,<br>and 0&nbsp;otherwise.<br><br><br><br><br><br></p><hr><h3><a name="lua_iscfunction"><code>lua_iscfunction</code></a></h3><p><br><span class="apii">[-0, +0, –]</span><br></p><pre>int lua_iscfunction (lua_State <em>L, int index);</em></pre><br><br><p><br>Returns 1 if the value at the given index is a C&nbsp;function,<br>and 0&nbsp;otherwise.<br><br><br><br><br><br></p><hr><h3><a name="lua_isfunction"><code>lua_isfunction</code></a></h3><p><br><span class="apii">[-0, +0, –]</span><br></p><pre>int lua_isfunction (lua_State L, int index);</pre><br><br><p><br>Returns 1 if the value at the given index is a function<br>(either C or Lua), and 0&nbsp;otherwise.<br><br><br><br><br><br></p><hr><h3><a name="lua_islightuserdata"><code>lua_islightuserdata</code></a></h3><p><br><span class="apii">[-0, +0, –]</span><br></p><pre>int lua_islightuserdata (lua_State <em>L, int index);</em></pre><br><br><p><br>Returns 1 if the value at the given index is a light userdata,<br>and 0&nbsp;otherwise.<br><br><br><br><br><br></p><hr><h3><a name="lua_isnil"><code>lua_isnil</code></a></h3><p><br><span class="apii">[-0, +0, –]</span><br></p><pre>int lua_isnil (lua_State L, int index);</pre><br><br><p><br>Returns 1 if the value at the given index is <b>nil</b>,<br>and 0&nbsp;otherwise.<br><br><br><br><br><br></p><hr><h3><a name="lua_isnone"><code>lua_isnone</code></a></h3><p><br><span class="apii">[-0, +0, –]</span><br></p><pre>int lua_isnone (lua_State <em>L, int index);</em></pre><br><br><p><br>Returns 1 if the given index is not valid,<br>and 0&nbsp;otherwise.<br><br><br><br><br><br></p><hr><h3><a name="lua_isnoneornil"><code>lua_isnoneornil</code></a></h3><p><br><span class="apii">[-0, +0, –]</span><br></p><pre>int lua_isnoneornil (lua_State L, int index);</pre><br><br><p><br>Returns 1 if the given index is not valid<br>or if the value at this index is <b>nil</b>,<br>and 0&nbsp;otherwise.<br><br><br><br><br><br></p><hr><h3><a name="lua_isnumber"><code>lua_isnumber</code></a></h3><p><br><span class="apii">[-0, +0, –]</span><br></p><pre>int lua_isnumber (lua_State <em>L, int index);</em></pre><br><br><p><br>Returns 1 if the value at the given index is a number<br>or a string convertible to a number,<br>and 0&nbsp;otherwise.<br><br><br><br><br><br></p><hr><h3><a name="lua_isstring"><code>lua_isstring</code></a></h3><p><br><span class="apii">[-0, +0, –]</span><br></p><pre>int lua_isstring (lua_State L, int index);</pre><br><br><p><br>Returns 1 if the value at the given index is a string<br>or a number (which is always convertible to a string),<br>and 0&nbsp;otherwise.<br><br><br><br><br><br></p><hr><h3><a name="lua_istable"><code>lua_istable</code></a></h3><p><br><span class="apii">[-0, +0, –]</span><br></p><pre>int lua_istable (lua_State <em>L, int index);</em></pre><br><br><p><br>Returns 1 if the value at the given index is a table,<br>and 0&nbsp;otherwise.<br><br><br><br><br><br></p><hr><h3><a name="lua_isthread"><code>lua_isthread</code></a></h3><p><br><span class="apii">[-0, +0, –]</span><br></p><pre>int lua_isthread (lua_State L, int index);</pre><br><br><p><br>Returns 1 if the value at the given index is a thread,<br>and 0&nbsp;otherwise.<br><br><br><br><br><br></p><hr><h3><a name="lua_isuserdata"><code>lua_isuserdata</code></a></h3><p><br><span class="apii">[-0, +0, –]</span><br></p><pre>int lua_isuserdata (lua_State <em>L, int index);</em></pre><br><br><p><br>Returns 1 if the value at the given index is a userdata<br>(either full or light), and 0&nbsp;otherwise.<br><br><br><br><br><br></p><hr><h3><a name="lua_len"><code>lua_len</code></a></h3><p><br><span class="apii">[-0, +1, <em>e</em>]</span><br></p><pre>void lua_len (lua_State L, int index);</pre><br><br><p><br>Returns the “length” of the value at the given index;<br>it is equivalent to the ‘<code>#</code>‘ operator in Lua (see <a href="#3.4.6">§3.4.6</a>).<br>The result is pushed on the stack.<br><br><br><br><br><br></p><hr><h3><a name="lua_load"><code>lua_load</code></a></h3><p><br><span class="apii">[-0, +1, –]</span><br></p><pre>int lua_load (lua_State <em>L,<br>              lua_Reader reader,<br>              void </em>data,<br>              const char <em>source,<br>              const char </em>mode);</pre><br><br><p><br>Loads a Lua chunk (without running it).<br>If there are no errors,<br><code>lua_load</code> pushes the compiled chunk as a Lua<br>function on top of the stack.<br>Otherwise, it pushes an error message.<br><br><br></p><p><br>The return values of <code>lua_load</code> are:<br><br></p><ul><br><br><li><b><a href="#pdf-LUA_OK"><code>LUA_OK</code></a>: </b> no errors;</li><br><br><li><b><a name="pdf-LUA_ERRSYNTAX"><code>LUA_ERRSYNTAX</code></a>: </b><br>syntax error during precompilation;</li><br><br><li><b><a href="#pdf-LUA_ERRMEM"><code>LUA_ERRMEM</code></a>: </b><br>memory allocation error;</li><br><br><li><b><a href="#pdf-LUA_ERRGCMM"><code>LUA_ERRGCMM</code></a>: </b><br>error while running a <code><strong>gc</strong></code> metamethod.<br>(This error has no relation with the chunk being loaded.<br>It is generated by the garbage collector.)<br></li><br><br></ul><br><br><p><br>The <code>lua_load</code> function uses a user-supplied <code>reader</code> function<br>to read the chunk (see <a href="#lua_Reader"><code>lua_Reader</code></a>).<br>The <code>data</code> argument is an opaque value passed to the reader function.<br><br><br></p><p><br>The <code>source</code> argument gives a name to the chunk,<br>which is used for error messages and in debug information (see <a href="#4.9">§4.9</a>).<br><br><br></p><p><br><code>lua_load</code> automatically detects whether the chunk is text or binary<br>and loads it accordingly (see program <code>luac</code>).<br>The string <code>mode</code> works as in function <a href="#pdf-load"><code>load</code></a>,<br>with the addition that<br>a <code>NULL</code> value is equivalent to the string “<code>bt</code>“.<br><br><br></p><p><br><code>lua_load</code> uses the stack internally,<br>so the reader function should always leave the stack<br>unmodified when returning.<br><br><br></p><p><br>If the resulting function has one upvalue,<br>this upvalue is set to the value of the global environment<br>stored at index <code>LUA_RIDX_GLOBALS</code> in the registry (see <a href="#4.5">§4.5</a>).<br>When loading main chunks,<br>this upvalue will be the <code>_ENV</code> variable (see <a href="#2.2">§2.2</a>).<br><br><br><br><br><br></p><hr><h3><a name="lua_newstate"><code>lua_newstate</code></a></h3><p><br><span class="apii">[-0, +0, –]</span><br></p><pre>lua_State <em>lua_newstate (lua_Alloc f, void </em>ud);</pre><br><br><p><br>Creates a new thread running in a new, independent state.<br>Returns <code>NULL</code> if cannot create the thread or the state<br>(due to lack of memory).<br>The argument <code>f</code> is the allocator function;<br>Lua does all memory allocation for this state through this function.<br>The second argument, <code>ud</code>, is an opaque pointer that Lua<br>passes to the allocator in every call.<br><br><br><br><br><br></p><hr><h3><a name="lua_newtable"><code>lua_newtable</code></a></h3><p><br><span class="apii">[-0, +1, <em>e</em>]</span><br></p><pre>void lua_newtable (lua_State <em>L);</em></pre><br><br><p><br>Creates a new empty table and pushes it onto the stack.<br>It is equivalent to <code>lua_createtable(L, 0, 0)</code>.<br><br><br><br><br><br></p><hr><h3><a name="lua_newthread"><code>lua_newthread</code></a></h3><p><br><span class="apii">[-0, +1, <em>e</em>]</span><br></p><pre>lua_State lua_newthread (lua_State <em>L);</em></pre><br><br><p><br>Creates a new thread, pushes it on the stack,<br>and returns a pointer to a <a href="#lua_State"><code>lua_State</code></a> that represents this new thread.<br>The new thread returned by this function shares with the original thread<br>its global environment,<br>but has an independent execution stack.<br><br><br></p><p><br>There is no explicit function to close or to destroy a thread.<br>Threads are subject to garbage collection,<br>like any Lua object.<br><br><br><br><br><br></p><hr><h3><a name="lua_newuserdata"><code>lua_newuserdata</code></a></h3><p><br><span class="apii">[-0, +1, <em>e</em>]</span><br></p><pre>void lua_newuserdata (lua_State <em>L, size_t size);</em></pre><br><br><p><br>This function allocates a new block of memory with the given size,<br>pushes onto the stack a new full userdata with the block address,<br>and returns this address.<br>The host program can freely use this memory.<br><br><br><br><br><br></p><hr><h3><a name="lua_next"><code>lua_next</code></a></h3><p><br><span class="apii">[-1, +(2|0), <em>e</em>]</span><br></p><pre>int lua_next (lua_State L, int index);</pre><br><br><p><br>Pops a key from the stack,<br>and pushes a key–value pair from the table at the given index<br>(the “next” pair after the given key).<br>If there are no more elements in the table,<br>then <a href="#lua_next"><code>lua_next</code></a> returns 0 (and pushes nothing).<br><br><br></p><p><br>A typical traversal looks like this:<br><br></p><pre>     /<em> table is in the stack at index ‘t’ </em>/<br>     lua_pushnil(L);  /<em> first key </em>/<br>     while (lua_next(L, t) != 0) {<br>       /<em> uses ‘key’ (at index -2) and ‘value’ (at index -1) </em>/<br>       printf(“%s - %s\n”,<br>              lua_typename(L, lua_type(L, -2)),<br>              lua_typename(L, lua_type(L, -1)));<br>       /<em> removes ‘value’; keeps ‘key’ for next iteration </em>/<br>       lua_pop(L, 1);<br>     }<br></pre><br><br><p><br>While traversing a table,<br>do not call <a href="#lua_tolstring"><code>lua_tolstring</code></a> directly on a key,<br>unless you know that the key is actually a string.<br>Recall that <a href="#lua_tolstring"><code>lua_tolstring</code></a> may change<br>the value at the given index;<br>this confuses the next call to <a href="#lua_next"><code>lua_next</code></a>.<br><br><br></p><p><br>See function <a href="#pdf-next"><code>next</code></a> for the caveats of modifying<br>the table during its traversal.<br><br><br><br><br><br></p><hr><h3><a name="lua_Number"><code>lua_Number</code></a></h3><br><pre>typedef double lua_Number;</pre><br><br><p><br>The type of numbers in Lua.<br>By default, it is double, but that can be changed in <code>luaconf.h</code>.<br>Through this configuration file you can change<br>Lua to operate with another type for numbers (e.g., float or long).<br><br><br><br><br><br></p><hr><h3><a name="lua_pcall"><code>lua_pcall</code></a></h3><p><br><span class="apii">[-(nargs + 1), +(nresults|1), –]</span><br></p><pre>int lua_pcall (lua_State *L, int nargs, int nresults, int msgh);</pre><br><br><p><br>Calls a function in protected mode.<br><br><br></p><p><br>Both <code>nargs</code> and <code>nresults</code> have the same meaning as<br>in <a href="#lua_call"><code>lua_call</code></a>.<br>If there are no errors during the call,<br><a href="#lua_pcall"><code>lua_pcall</code></a> behaves exactly like <a href="#lua_call"><code>lua_call</code></a>.<br>However, if there is any error,<br><a href="#lua_pcall"><code>lua_pcall</code></a> catches it,<br>pushes a single value on the stack (the error message),<br>and returns an error code.<br>Like <a href="#lua_call"><code>lua_call</code></a>,<br><a href="#lua_pcall"><code>lua_pcall</code></a> always removes the function<br>and its arguments from the stack.<br><br><br></p><p><br>If <code>msgh</code> is 0,<br>then the error message returned on the stack<br>is exactly the original error message.<br>Otherwise, <code>msgh</code> is the stack index of a<br><em>message handler</em>.<br>(In the current implementation, this index cannot be a pseudo-index.)<br>In case of runtime errors,<br>this function will be called with the error message<br>and its return value will be the message<br>returned on the stack by <a href="#lua_pcall"><code>lua_pcall</code></a>.<br><br><br></p><p><br>Typically, the message handler is used to add more debug<br>information to the error message, such as a stack traceback.<br>Such information cannot be gathered after the return of <a href="#lua_pcall"><code>lua_pcall</code></a>,<br>since by then the stack has unwound.<br><br><br></p><p><br>The <a href="#lua_pcall"><code>lua_pcall</code></a> function returns one of the following codes<br>(defined in <code>lua.h</code>):<br><br></p><ul><br><br><li><b><a name="pdf-LUA_OK"><code>LUA_OK</code></a> (0): </b><br>success.</li><br><br><li><b><a name="pdf-LUA_ERRRUN"><code>LUA_ERRRUN</code></a>: </b><br>a runtime error.<br></li><br><br><li><b><a name="pdf-LUA_ERRMEM"><code>LUA_ERRMEM</code></a>: </b><br>memory allocation error.<br>For such errors, Lua does not call the message handler.<br></li><br><br><li><b><a name="pdf-LUA_ERRERR"><code>LUA_ERRERR</code></a>: </b><br>error while running the message handler.<br></li><br><br><li><b><a name="pdf-LUA_ERRGCMM"><code>LUA_ERRGCMM</code></a>: </b><br>error while running a <code>gc</code> metamethod.<br>(This error typically has no relation with the function being called.<br>It is generated by the garbage collector.)<br></li><br><br></ul><br><br><br><br><br><hr><h3><a name="lua_pcallk"><code>lua_pcallk</code></a></h3><p><br><span class="apii">[-(nargs + 1), +(nresults|1), –]</span><br></p><pre>int lua_pcallk (lua_State <em>L,<br>                int nargs,<br>                int nresults,<br>                int errfunc,<br>                int ctx,<br>                lua_CFunction k);</em></pre><br><br><p><br>This function behaves exactly like <a href="#lua_pcall"><code>lua_pcall</code></a>,<br>but allows the called function to yield (see <a href="#4.7">§4.7</a>).<br><br><br><br><br><br></p><hr><h3><a name="lua_pop"><code>lua_pop</code></a></h3><p><br><span class="apii">[-n, +0, –]</span><br></p><pre>void lua_pop (lua_State L, int n);</pre><br><br><p><br>Pops <code>n</code> elements from the stack.<br><br><br><br><br><br></p><hr><h3><a name="lua_pushboolean"><code>lua_pushboolean</code></a></h3><p><br><span class="apii">[-0, +1, –]</span><br></p><pre>void lua_pushboolean (lua_State <em>L, int b);</em></pre><br><br><p><br>Pushes a boolean value with value <code>b</code> onto the stack.<br><br><br><br><br><br></p><hr><h3><a name="lua_pushcclosure"><code>lua_pushcclosure</code></a></h3><p><br><span class="apii">[-n, +1, <em>e</em>]</span><br></p><pre>void lua_pushcclosure (lua_State L, lua_CFunction fn, int n);</pre><br><br><p><br>Pushes a new C&nbsp;closure onto the stack.<br><br><br></p><p><br>When a C&nbsp;function is created,<br>it is possible to associate some values with it,<br>thus creating a C&nbsp;closure (see <a href="#4.4">§4.4</a>);<br>these values are then accessible to the function whenever it is called.<br>To associate values with a C&nbsp;function,<br>first these values should be pushed onto the stack<br>(when there are multiple values, the first value is pushed first).<br>Then <a href="#lua_pushcclosure"><code>lua_pushcclosure</code></a><br>is called to create and push the C&nbsp;function onto the stack,<br>with the argument <code>n</code> telling how many values should be<br>associated with the function.<br><a href="#lua_pushcclosure"><code>lua_pushcclosure</code></a> also pops these values from the stack.<br><br><br></p><p><br>The maximum value for <code>n</code> is 255.<br><br><br></p><p><br>When <code>n</code> is zero,<br>this function creates a <em>light C function</em>,<br>which is just a pointer to the C&nbsp;function.<br>In that case, it never throws a memory error.<br><br><br><br><br><br></p><hr><h3><a name="lua_pushcfunction"><code>lua_pushcfunction</code></a></h3><p><br><span class="apii">[-0, +1, –]</span><br></p><pre>void lua_pushcfunction (lua_State <em>L, lua_CFunction f);</em></pre><br><br><p><br>Pushes a C&nbsp;function onto the stack.<br>This function receives a pointer to a C function<br>and pushes onto the stack a Lua value of type <code>function</code> that,<br>when called, invokes the corresponding C&nbsp;function.<br><br><br></p><p><br>Any function to be registered in Lua must<br>follow the correct protocol to receive its parameters<br>and return its results (see <a href="#lua_CFunction"><code>lua_CFunction</code></a>).<br><br><br></p><p><br><code>lua_pushcfunction</code> is defined as a macro:<br><br></p><pre>     #define lua_pushcfunction(L,f)  lua_pushcclosure(L,f,0)<br></pre><p><br>Note that <code>f</code> is used twice.<br><br><br><br><br><br></p><hr><h3><a name="lua_pushfstring"><code>lua_pushfstring</code></a></h3><p><br><span class="apii">[-0, +1, <em>e</em>]</span><br></p><pre>const char lua_pushfstring (lua_State <em>L, const char </em>fmt, …);</pre><br><br><p><br>Pushes onto the stack a formatted string<br>and returns a pointer to this string.<br>It is similar to the ANSI&nbsp;C function <code>sprintf</code>,<br>but has some important differences:<br><br></p><ul><br><br><li><br>You do not have to allocate space for the result:<br>the result is a Lua string and Lua takes care of memory allocation<br>(and deallocation, through garbage collection).<br></li><br><br><li><br>The conversion specifiers are quite restricted.<br>There are no flags, widths, or precisions.<br>The conversion specifiers can only be<br>‘<code>%%</code>‘ (inserts a ‘<code>%</code>‘ in the string),<br>‘<code>%s</code>‘ (inserts a zero-terminated string, with no size restrictions),<br>‘<code>%f</code>‘ (inserts a <a href="#lua_Number"><code>lua_Number</code></a>),<br>‘<code>%p</code>‘ (inserts a pointer as a hexadecimal numeral),<br>‘<code>%d</code>‘ (inserts an <code>int</code>), and<br>‘<code>%c</code>‘ (inserts an <code>int</code> as a byte).<br></li><br><br></ul><br><br><br><br><br><hr><h3><a name="lua_pushglobaltable"><code>lua_pushglobaltable</code></a></h3><p><br><span class="apii">[-0, +1, –]</span><br></p><pre>void lua_pushglobaltable (lua_State <em>L);</em></pre><br><br><p><br>Pushes the global environment onto the stack.<br><br><br><br><br><br></p><hr><h3><a name="lua_pushinteger"><code>lua_pushinteger</code></a></h3><p><br><span class="apii">[-0, +1, –]</span><br></p><pre>void lua_pushinteger (lua_State L, lua_Integer n);</pre><br><br><p><br>Pushes a number with value <code>n</code> onto the stack.<br><br><br><br><br><br></p><hr><h3><a name="lua_pushlightuserdata"><code>lua_pushlightuserdata</code></a></h3><p><br><span class="apii">[-0, +1, –]</span><br></p><pre>void lua_pushlightuserdata (lua_State <em>L, void </em>p);</pre><br><br><p><br>Pushes a light userdata onto the stack.<br><br><br></p><p><br>Userdata represent C&nbsp;values in Lua.<br>A <em>light userdata</em> represents a pointer, a <code>void<em></em></code>.<br>It is a value (like a number):<br>you do not create it, it has no individual metatable,<br>and it is not collected (as it was never created).<br>A light userdata is equal to “any”<br>light userdata with the same C&nbsp;address.<br><br><br><br><br><br></p><hr><h3><a name="lua_pushliteral"><code>lua_pushliteral</code></a></h3><p><br><span class="apii">[-0, +1, <em>e</em>]</span><br></p><pre>const char lua_pushliteral (lua_State <em>L, const char </em>s);</pre><br><br><p><br>This macro is equivalent to <a href="#lua_pushlstring"><code>lua_pushlstring</code></a>,<br>but can be used only when <code>s</code> is a literal string.<br>It automatically provides the string length.<br><br><br><br><br><br></p><hr><h3><a name="lua_pushlstring"><code>lua_pushlstring</code></a></h3><p><br><span class="apii">[-0, +1, <em>e</em>]</span><br></p><pre>const char <em>lua_pushlstring (lua_State </em>L, const char <em>s, size_t len);</em></pre><br><br><p><br>Pushes the string pointed to by <code>s</code> with size <code>len</code><br>onto the stack.<br>Lua makes (or reuses) an internal copy of the given string,<br>so the memory at <code>s</code> can be freed or reused immediately after<br>the function returns.<br>The string can contain any binary data,<br>including embedded zeros.<br><br><br></p><p><br>Returns a pointer to the internal copy of the string.<br><br><br><br><br><br></p><hr><h3><a name="lua_pushnil"><code>lua_pushnil</code></a></h3><p><br><span class="apii">[-0, +1, –]</span><br></p><pre>void lua_pushnil (lua_State L);</pre><br><br><p><br>Pushes a nil value onto the stack.<br><br><br><br><br><br></p><hr><h3><a name="lua_pushnumber"><code>lua_pushnumber</code></a></h3><p><br><span class="apii">[-0, +1, –]</span><br></p><pre>void lua_pushnumber (lua_State <em>L, lua_Number n);</em></pre><br><br><p><br>Pushes a number with value <code>n</code> onto the stack.<br><br><br><br><br><br></p><hr><h3><a name="lua_pushstring"><code>lua_pushstring</code></a></h3><p><br><span class="apii">[-0, +1, <em>e</em>]</span><br></p><pre>const char lua_pushstring (lua_State <em>L, const char </em>s);</pre><br><br><p><br>Pushes the zero-terminated string pointed to by <code>s</code><br>onto the stack.<br>Lua makes (or reuses) an internal copy of the given string,<br>so the memory at <code>s</code> can be freed or reused immediately after<br>the function returns.<br><br><br></p><p><br>Returns a pointer to the internal copy of the string.<br><br><br></p><p><br>If <code>s</code> is <code>NULL</code>, pushes <b>nil</b> and returns <code>NULL</code>.<br><br><br><br><br><br></p><hr><h3><a name="lua_pushthread"><code>lua_pushthread</code></a></h3><p><br><span class="apii">[-0, +1, –]</span><br></p><pre>int lua_pushthread (lua_State <em>L);</em></pre><br><br><p><br>Pushes the thread represented by <code>L</code> onto the stack.<br>Returns 1 if this thread is the main thread of its state.<br><br><br><br><br><br></p><hr><h3><a name="lua_pushunsigned"><code>lua_pushunsigned</code></a></h3><p><br><span class="apii">[-0, +1, –]</span><br></p><pre>void lua_pushunsigned (lua_State L, lua_Unsigned n);</pre><br><br><p><br>Pushes a number with value <code>n</code> onto the stack.<br><br><br><br><br><br></p><hr><h3><a name="lua_pushvalue"><code>lua_pushvalue</code></a></h3><p><br><span class="apii">[-0, +1, –]</span><br></p><pre>void lua_pushvalue (lua_State <em>L, int index);</em></pre><br><br><p><br>Pushes a copy of the element at the given index<br>onto the stack.<br><br><br><br><br><br></p><hr><h3><a name="lua_pushvfstring"><code>lua_pushvfstring</code></a></h3><p><br><span class="apii">[-0, +1, <em>e</em>]</span><br></p><pre>const char lua_pushvfstring (lua_State <em>L,<br>                              const char </em>fmt,<br>                              va_list argp);</pre><br><br><p><br>Equivalent to <a href="#lua_pushfstring"><code>lua_pushfstring</code></a>, except that it receives a <code>va_list</code><br>instead of a variable number of arguments.<br><br><br><br><br><br></p><hr><h3><a name="lua_rawequal"><code>lua_rawequal</code></a></h3><p><br><span class="apii">[-0, +0, –]</span><br></p><pre>int lua_rawequal (lua_State <em>L, int index1, int index2);</em></pre><br><br><p><br>Returns 1 if the two values in indices <code>index1</code> and<br><code>index2</code> are primitively equal<br>(that is, without calling metamethods).<br>Otherwise returns&nbsp;0.<br>Also returns&nbsp;0 if any of the indices are non valid.<br><br><br><br><br><br></p><hr><h3><a name="lua_rawget"><code>lua_rawget</code></a></h3><p><br><span class="apii">[-1, +1, –]</span><br></p><pre>void lua_rawget (lua_State L, int index);</pre><br><br><p><br>Similar to <a href="#lua_gettable"><code>lua_gettable</code></a>, but does a raw access<br>(i.e., without metamethods).<br><br><br><br><br><br></p><hr><h3><a name="lua_rawgeti"><code>lua_rawgeti</code></a></h3><p><br><span class="apii">[-0, +1, –]</span><br></p><pre>void lua_rawgeti (lua_State <em>L, int index, int n);</em></pre><br><br><p><br>Pushes onto the stack the value <code>t[n]</code>,<br>where <code>t</code> is the table at the given index.<br>The access is raw;<br>that is, it does not invoke metamethods.<br><br><br><br><br><br></p><hr><h3><a name="lua_rawgetp"><code>lua_rawgetp</code></a></h3><p><br><span class="apii">[-0, +1, –]</span><br></p><pre>void lua_rawgetp (lua_State L, int index, const void <em>p);</em></pre><br><br><p><br>Pushes onto the stack the value <code>t[k]</code>,<br>where <code>t</code> is the table at the given index and<br><code>k</code> is the pointer <code>p</code> represented as a light userdata.<br>The access is raw;<br>that is, it does not invoke metamethods.<br><br><br><br><br><br></p><hr><h3><a name="lua_rawlen"><code>lua_rawlen</code></a></h3><p><br><span class="apii">[-0, +0, –]</span><br></p><pre>size_t lua_rawlen (lua_State L, int index);</pre><br><br><p><br>Returns the raw “length” of the value at the given index:<br>for strings, this is the string length;<br>for tables, this is the result of the length operator (‘<code>#</code>‘)<br>with no metamethods;<br>for userdata, this is the size of the block of memory allocated<br>for the userdata;<br>for other values, it is&nbsp;0.<br><br><br><br><br><br></p><hr><h3><a name="lua_rawset"><code>lua_rawset</code></a></h3><p><br><span class="apii">[-2, +0, <em>e</em>]</span><br></p><pre>void lua_rawset (lua_State <em>L, int index);</em></pre><br><br><p><br>Similar to <a href="#lua_settable"><code>lua_settable</code></a>, but does a raw assignment<br>(i.e., without metamethods).<br><br><br><br><br><br></p><hr><h3><a name="lua_rawseti"><code>lua_rawseti</code></a></h3><p><br><span class="apii">[-1, +0, <em>e</em>]</span><br></p><pre>void lua_rawseti (lua_State L, int index, int n);</pre><br><br><p><br>Does the equivalent of <code>t[n] = v</code>,<br>where <code>t</code> is the table at the given index<br>and <code>v</code> is the value at the top of the stack.<br><br><br></p><p><br>This function pops the value from the stack.<br>The assignment is raw;<br>that is, it does not invoke metamethods.<br><br><br><br><br><br></p><hr><h3><a name="lua_rawsetp"><code>lua_rawsetp</code></a></h3><p><br><span class="apii">[-1, +0, <em>e</em>]</span><br></p><pre>void lua_rawsetp (lua_State <em>L, int index, const void </em>p);</pre><br><br><p><br>Does the equivalent of <code>t[k] = v</code>,<br>where <code>t</code> is the table at the given index,<br><code>k</code> is the pointer <code>p</code> represented as a light userdata,<br>and <code>v</code> is the value at the top of the stack.<br><br><br></p><p><br>This function pops the value from the stack.<br>The assignment is raw;<br>that is, it does not invoke metamethods.<br><br><br><br><br><br></p><hr><h3><a name="lua_Reader"><code>lua_Reader</code></a></h3><br><pre>typedef const char <em> (</em>lua_Reader) (lua_State <em>L,<br>                                    void </em>data,<br>                                    size_t <em>size);</em></pre><br><br><p><br>The reader function used by <a href="#lua_load"><code>lua_load</code></a>.<br>Every time it needs another piece of the chunk,<br><a href="#lua_load"><code>lua_load</code></a> calls the reader,<br>passing along its <code>data</code> parameter.<br>The reader must return a pointer to a block of memory<br>with a new piece of the chunk<br>and set <code>size</code> to the block size.<br>The block must exist until the reader function is called again.<br>To signal the end of the chunk,<br>the reader must return <code>NULL</code> or set <code>size</code> to zero.<br>The reader function may return pieces of any size greater than zero.<br><br><br><br><br><br></p><hr><h3><a name="lua_register"><code>lua_register</code></a></h3><p><br><span class="apii">[-0, +0, <em>e</em>]</span><br></p><pre>void lua_register (lua_State L, const char <em>name, lua_CFunction f);</em></pre><br><br><p><br>Sets the C function <code>f</code> as the new value of global <code>name</code>.<br>It is defined as a macro:<br><br></p><pre>     #define lua_register(L,n,f) \<br>            (lua_pushcfunction(L, f), lua_setglobal(L, n))<br></pre><br><br><br><br><br><hr><h3><a name="lua_remove"><code>lua_remove</code></a></h3><p><br><span class="apii">[-1, +0, –]</span><br></p><pre>void lua_remove (lua_State L, int index);</pre><br><br><p><br>Removes the element at the given valid index,<br>shifting down the elements above this index to fill the gap.<br>This function cannot be called with a pseudo-index,<br>because a pseudo-index is not an actual stack position.<br><br><br><br><br><br></p><hr><h3><a name="lua_replace"><code>lua_replace</code></a></h3><p><br><span class="apii">[-1, +0, –]</span><br></p><pre>void lua_replace (lua_State <em>L, int index);</em></pre><br><br><p><br>Moves the top element into the given valid index<br>without shifting any element<br>(therefore replacing the value at the given index),<br>and then pops the top element.<br><br><br><br><br><br></p><hr><h3><a name="lua_resume"><code>lua_resume</code></a></h3><p><br><span class="apii">[-?, +?, –]</span><br></p><pre>int lua_resume (lua_State L, lua_State <em>from, int nargs);</em></pre><br><br><p><br>Starts and resumes a coroutine in a given thread.<br><br><br></p><p><br>To start a coroutine,<br>you push onto the thread stack the main function plus any arguments;<br>then you call <a href="#lua_resume"><code>lua_resume</code></a>,<br>with <code>nargs</code> being the number of arguments.<br>This call returns when the coroutine suspends or finishes its execution.<br>When it returns, the stack contains all values passed to <a href="#lua_yield"><code>lua_yield</code></a>,<br>or all values returned by the body function.<br><a href="#lua_resume"><code>lua_resume</code></a> returns<br><a href="#pdf-LUA_YIELD"><code>LUA_YIELD</code></a> if the coroutine yields,<br><a href="#pdf-LUA_OK"><code>LUA_OK</code></a> if the coroutine finishes its execution<br>without errors,<br>or an error code in case of errors (see <a href="#lua_pcall"><code>lua_pcall</code></a>).<br><br><br></p><p><br>In case of errors,<br>the stack is not unwound,<br>so you can use the debug API over it.<br>The error message is on the top of the stack.<br><br><br></p><p><br>To resume a coroutine,<br>you remove any results from the last <a href="#lua_yield"><code>lua_yield</code></a>,<br>put on its stack only the values to<br>be passed as results from <code>yield</code>,<br>and then call <a href="#lua_resume"><code>lua_resume</code></a>.<br><br><br></p><p><br>The parameter <code>from</code> represents the coroutine that is resuming <code>L</code>.<br>If there is no such coroutine,<br>this parameter can be <code>NULL</code>.<br><br><br><br><br><br></p><hr><h3><a name="lua_setallocf"><code>lua_setallocf</code></a></h3><p><br><span class="apii">[-0, +0, –]</span><br></p><pre>void lua_setallocf (lua_State L, lua_Alloc f, void <em>ud);</em></pre><br><br><p><br>Changes the allocator function of a given state to <code>f</code><br>with user data <code>ud</code>.<br><br><br><br><br><br></p><hr><h3><a name="lua_setfield"><code>lua_setfield</code></a></h3><p><br><span class="apii">[-1, +0, <em>e</em>]</span><br></p><pre>void lua_setfield (lua_State L, int index, const char <em>k);</em></pre><br><br><p><br>Does the equivalent to <code>t[k] = v</code>,<br>where <code>t</code> is the value at the given index<br>and <code>v</code> is the value at the top of the stack.<br><br><br></p><p><br>This function pops the value from the stack.<br>As in Lua, this function may trigger a metamethod<br>for the “newindex” event (see <a href="#2.4">§2.4</a>).<br><br><br><br><br><br></p><hr><h3><a name="lua_setglobal"><code>lua_setglobal</code></a></h3><p><br><span class="apii">[-1, +0, <em>e</em>]</span><br></p><pre>void lua_setglobal (lua_State L, const char <em>name);</em></pre><br><br><p><br>Pops a value from the stack and<br>sets it as the new value of global <code>name</code>.<br><br><br><br><br><br></p><hr><h3><a name="lua_setmetatable"><code>lua_setmetatable</code></a></h3><p><br><span class="apii">[-1, +0, –]</span><br></p><pre>void lua_setmetatable (lua_State L, int index);</pre><br><br><p><br>Pops a table from the stack and<br>sets it as the new metatable for the value at the given index.<br><br><br><br><br><br></p><hr><h3><a name="lua_settable"><code>lua_settable</code></a></h3><p><br><span class="apii">[-2, +0, <em>e</em>]</span><br></p><pre>void lua_settable (lua_State <em>L, int index);</em></pre><br><br><p><br>Does the equivalent to <code>t[k] = v</code>,<br>where <code>t</code> is the value at the given index,<br><code>v</code> is the value at the top of the stack,<br>and <code>k</code> is the value just below the top.<br><br><br></p><p><br>This function pops both the key and the value from the stack.<br>As in Lua, this function may trigger a metamethod<br>for the “newindex” event (see <a href="#2.4">§2.4</a>).<br><br><br><br><br><br></p><hr><h3><a name="lua_settop"><code>lua_settop</code></a></h3><p><br><span class="apii">[-?, +?, –]</span><br></p><pre>void lua_settop (lua_State L, int index);</pre><br><br><p><br>Accepts any index, or&nbsp;0,<br>and sets the stack top to this index.<br>If the new top is larger than the old one,<br>then the new elements are filled with <b>nil</b>.<br>If <code>index</code> is&nbsp;0, then all stack elements are removed.<br><br><br><br><br><br></p><hr><h3><a name="lua_setuservalue"><code>lua_setuservalue</code></a></h3><p><br><span class="apii">[-1, +0, –]</span><br></p><pre>void lua_setuservalue (lua_State <em>L, int index);</em></pre><br><br><p><br>Pops a table or <b>nil</b> from the stack and sets it as<br>the new value associated to the userdata at the given index.<br><br><br><br><br><br></p><hr><h3><a name="lua_State"><code>lua_State</code></a></h3><br><pre>typedef struct lua_State lua_State;</pre><br><br><p><br>An opaque structure that points to a thread and indirectly<br>(through the thread) to the whole state of a Lua interpreter.<br>The Lua library is fully reentrant:<br>it has no global variables.<br>All information about a state is accessible through this structure.<br><br><br></p><p><br>A pointer to this structure must be passed as the first argument to<br>every function in the library, except to <a href="#lua_newstate"><code>lua_newstate</code></a>,<br>which creates a Lua state from scratch.<br><br><br><br><br><br></p><hr><h3><a name="lua_status"><code>lua_status</code></a></h3><p><br><span class="apii">[-0, +0, –]</span><br></p><pre>int lua_status (lua_State L);</pre><br><br><p><br>Returns the status of the thread <code>L</code>.<br><br><br></p><p><br>The status can be 0 (<a href="#pdf-LUA_OK"><code>LUA_OK</code></a>) for a normal thread,<br>an error code if the thread finished the execution<br>of a <a href="#lua_resume"><code>lua_resume</code></a> with an error,<br>or <a name="pdf-LUA_YIELD"><code>LUA_YIELD</code></a> if the thread is suspended.<br><br><br></p><p><br>You can only call functions in threads with status <a href="#pdf-LUA_OK"><code>LUA_OK</code></a>.<br>You can resume threads with status <a href="#pdf-LUA_OK"><code>LUA_OK</code></a><br>(to start a new coroutine) or <a href="#pdf-LUA_YIELD"><code>LUA_YIELD</code></a><br>(to resume a coroutine).<br><br><br><br><br><br></p><hr><h3><a name="lua_toboolean"><code>lua_toboolean</code></a></h3><p><br><span class="apii">[-0, +0, –]</span><br></p><pre>int lua_toboolean (lua_State <em>L, int index);</em></pre><br><br><p><br>Converts the Lua value at the given index to a C&nbsp;boolean<br>value (0&nbsp;or&nbsp;1).<br>Like all tests in Lua,<br><a href="#lua_toboolean"><code>lua_toboolean</code></a> returns true for any Lua value<br>different from <b>false</b> and <b>nil</b>;<br>otherwise it returns false.<br>(If you want to accept only actual boolean values,<br>use <a href="#lua_isboolean"><code>lua_isboolean</code></a> to test the value’s type.)<br><br><br><br><br><br></p><hr><h3><a name="lua_tocfunction"><code>lua_tocfunction</code></a></h3><p><br><span class="apii">[-0, +0, –]</span><br></p><pre>lua_CFunction lua_tocfunction (lua_State L, int index);</pre><br><br><p><br>Converts a value at the given index to a C&nbsp;function.<br>That value must be a C&nbsp;function;<br>otherwise, returns <code>NULL</code>.<br><br><br><br><br><br></p><hr><h3><a name="lua_tointeger"><code>lua_tointeger</code></a></h3><p><br><span class="apii">[-0, +0, –]</span><br></p><pre>lua_Integer lua_tointeger (lua_State <em>L, int index);</em></pre><br><br><p><br>Equivalent to <a href="#lua_tointegerx"><code>lua_tointegerx</code></a> with <code>isnum</code> equal to <code>NULL</code>.<br><br><br><br><br><br></p><hr><h3><a name="lua_tointegerx"><code>lua_tointegerx</code></a></h3><p><br><span class="apii">[-0, +0, –]</span><br></p><pre>lua_Integer lua_tointegerx (lua_State L, int index, int <em>isnum);</em></pre><br><br><p><br>Converts the Lua value at the given index<br>to the signed integral type <a href="#lua_Integer"><code>lua_Integer</code></a>.<br>The Lua value must be a number or a string convertible to a number<br>(see <a href="#3.4.2">§3.4.2</a>);<br>otherwise, <code>lua_tointegerx</code> returns&nbsp;0.<br><br><br></p><p><br>If the number is not an integer,<br>it is truncated in some non-specified way.<br><br><br></p><p><br>If <code>isnum</code> is not <code>NULL</code>,<br>its referent is assigned a boolean value that<br>indicates whether the operation succeeded.<br><br><br><br><br><br></p><hr><h3><a name="lua_tolstring"><code>lua_tolstring</code></a></h3><p><br><span class="apii">[-0, +0, <em>e</em>]</span><br></p><pre>const char lua_tolstring (lua_State <em>L, int index, size_t </em>len);</pre><br><br><p><br>Converts the Lua value at the given index to a C&nbsp;string.<br>If <code>len</code> is not <code>NULL</code>,<br>it also sets <code><em>len</em></code> with the string length.<br>The Lua value must be a string or a number;<br>otherwise, the function returns <code>NULL</code>.<br>If the value is a number,<br>then <code>lua_tolstring</code> also<br><em>changes the actual value in the stack to a string</em>.<br>(This change confuses <a href="#lua_next"><code>lua_next</code></a><br>when <code>lua_tolstring</code> is applied to keys during a table traversal.)<br><br><br></p><p><br><code>lua_tolstring</code> returns a fully aligned pointer<br>to a string inside the Lua state.<br>This string always has a zero (‘<code>\0</code>‘)<br>after its last character (as in&nbsp;C),<br>but can contain other zeros in its body.<br>Because Lua has garbage collection,<br>there is no guarantee that the pointer returned by <code>lua_tolstring</code><br>will be valid after the corresponding value is removed from the stack.<br><br><br><br><br><br></p><hr><h3><a name="lua_tonumber"><code>lua_tonumber</code></a></h3><p><br><span class="apii">[-0, +0, –]</span><br></p><pre>lua_Number lua_tonumber (lua_State L, int index);</pre><br><br><p><br>Equivalent to <a href="#lua_tonumberx"><code>lua_tonumberx</code></a> with <code>isnum</code> equal to <code>NULL</code>.<br><br><br><br><br><br></p><hr><h3><a name="lua_tonumberx"><code>lua_tonumberx</code></a></h3><p><br><span class="apii">[-0, +0, –]</span><br></p><pre>lua_Number lua_tonumberx (lua_State <em>L, int index, int </em>isnum);</pre><br><br><p><br>Converts the Lua value at the given index<br>to the C&nbsp;type <a href="#lua_Number"><code>lua_Number</code></a> (see <a href="#lua_Number"><code>lua_Number</code></a>).<br>The Lua value must be a number or a string convertible to a number<br>(see <a href="#3.4.2">§3.4.2</a>);<br>otherwise, <a href="#lua_tonumberx"><code>lua_tonumberx</code></a> returns&nbsp;0.<br><br><br></p><p><br>If <code>isnum</code> is not <code>NULL</code>,<br>its referent is assigned a boolean value that<br>indicates whether the operation succeeded.<br><br><br><br><br><br></p><hr><h3><a name="lua_topointer"><code>lua_topointer</code></a></h3><p><br><span class="apii">[-0, +0, –]</span><br></p><pre>const void <em>lua_topointer (lua_State </em>L, int index);</pre><br><br><p><br>Converts the value at the given index to a generic<br>C&nbsp;pointer (<code>void<em></em></code>).<br>The value can be a userdata, a table, a thread, or a function;<br>otherwise, <code>lua_topointer</code> returns <code>NULL</code>.<br>Different objects will give different pointers.<br>There is no way to convert the pointer back to its original value.<br><br><br></p><p><br>Typically this function is used only for debug information.<br><br><br><br><br><br></p><hr><h3><a name="lua_tostring"><code>lua_tostring</code></a></h3><p><br><span class="apii">[-0, +0, <em>e</em>]</span><br></p><pre>const char lua_tostring (lua_State <em>L, int index);</em></pre><br><br><p><br>Equivalent to <a href="#lua_tolstring"><code>lua_tolstring</code></a> with <code>len</code> equal to <code>NULL</code>.<br><br><br><br><br><br></p><hr><h3><a name="lua_tothread"><code>lua_tothread</code></a></h3><p><br><span class="apii">[-0, +0, –]</span><br></p><pre>lua_State lua_tothread (lua_State <em>L, int index);</em></pre><br><br><p><br>Converts the value at the given index to a Lua thread<br>(represented as <code>lua_State</code>).<br>This value must be a thread;<br>otherwise, the function returns <code>NULL</code>.<br><br><br><br><br><br></p><hr><h3><a name="lua_tounsigned"><code>lua_tounsigned</code></a></h3><p><br><span class="apii">[-0, +0, –]</span><br></p><pre>lua_Unsigned lua_tounsigned (lua_State <em>L, int index);</em></pre><br><br><p><br>Equivalent to <a href="#lua_tounsignedx"><code>lua_tounsignedx</code></a> with <code>isnum</code> equal to <code>NULL</code>.<br><br><br><br><br><br></p><hr><h3><a name="lua_tounsignedx"><code>lua_tounsignedx</code></a></h3><p><br><span class="apii">[-0, +0, –]</span><br></p><pre>lua_Unsigned lua_tounsignedx (lua_State L, int index, int <em>isnum);</em></pre><br><br><p><br>Converts the Lua value at the given index<br>to the unsigned integral type <a href="#lua_Unsigned"><code>lua_Unsigned</code></a>.<br>The Lua value must be a number or a string convertible to a number<br>(see <a href="#3.4.2">§3.4.2</a>);<br>otherwise, <code>lua_tounsignedx</code> returns&nbsp;0.<br><br><br></p><p><br>If the number is not an integer,<br>it is truncated in some non-specified way.<br>If the number is outside the range of representable values,<br>it is normalized to the remainder of its division by<br>one more than the maximum representable value.<br><br><br></p><p><br>If <code>isnum</code> is not <code>NULL</code>,<br>its referent is assigned a boolean value that<br>indicates whether the operation succeeded.<br><br><br><br><br><br></p><hr><h3><a name="lua_touserdata"><code>lua_touserdata</code></a></h3><p><br><span class="apii">[-0, +0, –]</span><br></p><pre>void lua_touserdata (lua_State <em>L, int index);</em></pre><br><br><p><br>If the value at the given index is a full userdata,<br>returns its block address.<br>If the value is a light userdata,<br>returns its pointer.<br>Otherwise, returns <code>NULL</code>.<br><br><br><br><br><br></p><hr><h3><a name="lua_type"><code>lua_type</code></a></h3><p><br><span class="apii">[-0, +0, –]</span><br></p><pre>int lua_type (lua_State L, int index);</pre><br><br><p><br>Returns the type of the value in the given valid index,<br>or <code>LUA_TNONE</code> for a non-valid (but acceptable) index.<br>The types returned by <a href="#lua_type"><code>lua_type</code></a> are coded by the following constants<br>defined in <code>lua.h</code>:<br><a name="pdf-LUA_TNIL"><code>LUA_TNIL</code></a>,<br><a name="pdf-LUA_TNUMBER"><code>LUA_TNUMBER</code></a>,<br><a name="pdf-LUA_TBOOLEAN"><code>LUA_TBOOLEAN</code></a>,<br><a name="pdf-LUA_TSTRING"><code>LUA_TSTRING</code></a>,<br><a name="pdf-LUA_TTABLE"><code>LUA_TTABLE</code></a>,<br><a name="pdf-LUA_TFUNCTION"><code>LUA_TFUNCTION</code></a>,<br><a name="pdf-LUA_TUSERDATA"><code>LUA_TUSERDATA</code></a>,<br><a name="pdf-LUA_TTHREAD"><code>LUA_TTHREAD</code></a>,<br>and<br><a name="pdf-LUA_TLIGHTUSERDATA"><code>LUA_TLIGHTUSERDATA</code></a>.<br><br><br><br><br><br></p><hr><h3><a name="lua_typename"><code>lua_typename</code></a></h3><p><br><span class="apii">[-0, +0, –]</span><br></p><pre>const char <em>lua_typename (lua_State </em>L, int tp);</pre><br><br><p><br>Returns the name of the type encoded by the value <code>tp</code>,<br>which must be one the values returned by <a href="#lua_type"><code>lua_type</code></a>.<br><br><br><br><br><br></p><hr><h3><a name="lua_Unsigned"><code>lua_Unsigned</code></a></h3><br><pre>typedef unsigned long lua_Unsigned;</pre><br><br><p><br>The type used by the Lua API to represent unsigned integral values.<br>It must have at least 32 bits.<br><br><br></p><p><br>By default it is an <code>unsigned int</code> or an <code>unsigned long</code>,<br>whichever can hold 32-bit values.<br><br><br><br><br><br></p><hr><h3><a name="lua_upvalueindex"><code>lua_upvalueindex</code></a></h3><p><br><span class="apii">[-0, +0, –]</span><br></p><pre>int lua_upvalueindex (int i);</pre><br><br><p><br>Returns the pseudo-index that represents the <code>i</code>-th upvalue of<br>the running function (see <a href="#4.4">§4.4</a>).<br><br><br><br><br><br></p><hr><h3><a name="lua_version"><code>lua_version</code></a></h3><p><br><span class="apii">[-0, +0, <em>v</em>]</span><br></p><pre>const lua_Number <em>lua_version (lua_State </em>L);</pre><br><br><p><br>Returns the address of the version number stored in the Lua core.<br>When called with a valid <a href="#lua_State"><code>lua_State</code></a>,<br>returns the address of the version used to create that state.<br>When called with <code>NULL</code>,<br>returns the address of the version running the call.<br><br><br><br><br><br></p><hr><h3><a name="lua_Writer"><code>lua_Writer</code></a></h3><br><pre>typedef int (<em>lua_Writer) (lua_State </em>L,<br>                           const void<em> p,<br>                           size_t sz,<br>                           void</em> ud);</pre><br><br><p><br>The type of the writer function used by <a href="#lua_dump"><code>lua_dump</code></a>.<br>Every time it produces another piece of chunk,<br><a href="#lua_dump"><code>lua_dump</code></a> calls the writer,<br>passing along the buffer to be written (<code>p</code>),<br>its size (<code>sz</code>),<br>and the <code>data</code> parameter supplied to <a href="#lua_dump"><code>lua_dump</code></a>.<br><br><br></p><p><br>The writer returns an error code:<br>0&nbsp;means no errors;<br>any other value means an error and stops <a href="#lua_dump"><code>lua_dump</code></a> from<br>calling the writer again.<br><br><br><br><br><br></p><hr><h3><a name="lua_xmove"><code>lua_xmove</code></a></h3><p><br><span class="apii">[-?, +?, –]</span><br></p><pre>void lua_xmove (lua_State <em>from, lua_State </em>to, int n);</pre><br><br><p><br>Exchange values between different threads of the same state.<br><br><br></p><p><br>This function pops <code>n</code> values from the stack <code>from</code>,<br>and pushes them onto the stack <code>to</code>.<br><br><br><br><br><br></p><hr><h3><a name="lua_yield"><code>lua_yield</code></a></h3><p><br><span class="apii">[-?, +?, –]</span><br></p><pre>int lua_yield (lua_State <em>L, int nresults);</em></pre><br><br><p><br>This function is equivalent to <a href="#lua_yieldk"><code>lua_yieldk</code></a>,<br>but it has no continuation (see <a href="#4.7">§4.7</a>).<br>Therefore, when the thread resumes,<br>it returns to the function that called<br>the function calling <code>lua_yield</code>.<br><br><br><br><br><br></p><hr><h3><a name="lua_yieldk"><code>lua_yieldk</code></a></h3><p><br><span class="apii">[-?, +?, –]</span><br></p><pre>int lua_yieldk (lua_State L, int nresults, int ctx, lua_CFunction k);</pre><br><br><p><br>Yields a coroutine.<br><br><br></p><p><br>This function should only be called as the<br>return expression of a C&nbsp;function, as follows:<br><br></p><pre>     return lua_yieldk (L, n, i, k);<br></pre><p><br>When a C&nbsp;function calls <a href="#lua_yieldk"><code>lua_yieldk</code></a> in that way,<br>the running coroutine suspends its execution,<br>and the call to <a href="#lua_resume"><code>lua_resume</code></a> that started this coroutine returns.<br>The parameter <code>nresults</code> is the number of values from the stack<br>that are passed as results to <a href="#lua_resume"><code>lua_resume</code></a>.<br><br><br></p><p><br>When the coroutine is resumed again,<br>Lua calls the given continuation function <code>k</code> to continue<br>the execution of the C function that yielded (see <a href="#4.7">§4.7</a>).<br>This continuation function receives the same stack<br>from the previous function,<br>with the results removed and<br>replaced by the arguments passed to <a href="#lua_resume"><code>lua_resume</code></a>.<br>Moreover,<br>the continuation function may access the value <code>ctx</code><br>by calling <a href="#lua_getctx"><code>lua_getctx</code></a>.<br><br><br><br><br><br><br><br></p><h2>4.9 – <a name="4.9">The Debug Interface</a></h2><br><br><p><br>Lua has no built-in debugging facilities.<br>Instead, it offers a special interface<br>by means of functions and <em>hooks</em>.<br>This interface allows the construction of different<br>kinds of debuggers, profilers, and other tools<br>that need “inside information” from the interpreter.<br><br><br><br></p><hr><h3><a name="lua_Debug"><code>lua_Debug</code></a></h3><br><pre>typedef struct lua_Debug {<br>  int event;<br>  const char <em>name;           /</em> (n) <em>/<br>  const char </em>namewhat;       /<em> (n) </em>/<br>  const char <em>what;           /</em> (S) <em>/<br>  const char </em>source;         /<em> (S) </em>/<br>  int currentline;            /<em> (l) </em>/<br>  int linedefined;            /<em> (S) </em>/<br>  int lastlinedefined;        /<em> (S) </em>/<br>  unsigned char nups;         /<em> (u) number of upvalues </em>/<br>  unsigned char nparams;      /<em> (u) number of parameters </em>/<br>  char isvararg;              /<em> (u) </em>/<br>  char istailcall;            /<em> (t) </em>/<br>  char short_src[LUA_IDSIZE]; /<em> (S) </em>/<br>  /<em> private part </em>/<br>  <em>other fields</em><br>} lua_Debug;</pre><br><br><p><br>A structure used to carry different pieces of<br>information about a function or an activation record.<br><a href="#lua_getstack"><code>lua_getstack</code></a> fills only the private part<br>of this structure, for later use.<br>To fill the other fields of <a href="#lua_Debug"><code>lua_Debug</code></a> with useful information,<br>call <a href="#lua_getinfo"><code>lua_getinfo</code></a>.<br><br><br></p><p><br>The fields of <a href="#lua_Debug"><code>lua_Debug</code></a> have the following meaning:<br><br></p><ul><br><br><li><b><code>source</code>: </b><br>the source of the chunk that created the function.<br>If <code>source</code> starts with a ‘<code>@</code>‘,<br>it means that the function was defined in a file where<br>the file name follows the ‘<code>@</code>‘.<br>If <code>source</code> starts with a ‘<code>=</code>‘,<br>the remainder of its contents describe the source in a user-dependent manner.<br>Otherwise,<br>the function was defined in a string where<br><code>source</code> is that string.<br></li><br><br><li><b><code>short_src</code>: </b><br>a “printable” version of <code>source</code>, to be used in error messages.<br></li><br><br><li><b><code>linedefined</code>: </b><br>the line number where the definition of the function starts.<br></li><br><br><li><b><code>lastlinedefined</code>: </b><br>the line number where the definition of the function ends.<br></li><br><br><li><b><code>what</code>: </b><br>the string <code>“Lua”</code> if the function is a Lua function,<br><code>“C”</code> if it is a C&nbsp;function,<br><code>“main”</code> if it is the main part of a chunk.<br></li><br><br><li><b><code>currentline</code>: </b><br>the current line where the given function is executing.<br>When no line information is available,<br><code>currentline</code> is set to -1.<br></li><br><br><li><b><code>name</code>: </b><br>a reasonable name for the given function.<br>Because functions in Lua are first-class values,<br>they do not have a fixed name:<br>some functions can be the value of multiple global variables,<br>while others can be stored only in a table field.<br>The <code>lua_getinfo</code> function checks how the function was<br>called to find a suitable name.<br>If it cannot find a name,<br>then <code>name</code> is set to <code>NULL</code>.<br></li><br><br><li><b><code>namewhat</code>: </b><br>explains the <code>name</code> field.<br>The value of <code>namewhat</code> can be<br><code>“global”</code>, <code>“local”</code>, <code>“method”</code>,<br><code>“field”</code>, <code>“upvalue”</code>, or <code>“”</code> (the empty string),<br>according to how the function was called.<br>(Lua uses the empty string when no other option seems to apply.)<br></li><br><br><li><b><code>istailcall</code>: </b><br>true if this function invocation was called by a tail call.<br>In this case, the caller of this level is not in the stack.<br></li><br><br><li><b><code>nups</code>: </b><br>the number of upvalues of the function.<br></li><br><br><li><b><code>nparams</code>: </b><br>the number of fixed parameters of the function<br>(always 0&nbsp;for C&nbsp;functions).<br></li><br><br><li><b><code>isvararg</code>: </b><br>true if the function is a vararg function<br>(always true for C&nbsp;functions).<br></li><br><br></ul><br><br><br><br><br><hr><h3><a name="lua_gethook"><code>lua_gethook</code></a></h3><p><br><span class="apii">[-0, +0, –]</span><br></p><pre>lua_Hook lua_gethook (lua_State <em>L);</em></pre><br><br><p><br>Returns the current hook function.<br><br><br><br><br><br></p><hr><h3><a name="lua_gethookcount"><code>lua_gethookcount</code></a></h3><p><br><span class="apii">[-0, +0, –]</span><br></p><pre>int lua_gethookcount (lua_State L);</pre><br><br><p><br>Returns the current hook count.<br><br><br><br><br><br></p><hr><h3><a name="lua_gethookmask"><code>lua_gethookmask</code></a></h3><p><br><span class="apii">[-0, +0, –]</span><br></p><pre>int lua_gethookmask (lua_State <em>L);</em></pre><br><br><p><br>Returns the current hook mask.<br><br><br><br><br><br></p><hr><h3><a name="lua_getinfo"><code>lua_getinfo</code></a></h3><p><br><span class="apii">[-(0|1), +(0|1|2), <em>e</em>]</span><br></p><pre>int lua_getinfo (lua_State L, const char <em>what, lua_Debug </em>ar);</pre><br><br><p><br>Gets information about a specific function or function invocation.<br><br><br></p><p><br>To get information about a function invocation,<br>the parameter <code>ar</code> must be a valid activation record that was<br>filled by a previous call to <a href="#lua_getstack"><code>lua_getstack</code></a> or<br>given as argument to a hook (see <a href="#lua_Hook"><code>lua_Hook</code></a>).<br><br><br></p><p><br>To get information about a function you push it onto the stack<br>and start the <code>what</code> string with the character ‘<code>&gt;</code>‘.<br>(In that case,<br><code>lua_getinfo</code> pops the function from the top of the stack.)<br>For instance, to know in which line a function <code>f</code> was defined,<br>you can write the following code:<br><br></p><pre>     lua_Debug ar;<br>     lua_getglobal(L, “f”);  /<em> get global ‘f’ </em>/<br>     lua_getinfo(L, “&gt;S”, &amp;ar);<br>     printf(“%d\n”, ar.linedefined);<br></pre><br><br><p><br>Each character in the string <code>what</code><br>selects some fields of the structure <code>ar</code> to be filled or<br>a value to be pushed on the stack:<br><br></p><ul><br><br><li><b>‘<code>n</code>‘: </b> fills in the field <code>name</code> and <code>namewhat</code>;<br></li><br><br><li><b>‘<code>S</code>‘: </b><br>fills in the fields <code>source</code>, <code>short_src</code>,<br><code>linedefined</code>, <code>lastlinedefined</code>, and <code>what</code>;<br></li><br><br><li><b>‘<code>l</code>‘: </b> fills in the field <code>currentline</code>;<br></li><br><br><li><b>‘<code>t</code>‘: </b> fills in the field <code>istailcall</code>;<br></li><br><br><li><b>‘<code>u</code>‘: </b> fills in the fields<br><code>nups</code>, <code>nparams</code>, and <code>isvararg</code>;<br></li><br><br><li><b>‘<code>f</code>‘: </b><br>pushes onto the stack the function that is<br>running at the given level;<br></li><br><br><li><b>‘<code>L</code>‘: </b><br>pushes onto the stack a table whose indices are the<br>numbers of the lines that are valid on the function.<br>(A <em>valid line</em> is a line with some associated code,<br>that is, a line where you can put a break point.<br>Non-valid lines include empty lines and comments.)<br></li><br><br></ul><br><br><p><br>This function returns 0 on error<br>(for instance, an invalid option in <code>what</code>).<br><br><br><br><br><br></p><hr><h3><a name="lua_getlocal"><code>lua_getlocal</code></a></h3><p><br><span class="apii">[-0, +(0|1), –]</span><br></p><pre>const char <em>lua_getlocal (lua_State </em>L, lua_Debug <em>ar, int n);</em></pre><br><br><p><br>Gets information about a local variable of<br>a given activation record or a given function.<br><br><br></p><p><br>In the first case,<br>the parameter <code>ar</code> must be a valid activation record that was<br>filled by a previous call to <a href="#lua_getstack"><code>lua_getstack</code></a> or<br>given as argument to a hook (see <a href="#lua_Hook"><code>lua_Hook</code></a>).<br>The index <code>n</code> selects which local variable to inspect;<br>see <a href="#pdf-debug.getlocal"><code>debug.getlocal</code></a> for details about variable indices<br>and names.<br><br><br></p><p><br><a href="#lua_getlocal"><code>lua_getlocal</code></a> pushes the variable’s value onto the stack<br>and returns its name.<br><br><br></p><p><br>In the second case, <code>ar</code> should be <code>NULL</code> and the function<br>to be inspected must be at the top of the stack.<br>In this case, only parameters of Lua functions are visible<br>(as there is no information about what variables are active)<br>and no values are pushed onto the stack.<br><br><br></p><p><br>Returns <code>NULL</code> (and pushes nothing)<br>when the index is greater than<br>the number of active local variables.<br><br><br><br><br><br></p><hr><h3><a name="lua_getstack"><code>lua_getstack</code></a></h3><p><br><span class="apii">[-0, +0, –]</span><br></p><pre>int lua_getstack (lua_State L, int level, lua_Debug <em>ar);</em></pre><br><br><p><br>Gets information about the interpreter runtime stack.<br><br><br></p><p><br>This function fills parts of a <a href="#lua_Debug"><code>lua_Debug</code></a> structure with<br>an identification of the <em>activation record</em><br>of the function executing at a given level.<br>Level&nbsp;0 is the current running function,<br>whereas level <em>n+1</em> is the function that has called level <em>n</em><br>(except for tail calls, which do not count on the stack).<br>When there are no errors, <a href="#lua_getstack"><code>lua_getstack</code></a> returns 1;<br>when called with a level greater than the stack depth,<br>it returns 0.<br><br><br><br><br><br></p><hr><h3><a name="lua_getupvalue"><code>lua_getupvalue</code></a></h3><p><br><span class="apii">[-0, +(0|1), –]</span><br></p><pre>const char lua_getupvalue (lua_State <em>L, int funcindex, int n);</em></pre><br><br><p><br>Gets information about a closure’s upvalue.<br>(For Lua functions,<br>upvalues are the external local variables that the function uses,<br>and that are consequently included in its closure.)<br><a href="#lua_getupvalue"><code>lua_getupvalue</code></a> gets the index <code>n</code> of an upvalue,<br>pushes the upvalue’s value onto the stack,<br>and returns its name.<br><code>funcindex</code> points to the closure in the stack.<br>(Upvalues have no particular order,<br>as they are active through the whole function.<br>So, they are numbered in an arbitrary order.)<br><br><br></p><p><br>Returns <code>NULL</code> (and pushes nothing)<br>when the index is greater than the number of upvalues.<br>For C&nbsp;functions, this function uses the empty string <code>“”</code><br>as a name for all upvalues.<br><br><br><br><br><br></p><hr><h3><a name="lua_Hook"><code>lua_Hook</code></a></h3><br><pre>typedef void (lua_Hook) (lua_State <em>L, lua_Debug </em>ar);</pre><br><br><p><br>Type for debugging hook functions.<br><br><br></p><p><br>Whenever a hook is called, its <code>ar</code> argument has its field<br><code>event</code> set to the specific event that triggered the hook.<br>Lua identifies these events with the following constants:<br><a name="pdf-LUA_HOOKCALL"><code>LUA_HOOKCALL</code></a>, <a name="pdf-LUA_HOOKRET"><code>LUA_HOOKRET</code></a>,<br><a name="pdf-LUA_HOOKTAILCALL"><code>LUA_HOOKTAILCALL</code></a>, <a name="pdf-LUA_HOOKLINE"><code>LUA_HOOKLINE</code></a>,<br>and <a name="pdf-LUA_HOOKCOUNT"><code>LUA_HOOKCOUNT</code></a>.<br>Moreover, for line events, the field <code>currentline</code> is also set.<br>To get the value of any other field in <code>ar</code>,<br>the hook must call <a href="#lua_getinfo"><code>lua_getinfo</code></a>.<br><br><br></p><p><br>For call events, <code>event</code> can be <code>LUA_HOOKCALL</code>,<br>the normal value, or <code>LUA_HOOKTAILCALL</code>, for a tail call;<br>in this case, there will be no corresponding return event.<br><br><br></p><p><br>While Lua is running a hook, it disables other calls to hooks.<br>Therefore, if a hook calls back Lua to execute a function or a chunk,<br>this execution occurs without any calls to hooks.<br><br><br></p><p><br>Hook functions cannot have continuations,<br>that is, they cannot call <a href="#lua_yieldk"><code>lua_yieldk</code></a>,<br><a href="#lua_pcallk"><code>lua_pcallk</code></a>, or <a href="#lua_callk"><code>lua_callk</code></a> with a non-null <code>k</code>.<br><br><br></p><p><br>Hook functions can yield under the following conditions:<br>Only count and line events can yield<br>and they cannot yield any value;<br>to yield a hook function must finish its execution<br>calling <a href="#lua_yield"><code>lua_yield</code></a> with <code>nresults</code> equal to zero.<br><br><br><br><br><br></p><hr><h3><a name="lua_sethook"><code>lua_sethook</code></a></h3><p><br><span class="apii">[-0, +0, –]</span><br></p><pre>int lua_sethook (lua_State <em>L, lua_Hook f, int mask, int count);</em></pre><br><br><p><br>Sets the debugging hook function.<br><br><br></p><p><br>Argument <code>f</code> is the hook function.<br><code>mask</code> specifies on which events the hook will be called:<br>it is formed by a bitwise or of the constants<br><a name="pdf-LUA_MASKCALL"><code>LUA_MASKCALL</code></a>,<br><a name="pdf-LUA_MASKRET"><code>LUA_MASKRET</code></a>,<br><a name="pdf-LUA_MASKLINE"><code>LUA_MASKLINE</code></a>,<br>and <a name="pdf-LUA_MASKCOUNT"><code>LUA_MASKCOUNT</code></a>.<br>The <code>count</code> argument is only meaningful when the mask<br>includes <code>LUA_MASKCOUNT</code>.<br>For each event, the hook is called as explained below:<br><br></p><ul><br><br><li><b>The call hook: </b> is called when the interpreter calls a function.<br>The hook is called just after Lua enters the new function,<br>before the function gets its arguments.<br></li><br><br><li><b>The return hook: </b> is called when the interpreter returns from a function.<br>The hook is called just before Lua leaves the function.<br>There is no standard way to access the values<br>to be returned by the function.<br></li><br><br><li><b>The line hook: </b> is called when the interpreter is about to<br>start the execution of a new line of code,<br>or when it jumps back in the code (even to the same line).<br>(This event only happens while Lua is executing a Lua function.)<br></li><br><br><li><b>The count hook: </b> is called after the interpreter executes every<br><code>count</code> instructions.<br>(This event only happens while Lua is executing a Lua function.)<br></li><br><br></ul><br><br><p><br>A hook is disabled by setting <code>mask</code> to zero.<br><br><br><br><br><br></p><hr><h3><a name="lua_setlocal"><code>lua_setlocal</code></a></h3><p><br><span class="apii">[-(0|1), +0, –]</span><br></p><pre>const char lua_setlocal (lua_State <em>L, lua_Debug </em>ar, int n);</pre><br><br><p><br>Sets the value of a local variable of a given activation record.<br>Parameters <code>ar</code> and <code>n</code> are as in <a href="#lua_getlocal"><code>lua_getlocal</code></a><br>(see <a href="#lua_getlocal"><code>lua_getlocal</code></a>).<br><a href="#lua_setlocal"><code>lua_setlocal</code></a> assigns the value at the top of the stack<br>to the variable and returns its name.<br>It also pops the value from the stack.<br><br><br></p><p><br>Returns <code>NULL</code> (and pops nothing)<br>when the index is greater than<br>the number of active local variables.<br><br><br><br><br><br></p><hr><h3><a name="lua_setupvalue"><code>lua_setupvalue</code></a></h3><p><br><span class="apii">[-(0|1), +0, –]</span><br></p><pre>const char <em>lua_setupvalue (lua_State </em>L, int funcindex, int n);</pre><br><br><p><br>Sets the value of a closure’s upvalue.<br>It assigns the value at the top of the stack<br>to the upvalue and returns its name.<br>It also pops the value from the stack.<br>Parameters <code>funcindex</code> and <code>n</code> are as in the <a href="#lua_getupvalue"><code>lua_getupvalue</code></a><br>(see <a href="#lua_getupvalue"><code>lua_getupvalue</code></a>).<br><br><br></p><p><br>Returns <code>NULL</code> (and pops nothing)<br>when the index is greater than the number of upvalues.<br><br><br><br><br><br></p><hr><h3><a name="lua_upvalueid"><code>lua_upvalueid</code></a></h3><p><br><span class="apii">[-0, +0, –]</span><br></p><pre>void <em>lua_upvalueid (lua_State </em>L, int funcindex, int n);</pre><br><br><p><br>Returns an unique identifier for the upvalue numbered <code>n</code><br>from the closure at index <code>funcindex</code>.<br>Parameters <code>funcindex</code> and <code>n</code> are as in the <a href="#lua_getupvalue"><code>lua_getupvalue</code></a><br>(see <a href="#lua_getupvalue"><code>lua_getupvalue</code></a>)<br>(but <code>n</code> cannot be greater than the number of upvalues).<br><br><br></p><p><br>These unique identifiers allow a program to check whether different<br>closures share upvalues.<br>Lua closures that share an upvalue<br>(that is, that access a same external local variable)<br>will return identical ids for those upvalue indices.<br><br><br><br><br><br></p><hr><h3><a name="lua_upvaluejoin"><code>lua_upvaluejoin</code></a></h3><p><br><span class="apii">[-0, +0, –]</span><br></p><pre>void lua_upvaluejoin (lua<em>State *L, int funcindex1, int n1,<br>                                    int funcindex2, int n2);</em></pre><br><br><p><br>Make the <code>n1</code>-th upvalue of the Lua closure at index <code>funcindex1</code><br>refer to the <code>n2</code>-th upvalue of the Lua closure at index <code>funcindex2</code>.<br><br><br><br><br><br><br><br></p><h1>5 – <a name="5">The Auxiliary Library</a></h1><br><br><p><br><br>The <em>auxiliary library</em> provides several convenient functions<br>to interface C with Lua.<br>While the basic API provides the primitive functions for all<br>interactions between C and Lua,<br>the auxiliary library provides higher-level functions for some<br>common tasks.<br><br><br></p><p><br>All functions and types from the auxiliary library<br>are defined in header file <code>lauxlib.h</code> and<br>have a prefix <code>luaL</code>.<br><br><br></p><p><br>All functions in the auxiliary library are built on<br>top of the basic API,<br>and so they provide nothing that cannot be done with that API.<br>Nevertheless, the use of the auxiliary library ensures<br>more consistency to your code.<br><br><br></p><p><br>Several functions in the auxiliary library use internally some<br>extra stack slots.<br>When a function in the auxiliary library uses less than five slots,<br>it does not check the stack size;<br>it simply assumes that there are enough slots.<br><br><br></p><p><br>Several functions in the auxiliary library are used to<br>check C&nbsp;function arguments.<br>Because the error message is formatted for arguments<br>(e.g., “<code>bad argument #1</code>“),<br>you should not use these functions for other stack values.<br><br><br></p><p><br>Functions called <code>luaL_check<em></em></code><br>always throw an error if the check is not satisfied.<br><br><br><br></p><h2>5.1 – <a name="5.1">Functions and Types</a></h2><br><br><p><br>Here we list all functions and types from the auxiliary library<br>in alphabetical order.<br><br><br><br></p><hr><h3><a name="luaL_addchar"><code>luaL_addchar</code></a></h3><p><br><span class="apii">[-?, +?, <em>e</em>]</span><br></p><pre>void luaL_addchar (luaL_Buffer B, char c);</pre><br><br><p><br>Adds the byte <code>c</code> to the buffer <code>B</code><br>(see <a href="#luaL_Buffer"><code>luaL_Buffer</code></a>).<br><br><br><br><br><br></p><hr><h3><a name="luaL_addlstring"><code>luaL_addlstring</code></a></h3><p><br><span class="apii">[-?, +?, <em>e</em>]</span><br></p><pre>void luaL_addlstring (luaL_Buffer <em>B, const char </em>s, size_t l);</pre><br><br><p><br>Adds the string pointed to by <code>s</code> with length <code>l</code> to<br>the buffer <code>B</code><br>(see <a href="#luaL_Buffer"><code>luaL_Buffer</code></a>).<br>The string can contain embedded zeros.<br><br><br><br><br><br></p><hr><h3><a name="luaL_addsize"><code>luaL_addsize</code></a></h3><p><br><span class="apii">[-?, +?, <em>e</em>]</span><br></p><pre>void luaL_addsize (luaL_Buffer <em>B, size_t n);</em></pre><br><br><p><br>Adds to the buffer <code>B</code> (see <a href="#luaL_Buffer"><code>luaL_Buffer</code></a>)<br>a string of length <code>n</code> previously copied to the<br>buffer area (see <a href="#luaL_prepbuffer"><code>luaL_prepbuffer</code></a>).<br><br><br><br><br><br></p><hr><h3><a name="luaL_addstring"><code>luaL_addstring</code></a></h3><p><br><span class="apii">[-?, +?, <em>e</em>]</span><br></p><pre>void luaL_addstring (luaL_Buffer B, const char <em>s);</em></pre><br><br><p><br>Adds the zero-terminated string pointed to by <code>s</code><br>to the buffer <code>B</code><br>(see <a href="#luaL_Buffer"><code>luaL_Buffer</code></a>).<br>The string cannot contain embedded zeros.<br><br><br><br><br><br></p><hr><h3><a name="luaL_addvalue"><code>luaL_addvalue</code></a></h3><p><br><span class="apii">[-1, +?, <em>e</em>]</span><br></p><pre>void luaL_addvalue (luaL_Buffer B);</pre><br><br><p><br>Adds the value at the top of the stack<br>to the buffer <code>B</code><br>(see <a href="#luaL_Buffer"><code>luaL_Buffer</code></a>).<br>Pops the value.<br><br><br></p><p><br>This is the only function on string buffers that can (and must)<br>be called with an extra element on the stack,<br>which is the value to be added to the buffer.<br><br><br><br><br><br></p><hr><h3><a name="luaL_argcheck"><code>luaL_argcheck</code></a></h3><p><br><span class="apii">[-0, +0, <em>v</em>]</span><br></p><pre>void luaL_argcheck (lua_State <em>L,<br>                    int cond,<br>                    int arg,<br>                    const char </em>extramsg);</pre><br><br><p><br>Checks whether <code>cond</code> is true.<br>If not, raises an error with a standard message.<br><br><br><br><br><br></p><hr><h3><a name="luaL_argerror"><code>luaL_argerror</code></a></h3><p><br><span class="apii">[-0, +0, <em>v</em>]</span><br></p><pre>int luaL_argerror (lua_State <em>L, int arg, const char </em>extramsg);</pre><br><br><p><br>Raises an error with a standard message<br>that includes <code>extramsg</code> as a comment.<br><br><br></p><p><br>This function never returns,<br>but it is an idiom to use it in C&nbsp;functions<br>as <code>return luaL_argerror(<em>args</em>)</code>.<br><br><br><br><br><br></p><hr><h3><a name="luaL_Buffer"><code>luaL_Buffer</code></a></h3><br><pre>typedef struct luaL_Buffer luaL_Buffer;</pre><br><br><p><br>Type for a <em>string buffer</em>.<br><br><br></p><p><br>A string buffer allows C&nbsp;code to build Lua strings piecemeal.<br>Its pattern of use is as follows:<br><br></p><ul><br><br><li>First declare a variable <code>b</code> of type <a href="#luaL_Buffer"><code>luaL_Buffer</code></a>.</li><br><br><li>Then initialize it with a call <code>luaL_buffinit(L, &amp;b)</code>.</li><br><br><li><br>Then add string pieces to the buffer calling any of<br>the <code>luaL_add<em></em></code> functions.<br></li><br><br><li><br>Finish by calling <code>luaL_pushresult(&amp;b)</code>.<br>This call leaves the final string on the top of the stack.<br></li><br><br></ul><br><br><p><br>If you know beforehand the total size of the resulting string,<br>you can use the buffer like this:<br><br></p><ul><br><br><li>First declare a variable <code>b</code> of type <a href="#luaL_Buffer"><code>luaL_Buffer</code></a>.</li><br><br><li>Then initialize it and preallocate a space of<br>size <code>sz</code> with a call <code>luaL_buffinitsize(L, &amp;b, sz)</code>.</li><br><br><li>Then copy the string into that space.</li><br><br><li><br>Finish by calling <code>luaL_pushresultsize(&amp;b, sz)</code>,<br>where <code>sz</code> is the total size of the resulting string<br>copied into that space.<br></li><br><br></ul><br><br><p><br>During its normal operation,<br>a string buffer uses a variable number of stack slots.<br>So, while using a buffer, you cannot assume that you know where<br>the top of the stack is.<br>You can use the stack between successive calls to buffer operations<br>as long as that use is balanced;<br>that is,<br>when you call a buffer operation,<br>the stack is at the same level<br>it was immediately after the previous buffer operation.<br>(The only exception to this rule is <a href="#luaL_addvalue"><code>luaL_addvalue</code></a>.)<br>After calling <a href="#luaL_pushresult"><code>luaL_pushresult</code></a> the stack is back to its<br>level when the buffer was initialized,<br>plus the final string on its top.<br><br><br><br><br><br></p><hr><h3><a name="luaL_buffinit"><code>luaL_buffinit</code></a></h3><p><br><span class="apii">[-0, +0, –]</span><br></p><pre>void luaL_buffinit (lua_State L, luaL_Buffer <em>B);</em></pre><br><br><p><br>Initializes a buffer <code>B</code>.<br>This function does not allocate any space;<br>the buffer must be declared as a variable<br>(see <a href="#luaL_Buffer"><code>luaL_Buffer</code></a>).<br><br><br><br><br><br></p><hr><h3><a name="luaL_buffinitsize"><code>luaL_buffinitsize</code></a></h3><p><br><span class="apii">[-?, +?, <em>e</em>]</span><br></p><pre>char luaL_buffinitsize (lua_State <em>L, luaL_Buffer </em>B, size_t sz);</pre><br><br><p><br>Equivalent to the sequence<br><a href="#luaL_buffinit"><code>luaL_buffinit</code></a>, <a href="#luaL_prepbuffsize"><code>luaL_prepbuffsize</code></a>.<br><br><br><br><br><br></p><hr><h3><a name="luaL_callmeta"><code>luaL_callmeta</code></a></h3><p><br><span class="apii">[-0, +(0|1), <em>e</em>]</span><br></p><pre>int luaL_callmeta (lua_State <em>L, int obj, const char </em>e);</pre><br><br><p><br>Calls a metamethod.<br><br><br></p><p><br>If the object at index <code>obj</code> has a metatable and this<br>metatable has a field <code>e</code>,<br>this function calls this field passing the object as its only argument.<br>In this case this function returns true and pushes onto the<br>stack the value returned by the call.<br>If there is no metatable or no metamethod,<br>this function returns false (without pushing any value on the stack).<br><br><br><br><br><br></p><hr><h3><a name="luaL_checkany"><code>luaL_checkany</code></a></h3><p><br><span class="apii">[-0, +0, <em>v</em>]</span><br></p><pre>void luaL_checkany (lua_State <em>L, int arg);</em></pre><br><br><p><br>Checks whether the function has an argument<br>of any type (including <b>nil</b>) at position <code>arg</code>.<br><br><br><br><br><br></p><hr><h3><a name="luaL_checkint"><code>luaL_checkint</code></a></h3><p><br><span class="apii">[-0, +0, <em>v</em>]</span><br></p><pre>int luaL_checkint (lua_State L, int arg);</pre><br><br><p><br>Checks whether the function argument <code>arg</code> is a number<br>and returns this number cast to an <code>int</code>.<br><br><br><br><br><br></p><hr><h3><a name="luaL_checkinteger"><code>luaL_checkinteger</code></a></h3><p><br><span class="apii">[-0, +0, <em>v</em>]</span><br></p><pre>lua_Integer luaL_checkinteger (lua_State <em>L, int arg);</em></pre><br><br><p><br>Checks whether the function argument <code>arg</code> is a number<br>and returns this number cast to a <a href="#lua_Integer"><code>lua_Integer</code></a>.<br><br><br><br><br><br></p><hr><h3><a name="luaL_checklong"><code>luaL_checklong</code></a></h3><p><br><span class="apii">[-0, +0, <em>v</em>]</span><br></p><pre>long luaL_checklong (lua_State L, int arg);</pre><br><br><p><br>Checks whether the function argument <code>arg</code> is a number<br>and returns this number cast to a <code>long</code>.<br><br><br><br><br><br></p><hr><h3><a name="luaL_checklstring"><code>luaL_checklstring</code></a></h3><p><br><span class="apii">[-0, +0, <em>v</em>]</span><br></p><pre>const char <em>luaL_checklstring (lua_State </em>L, int arg, size_t <em>l);</em></pre><br><br><p><br>Checks whether the function argument <code>arg</code> is a string<br>and returns this string;<br>if <code>l</code> is not <code>NULL</code> fills <code>l</code><br>with the string’s length.<br><br><br></p><p><br>This function uses <a href="#lua_tolstring"><code>lua_tolstring</code></a> to get its result,<br>so all conversions and caveats of that function apply here.<br><br><br><br><br><br></p><hr><h3><a name="luaL_checknumber"><code>luaL_checknumber</code></a></h3><p><br><span class="apii">[-0, +0, <em>v</em>]</span><br></p><pre>lua_Number luaL_checknumber (lua_State <em>L, int arg);</em></pre><br><br><p><br>Checks whether the function argument <code>arg</code> is a number<br>and returns this number.<br><br><br><br><br><br></p><hr><h3><a name="luaL_checkoption"><code>luaL_checkoption</code></a></h3><p><br><span class="apii">[-0, +0, <em>v</em>]</span><br></p><pre>int luaL_checkoption (lua_State L,<br>                      int arg,<br>                      const char <em>def,<br>                      const char </em>const lst[]);</pre><br><br><p><br>Checks whether the function argument <code>arg</code> is a string and<br>searches for this string in the array <code>lst</code><br>(which must be NULL-terminated).<br>Returns the index in the array where the string was found.<br>Raises an error if the argument is not a string or<br>if the string cannot be found.<br><br><br></p><p><br>If <code>def</code> is not <code>NULL</code>,<br>the function uses <code>def</code> as a default value when<br>there is no argument <code>arg</code> or when this argument is <b>nil</b>.<br><br><br></p><p><br>This is a useful function for mapping strings to C&nbsp;enums.<br>(The usual convention in Lua libraries is<br>to use strings instead of numbers to select options.)<br><br><br><br><br><br></p><hr><h3><a name="luaL_checkstack"><code>luaL_checkstack</code></a></h3><p><br><span class="apii">[-0, +0, <em>v</em>]</span><br></p><pre>void luaL_checkstack (lua_State <em>L, int sz, const char </em>msg);</pre><br><br><p><br>Grows the stack size to <code>top + sz</code> elements,<br>raising an error if the stack cannot grow to that size.<br><code>msg</code> is an additional text to go into the error message<br>(or <code>NULL</code> for no additional text).<br><br><br><br><br><br></p><hr><h3><a name="luaL_checkstring"><code>luaL_checkstring</code></a></h3><p><br><span class="apii">[-0, +0, <em>v</em>]</span><br></p><pre>const char <em>luaL_checkstring (lua_State </em>L, int arg);</pre><br><br><p><br>Checks whether the function argument <code>arg</code> is a string<br>and returns this string.<br><br><br></p><p><br>This function uses <a href="#lua_tolstring"><code>lua_tolstring</code></a> to get its result,<br>so all conversions and caveats of that function apply here.<br><br><br><br><br><br></p><hr><h3><a name="luaL_checktype"><code>luaL_checktype</code></a></h3><p><br><span class="apii">[-0, +0, <em>v</em>]</span><br></p><pre>void luaL_checktype (lua_State <em>L, int arg, int t);</em></pre><br><br><p><br>Checks whether the function argument <code>arg</code> has type <code>t</code>.<br>See <a href="#lua_type"><code>lua_type</code></a> for the encoding of types for <code>t</code>.<br><br><br><br><br><br></p><hr><h3><a name="luaL_checkudata"><code>luaL_checkudata</code></a></h3><p><br><span class="apii">[-0, +0, <em>v</em>]</span><br></p><pre>void luaL_checkudata (lua_State <em>L, int arg, const char </em>tname);</pre><br><br><p><br>Checks whether the function argument <code>arg</code> is a userdata<br>of the type <code>tname</code> (see <a href="#luaL_newmetatable"><code>luaL_newmetatable</code></a>) and<br>returns the userdata address (see <a href="#lua_touserdata"><code>lua_touserdata</code></a>).<br><br><br><br><br><br></p><hr><h3><a name="luaL_checkunsigned"><code>luaL_checkunsigned</code></a></h3><p><br><span class="apii">[-0, +0, <em>v</em>]</span><br></p><pre>lua_Unsigned luaL_checkunsigned (lua_State <em>L, int arg);</em></pre><br><br><p><br>Checks whether the function argument <code>arg</code> is a number<br>and returns this number cast to a <a href="#lua_Unsigned"><code>lua_Unsigned</code></a>.<br><br><br><br><br><br></p><hr><h3><a name="luaL_checkversion"><code>luaL_checkversion</code></a></h3><p><br><span class="apii">[-0, +0, –]</span><br></p><pre>void luaL_checkversion (lua_State L);</pre><br><br><p><br>Checks whether the core running the call,<br>the core that created the Lua state,<br>and the code making the call are all using the same version of Lua.<br>Also checks whether the core running the call<br>and the core that created the Lua state<br>are using the same address space.<br><br><br><br><br><br></p><hr><h3><a name="luaL_dofile"><code>luaL_dofile</code></a></h3><p><br><span class="apii">[-0, +?, <em>e</em>]</span><br></p><pre>int luaL_dofile (lua_State <em>L, const char </em>filename);</pre><br><br><p><br>Loads and runs the given file.<br>It is defined as the following macro:<br><br></p><pre>     (luaL_loadfile(L, filename) || lua_pcall(L, 0, LUA_MULTRET, 0))<br></pre><p><br>It returns false if there are no errors<br>or true in case of errors.<br><br><br><br><br><br></p><hr><h3><a name="luaL_dostring"><code>luaL_dostring</code></a></h3><p><br><span class="apii">[-0, +?, –]</span><br></p><pre>int luaL_dostring (lua_State <em>L, const char </em>str);</pre><br><br><p><br>Loads and runs the given string.<br>It is defined as the following macro:<br><br></p><pre>     (luaL_loadstring(L, str) || lua_pcall(L, 0, LUA_MULTRET, 0))<br></pre><p><br>It returns false if there are no errors<br>or true in case of errors.<br><br><br><br><br><br></p><hr><h3><a name="luaL_error"><code>luaL_error</code></a></h3><p><br><span class="apii">[-0, +0, <em>v</em>]</span><br></p><pre>int luaL_error (lua_State <em>L, const char </em>fmt, …);</pre><br><br><p><br>Raises an error.<br>The error message format is given by <code>fmt</code><br>plus any extra arguments,<br>following the same rules of <a href="#lua_pushfstring"><code>lua_pushfstring</code></a>.<br>It also adds at the beginning of the message the file name and<br>the line number where the error occurred,<br>if this information is available.<br><br><br></p><p><br>This function never returns,<br>but it is an idiom to use it in C&nbsp;functions<br>as <code>return luaL_error(<em>args</em>)</code>.<br><br><br><br><br><br></p><hr><h3><a name="luaL_execresult"><code>luaL_execresult</code></a></h3><p><br><span class="apii">[-0, +3, <em>e</em>]</span><br></p><pre>int luaL_execresult (lua_State <em>L, int stat);</em></pre><br><br><p><br>This function produces the return values for<br>process-related functions in the standard library<br>(<a href="#pdf-os.execute"><code>os.execute</code></a> and <a href="#pdf-io.close"><code>io.close</code></a>).<br><br><br><br><br><br></p><hr><h3><a name="luaL_fileresult"><code>luaL_fileresult</code></a></h3><p><br><span class="apii">[-0, +(1|3), <em>e</em>]</span><br></p><pre>int luaL_fileresult (lua_State L, int stat, const char <em>fname);</em></pre><br><br><p><br>This function produces the return values for<br>file-related functions in the standard library<br>(<a href="#pdf-io.open"><code>io.open</code></a>, <a href="#pdf-os.rename"><code>os.rename</code></a>, <a href="#pdf-file:seek"><code>file:seek</code></a>, etc.).<br><br><br><br><br><br></p><hr><h3><a name="luaL_getmetafield"><code>luaL_getmetafield</code></a></h3><p><br><span class="apii">[-0, +(0|1), <em>e</em>]</span><br></p><pre>int luaL_getmetafield (lua_State L, int obj, const char <em>e);</em></pre><br><br><p><br>Pushes onto the stack the field <code>e</code> from the metatable<br>of the object at index <code>obj</code>.<br>If the object does not have a metatable,<br>or if the metatable does not have this field,<br>returns false and pushes nothing.<br><br><br><br><br><br></p><hr><h3><a name="luaL_getmetatable"><code>luaL_getmetatable</code></a></h3><p><br><span class="apii">[-0, +1, –]</span><br></p><pre>void luaL_getmetatable (lua_State L, const char <em>tname);</em></pre><br><br><p><br>Pushes onto the stack the metatable associated with name <code>tname</code><br>in the registry (see <a href="#luaL_newmetatable"><code>luaL_newmetatable</code></a>).<br><br><br><br><br><br></p><hr><h3><a name="luaL_getsubtable"><code>luaL_getsubtable</code></a></h3><p><br><span class="apii">[-0, +1, <em>e</em>]</span><br></p><pre>int luaL_getsubtable (lua_State L, int idx, const char <em>fname);</em></pre><br><br><p><br>Ensures that the value <code>t[fname]</code>,<br>where <code>t</code> is the value at index <code>idx</code>,<br>is a table,<br>and pushes that table onto the stack.<br>Returns true if it finds a previous table there<br>and false if it creates a new table.<br><br><br><br><br><br></p><hr><h3><a name="luaL_gsub"><code>luaL_gsub</code></a></h3><p><br><span class="apii">[-0, +1, <em>e</em>]</span><br></p><pre>const char luaL_gsub (lua_State <em>L,<br>                       const char </em>s,<br>                       const char <em>p,<br>                       const char </em>r);</pre><br><br><p><br>Creates a copy of string <code>s</code> by replacing<br>any occurrence of the string <code>p</code><br>with the string <code>r</code>.<br>Pushes the resulting string on the stack and returns it.<br><br><br><br><br><br></p><hr><h3><a name="luaL_len"><code>luaL_len</code></a></h3><p><br><span class="apii">[-0, +0, <em>e</em>]</span><br></p><pre>int luaL_len (lua_State <em>L, int index);</em></pre><br><br><p><br>Returns the “length” of the value at the given index<br>as a number;<br>it is equivalent to the ‘<code>#</code>‘ operator in Lua (see <a href="#3.4.6">§3.4.6</a>).<br>Raises an error if the result of the operation is not a number.<br>(This case only can happen through metamethods.)<br><br><br><br><br><br></p><hr><h3><a name="luaL_loadbuffer"><code>luaL_loadbuffer</code></a></h3><p><br><span class="apii">[-0, +1, –]</span><br></p><pre>int luaL_loadbuffer (lua_State L,<br>                     const char <em>buff,<br>                     size_t sz,<br>                     const char </em>name);</pre><br><br><p><br>Equivalent to <a href="#luaL_loadbufferx"><code>luaL_loadbufferx</code></a> with <code>mode</code> equal to <code>NULL</code>.<br><br><br><br><br><br></p><hr><h3><a name="luaL_loadbufferx"><code>luaL_loadbufferx</code></a></h3><p><br><span class="apii">[-0, +1, –]</span><br></p><pre>int luaL_loadbufferx (lua_State <em>L,<br>                      const char </em>buff,<br>                      size_t sz,<br>                      const char <em>name,<br>                      const char </em>mode);</pre><br><br><p><br>Loads a buffer as a Lua chunk.<br>This function uses <a href="#lua_load"><code>lua_load</code></a> to load the chunk in the<br>buffer pointed to by <code>buff</code> with size <code>sz</code>.<br><br><br></p><p><br>This function returns the same results as <a href="#lua_load"><code>lua_load</code></a>.<br><code>name</code> is the chunk name,<br>used for debug information and error messages.<br>The string <code>mode</code> works as in function <a href="#lua_load"><code>lua_load</code></a>.<br><br><br><br><br><br></p><hr><h3><a name="luaL_loadfile"><code>luaL_loadfile</code></a></h3><p><br><span class="apii">[-0, +1, <em>e</em>]</span><br></p><pre>int luaL_loadfile (lua_State <em>L, const char </em>filename);</pre><br><br><p><br>Equivalent to <a href="#luaL_loadfilex"><code>luaL_loadfilex</code></a> with <code>mode</code> equal to <code>NULL</code>.<br><br><br><br><br><br></p><hr><h3><a name="luaL_loadfilex"><code>luaL_loadfilex</code></a></h3><p><br><span class="apii">[-0, +1, <em>e</em>]</span><br></p><pre>int luaL_loadfilex (lua_State <em>L, const char </em>filename,<br>                                            const char <em>mode);</em></pre><br><br><p><br>Loads a file as a Lua chunk.<br>This function uses <a href="#lua_load"><code>lua_load</code></a> to load the chunk in the file<br>named <code>filename</code>.<br>If <code>filename</code> is <code>NULL</code>,<br>then it loads from the standard input.<br>The first line in the file is ignored if it starts with a <code>#</code>.<br><br><br></p><p><br>The string <code>mode</code> works as in function <a href="#lua_load"><code>lua_load</code></a>.<br><br><br></p><p><br>This function returns the same results as <a href="#lua_load"><code>lua_load</code></a>,<br>but it has an extra error code <a name="pdf-LUA_ERRFILE"><code>LUA_ERRFILE</code></a><br>if it cannot open/read the file or the file has a wrong mode.<br><br><br></p><p><br>As <a href="#lua_load"><code>lua_load</code></a>, this function only loads the chunk;<br>it does not run it.<br><br><br><br><br><br></p><hr><h3><a name="luaL_loadstring"><code>luaL_loadstring</code></a></h3><p><br><span class="apii">[-0, +1, –]</span><br></p><pre>int luaL_loadstring (lua_State L, const char <em>s);</em></pre><br><br><p><br>Loads a string as a Lua chunk.<br>This function uses <a href="#lua_load"><code>lua_load</code></a> to load the chunk in<br>the zero-terminated string <code>s</code>.<br><br><br></p><p><br>This function returns the same results as <a href="#lua_load"><code>lua_load</code></a>.<br><br><br></p><p><br>Also as <a href="#lua_load"><code>lua_load</code></a>, this function only loads the chunk;<br>it does not run it.<br><br><br><br><br><br></p><hr><h3><a name="luaL_newlib"><code>luaL_newlib</code></a></h3><p><br><span class="apii">[-0, +1, <em>e</em>]</span><br></p><pre>void luaL_newlib (lua_State L, const luaL_Reg <em>l);</em></pre><br><br><p><br>Creates a new table and registers there<br>the functions in list <code>l</code>.<br>It is implemented as the following macro:<br><br></p><pre>     (luaL_newlibtable(L,l), luaL_setfuncs(L,l,0))<br></pre><br><br><br><br><br><hr><h3><a name="luaL_newlibtable"><code>luaL_newlibtable</code></a></h3><p><br><span class="apii">[-0, +1, <em>e</em>]</span><br></p><pre>void luaL_newlibtable (lua_State L, const luaL_Reg l[]);</pre><br><br><p><br>Creates a new table with a size optimized<br>to store all entries in the array <code>l</code><br>(but does not actually store them).<br>It is intended to be used in conjunction with <a href="#luaL_setfuncs"><code>luaL_setfuncs</code></a><br>(see <a href="#luaL_newlib"><code>luaL_newlib</code></a>).<br><br><br></p><p><br>It is implemented as a macro.<br>The array <code>l</code> must be the actual array,<br>not a pointer to it.<br><br><br><br><br><br></p><hr><h3><a name="luaL_newmetatable"><code>luaL_newmetatable</code></a></h3><p><br><span class="apii">[-0, +1, <em>e</em>]</span><br></p><pre>int luaL_newmetatable (lua_State <em>L, const char </em>tname);</pre><br><br><p><br>If the registry already has the key <code>tname</code>,<br>returns 0.<br>Otherwise,<br>creates a new table to be used as a metatable for userdata,<br>adds it to the registry with key <code>tname</code>,<br>and returns 1.<br><br><br></p><p><br>In both cases pushes onto the stack the final value associated<br>with <code>tname</code> in the registry.<br><br><br><br><br><br></p><hr><h3><a name="luaL_newstate"><code>luaL_newstate</code></a></h3><p><br><span class="apii">[-0, +0, –]</span><br></p><pre>lua_State <em>luaL_newstate (void);</em></pre><br><br><p><br>Creates a new Lua state.<br>It calls <a href="#lua_newstate"><code>lua_newstate</code></a> with an<br>allocator based on the standard&nbsp;C <code>realloc</code> function<br>and then sets a panic function (see <a href="#4.6">§4.6</a>) that prints<br>an error message to the standard error output in case of fatal<br>errors.<br><br><br></p><p><br>Returns the new state,<br>or <code>NULL</code> if there is a memory allocation error.<br><br><br><br><br><br></p><hr><h3><a name="luaL_openlibs"><code>luaL_openlibs</code></a></h3><p><br><span class="apii">[-0, +0, <em>e</em>]</span><br></p><pre>void luaL_openlibs (lua_State L);</pre><br><br><p><br>Opens all standard Lua libraries into the given state.<br><br><br><br><br><br></p><hr><h3><a name="luaL_optint"><code>luaL_optint</code></a></h3><p><br><span class="apii">[-0, +0, <em>v</em>]</span><br></p><pre>int luaL_optint (lua_State <em>L, int arg, int d);</em></pre><br><br><p><br>If the function argument <code>arg</code> is a number,<br>returns this number cast to an <code>int</code>.<br>If this argument is absent or is <b>nil</b>,<br>returns <code>d</code>.<br>Otherwise, raises an error.<br><br><br><br><br><br></p><hr><h3><a name="luaL_optinteger"><code>luaL_optinteger</code></a></h3><p><br><span class="apii">[-0, +0, <em>v</em>]</span><br></p><pre>lua_Integer luaL_optinteger (lua_State L,<br>                             int arg,<br>                             lua_Integer d);</pre><br><br><p><br>If the function argument <code>arg</code> is a number,<br>returns this number cast to a <a href="#lua_Integer"><code>lua_Integer</code></a>.<br>If this argument is absent or is <b>nil</b>,<br>returns <code>d</code>.<br>Otherwise, raises an error.<br><br><br><br><br><br></p><hr><h3><a name="luaL_optlong"><code>luaL_optlong</code></a></h3><p><br><span class="apii">[-0, +0, <em>v</em>]</span><br></p><pre>long luaL_optlong (lua_State <em>L, int arg, long d);</em></pre><br><br><p><br>If the function argument <code>arg</code> is a number,<br>returns this number cast to a <code>long</code>.<br>If this argument is absent or is <b>nil</b>,<br>returns <code>d</code>.<br>Otherwise, raises an error.<br><br><br><br><br><br></p><hr><h3><a name="luaL_optlstring"><code>luaL_optlstring</code></a></h3><p><br><span class="apii">[-0, +0, <em>v</em>]</span><br></p><pre>const char luaL_optlstring (lua_State <em>L,<br>                             int arg,<br>                             const char </em>d,<br>                             size_t <em>l);</em></pre><br><br><p><br>If the function argument <code>arg</code> is a string,<br>returns this string.<br>If this argument is absent or is <b>nil</b>,<br>returns <code>d</code>.<br>Otherwise, raises an error.<br><br><br></p><p><br>If <code>l</code> is not <code>NULL</code>,<br>fills the position <code>l</code> with the result’s length.<br><br><br><br><br><br></p><hr><h3><a name="luaL_optnumber"><code>luaL_optnumber</code></a></h3><p><br><span class="apii">[-0, +0, <em>v</em>]</span><br></p><pre>lua_Number luaL_optnumber (lua_State <em>L, int arg, lua_Number d);</em></pre><br><br><p><br>If the function argument <code>arg</code> is a number,<br>returns this number.<br>If this argument is absent or is <b>nil</b>,<br>returns <code>d</code>.<br>Otherwise, raises an error.<br><br><br><br><br><br></p><hr><h3><a name="luaL_optstring"><code>luaL_optstring</code></a></h3><p><br><span class="apii">[-0, +0, <em>v</em>]</span><br></p><pre>const char luaL_optstring (lua_State <em>L,<br>                            int arg,<br>                            const char </em>d);</pre><br><br><p><br>If the function argument <code>arg</code> is a string,<br>returns this string.<br>If this argument is absent or is <b>nil</b>,<br>returns <code>d</code>.<br>Otherwise, raises an error.<br><br><br><br><br><br></p><hr><h3><a name="luaL_optunsigned"><code>luaL_optunsigned</code></a></h3><p><br><span class="apii">[-0, +0, <em>v</em>]</span><br></p><pre>lua_Unsigned luaL_optunsigned (lua_State <em>L,<br>                               int arg,<br>                               lua_Unsigned u);</em></pre><br><br><p><br>If the function argument <code>arg</code> is a number,<br>returns this number cast to a <a href="#lua_Unsigned"><code>lua_Unsigned</code></a>.<br>If this argument is absent or is <b>nil</b>,<br>returns <code>u</code>.<br>Otherwise, raises an error.<br><br><br><br><br><br></p><hr><h3><a name="luaL_prepbuffer"><code>luaL_prepbuffer</code></a></h3><p><br><span class="apii">[-?, +?, <em>e</em>]</span><br></p><pre>char luaL_prepbuffer (luaL_Buffer <em>B);</em></pre><br><br><p><br>Equivalent to <a href="#luaL_prepbuffsize"><code>luaL_prepbuffsize</code></a><br>with the predefined size <a name="pdf-LUAL_BUFFERSIZE"><code>LUAL_BUFFERSIZE</code></a>.<br><br><br><br><br><br></p><hr><h3><a name="luaL_prepbuffsize"><code>luaL_prepbuffsize</code></a></h3><p><br><span class="apii">[-?, +?, <em>e</em>]</span><br></p><pre>char luaL_prepbuffsize (luaL_Buffer <em>B, size_t sz);</em></pre><br><br><p><br>Returns an address to a space of size <code>sz</code><br>where you can copy a string to be added to buffer <code>B</code><br>(see <a href="#luaL_Buffer"><code>luaL_Buffer</code></a>).<br>After copying the string into this space you must call<br><a href="#luaL_addsize"><code>luaL_addsize</code></a> with the size of the string to actually add<br>it to the buffer.<br><br><br><br><br><br></p><hr><h3><a name="luaL_pushresult"><code>luaL_pushresult</code></a></h3><p><br><span class="apii">[-?, +1, <em>e</em>]</span><br></p><pre>void luaL_pushresult (luaL_Buffer B);</pre><br><br><p><br>Finishes the use of buffer <code>B</code> leaving the final string on<br>the top of the stack.<br><br><br><br><br><br></p><hr><h3><a name="luaL_pushresultsize"><code>luaL_pushresultsize</code></a></h3><p><br><span class="apii">[-?, +1, <em>e</em>]</span><br></p><pre>void luaL_pushresultsize (luaL_Buffer <em>B, size_t sz);</em></pre><br><br><p><br>Equivalent to the sequence <a href="#luaL_addsize"><code>luaL_addsize</code></a>, <a href="#luaL_pushresult"><code>luaL_pushresult</code></a>.<br><br><br><br><br><br></p><hr><h3><a name="luaL_ref"><code>luaL_ref</code></a></h3><p><br><span class="apii">[-1, +0, <em>e</em>]</span><br></p><pre>int luaL_ref (lua_State L, int t);</pre><br><br><p><br>Creates and returns a <em>reference</em>,<br>in the table at index <code>t</code>,<br>for the object at the top of the stack (and pops the object).<br><br><br></p><p><br>A reference is a unique integer key.<br>As long as you do not manually add integer keys into table <code>t</code>,<br><a href="#luaL_ref"><code>luaL_ref</code></a> ensures the uniqueness of the key it returns.<br>You can retrieve an object referred by reference <code>r</code><br>by calling <code>lua_rawgeti(L, t, r)</code>.<br>Function <a href="#luaL_unref"><code>luaL_unref</code></a> frees a reference and its associated object.<br><br><br></p><p><br>If the object at the top of the stack is <b>nil</b>,<br><a href="#luaL_ref"><code>luaL_ref</code></a> returns the constant <a name="pdf-LUA_REFNIL"><code>LUA_REFNIL</code></a>.<br>The constant <a name="pdf-LUA_NOREF"><code>LUA_NOREF</code></a> is guaranteed to be different<br>from any reference returned by <a href="#luaL_ref"><code>luaL_ref</code></a>.<br><br><br><br><br><br></p><hr><h3><a name="luaL_Reg"><code>luaL_Reg</code></a></h3><br><pre>typedef struct luaL_Reg {<br>  const char <em>name;<br>  lua_CFunction func;<br>} luaL_Reg;</em></pre><br><br><p><br>Type for arrays of functions to be registered by<br><a href="#luaL_setfuncs"><code>luaL_setfuncs</code></a>.<br><code>name</code> is the function name and <code>func</code> is a pointer to<br>the function.<br>Any array of <a href="#luaL_Reg"><code>luaL_Reg</code></a> must end with an sentinel entry<br>in which both <code>name</code> and <code>func</code> are <code>NULL</code>.<br><br><br><br><br><br></p><hr><h3><a name="luaL_requiref"><code>luaL_requiref</code></a></h3><p><br><span class="apii">[-0, +1, <em>e</em>]</span><br></p><pre>void luaL_requiref (lua_State L, const char <em>modname,<br>                    lua_CFunction openf, int glb);</em></pre><br><br><p><br>Calls function <code>openf</code> with string <code>modname</code> as an argument<br>and sets the call result in <code>package.loaded[modname]</code>,<br>as if that function has been called through <a href="#pdf-require"><code>require</code></a>.<br><br><br></p><p><br>If <code>glb</code> is true,<br>also stores the result into global <code>modname</code>.<br><br><br></p><p><br>Leaves a copy of that result on the stack.<br><br><br><br><br><br></p><hr><h3><a name="luaL_setfuncs"><code>luaL_setfuncs</code></a></h3><p><br><span class="apii">[-nup, +0, <em>e</em>]</span><br></p><pre>void luaL_setfuncs (lua_State L, const luaL_Reg <em>l, int nup);</em></pre><br><br><p><br>Registers all functions in the array <code>l</code><br>(see <a href="#luaL_Reg"><code>luaL_Reg</code></a>) into the table on the top of the stack<br>(below optional upvalues, see next).<br><br><br></p><p><br>When <code>nup</code> is not zero,<br>all functions are created sharing <code>nup</code> upvalues,<br>which must be previously pushed on the stack<br>on top of the library table.<br>These values are popped from the stack after the registration.<br><br><br><br><br><br></p><hr><h3><a name="luaL_setmetatable"><code>luaL_setmetatable</code></a></h3><p><br><span class="apii">[-0, +0, –]</span><br></p><pre>void luaL_setmetatable (lua_State L, const char <em>tname);</em></pre><br><br><p><br>Sets the metatable of the object at the top of the stack<br>as the metatable associated with name <code>tname</code><br>in the registry (see <a href="#luaL_newmetatable"><code>luaL_newmetatable</code></a>).<br><br><br><br><br><br></p><hr><h3><a name="luaL_testudata"><code>luaL_testudata</code></a></h3><p><br><span class="apii">[-0, +0, <em>e</em>]</span><br></p><pre>void luaL_testudata (lua_State <em>L, int arg, const char </em>tname);</pre><br><br><p><br>This function works like <a href="#luaL_checkudata"><code>luaL_checkudata</code></a>,<br>except that, when the test fails,<br>it returns <code>NULL</code> instead of throwing an error.<br><br><br><br><br><br></p><hr><h3><a name="luaL_tolstring"><code>luaL_tolstring</code></a></h3><p><br><span class="apii">[-0, +1, <em>e</em>]</span><br></p><pre>const char <em>luaL_tolstring (lua_State </em>L, int idx, size_t <em>len);</em></pre><br><br><p><br>Converts any Lua value at the given index to a C&nbsp;string<br>in a reasonable format.<br>The resulting string is pushed onto the stack and also<br>returned by the function.<br>If <code>len</code> is not <code>NULL</code>,<br>the function also sets <code>len</code> with the string length.<br><br><br></p><p><br>If the value has a metatable with a <code>“<strong>tostring”</strong></code> field,<br>then <code>luaL_tolstring</code> calls the corresponding metamethod<br>with the value as argument,<br>and uses the result of the call as its result.<br><br><br><br><br><br></p><hr><h3><a name="luaL_traceback"><code>luaL_traceback</code></a></h3><p><br><span class="apii">[-0, +1, <em>e</em>]</span><br></p><pre>void luaL_traceback (lua_State <em>L, lua_State </em>L1, const char <em>msg,<br>                     int level);</em></pre><br><br><p><br>Creates and pushes a traceback of the stack <code>L1</code>.<br>If <code>msg</code> is not <code>NULL</code> it is appended<br>at the beginning of the traceback.<br>The <code>level</code> parameter tells at which level<br>to start the traceback.<br><br><br><br><br><br></p><hr><h3><a name="luaL_typename"><code>luaL_typename</code></a></h3><p><br><span class="apii">[-0, +0, –]</span><br></p><pre>const char luaL_typename (lua_State <em>L, int index);</em></pre><br><br><p><br>Returns the name of the type of the value at the given index.<br><br><br><br><br><br></p><hr><h3><a name="luaL_unref"><code>luaL_unref</code></a></h3><p><br><span class="apii">[-0, +0, –]</span><br></p><pre>void luaL_unref (lua_State L, int t, int ref);</pre><br><br><p><br>Releases reference <code>ref</code> from the table at index <code>t</code><br>(see <a href="#luaL_ref"><code>luaL_ref</code></a>).<br>The entry is removed from the table,<br>so that the referred object can be collected.<br>The reference <code>ref</code> is also freed to be used again.<br><br><br></p><p><br>If <code>ref</code> is <a href="#pdf-LUA_NOREF"><code>LUA_NOREF</code></a> or <a href="#pdf-LUA_REFNIL"><code>LUA_REFNIL</code></a>,<br><a href="#luaL_unref"><code>luaL_unref</code></a> does nothing.<br><br><br><br><br><br></p><hr><h3><a name="luaL_where"><code>luaL_where</code></a></h3><p><br><span class="apii">[-0, +1, <em>e</em>]</span><br></p><pre>void luaL_where (lua_State <em>L, int lvl);</em></pre><br><br><p><br>Pushes onto the stack a string identifying the current position<br>of the control at level <code>lvl</code> in the call stack.<br>Typically this string has the following format:<br><br></p><pre>     <em>chunkname</em>:<em>currentline</em>:<br></pre><p><br>Level&nbsp;0 is the running function,<br>level&nbsp;1 is the function that called the running function,<br>etc.<br><br><br></p><p><br>This function is used to build a prefix for error messages.<br><br><br><br><br><br><br><br></p><h1>6 – <a name="6">Standard Libraries</a></h1><br><br><p><br>The standard Lua libraries provide useful functions<br>that are implemented directly through the C&nbsp;API.<br>Some of these functions provide essential services to the language<br>(e.g., <a href="#pdf-type"><code>type</code></a> and <a href="#pdf-getmetatable"><code>getmetatable</code></a>);<br>others provide access to “outside” services (e.g., I/O);<br>and others could be implemented in Lua itself,<br>but are quite useful or have critical performance requirements that<br>deserve an implementation in C (e.g., <a href="#pdf-table.sort"><code>table.sort</code></a>).<br><br><br></p><p><br>All libraries are implemented through the official C&nbsp;API<br>and are provided as separate C&nbsp;modules.<br>Currently, Lua has the following standard libraries:<br><br></p><ul><br><br><li>basic library (<a href="#6.1">§6.1</a>);</li><br><br><li>coroutine library (<a href="#6.2">§6.2</a>);</li><br><br><li>package library (<a href="#6.3">§6.3</a>);</li><br><br><li>string manipulation (<a href="#6.4">§6.4</a>);</li><br><br><li>table manipulation (<a href="#6.5">§6.5</a>);</li><br><br><li>mathematical functions (<a href="#6.6">§6.6</a>) (sin, log, etc.);</li><br><br><li>bitwise operations (<a href="#6.7">§6.7</a>);</li><br><br><li>input and output (<a href="#6.8">§6.8</a>);</li><br><br><li>operating system facilities (<a href="#6.9">§6.9</a>);</li><br><br><li>debug facilities (<a href="#6.10">§6.10</a>).</li><br><br></ul><p><br>Except for the basic and the package libraries,<br>each library provides all its functions as fields of a global table<br>or as methods of its objects.<br><br><br></p><p><br>To have access to these libraries,<br>the C&nbsp;host program should call the <a href="#luaL_openlibs"><code>luaL_openlibs</code></a> function,<br>which opens all standard libraries.<br>Alternatively,<br>the host program can open them individually by using<br><a href="#luaL_requiref"><code>luaL_requiref</code></a> to call<br><a name="pdf-luaopen_base"><code>luaopen_base</code></a> (for the basic library),<br><a name="pdf-luaopen_package"><code>luaopen_package</code></a> (for the package library),<br><a name="pdf-luaopen_coroutine"><code>luaopen_coroutine</code></a> (for the coroutine library),<br><a name="pdf-luaopen_string"><code>luaopen_string</code></a> (for the string library),<br><a name="pdf-luaopen_table"><code>luaopen_table</code></a> (for the table library),<br><a name="pdf-luaopen_math"><code>luaopen_math</code></a> (for the mathematical library),<br><a name="pdf-luaopen_bit32"><code>luaopen_bit32</code></a> (for the bit library),<br><a name="pdf-luaopen_io"><code>luaopen_io</code></a> (for the I/O library),<br><a name="pdf-luaopen_os"><code>luaopen_os</code></a> (for the Operating System library),<br>and <a name="pdf-luaopen_debug"><code>luaopen_debug</code></a> (for the debug library).<br>These functions are declared in <a name="pdf-lualib.h"><code>lualib.h</code></a>.<br><br><br><br></p><h2>6.1 – <a name="6.1">Basic Functions</a></h2><br><br><p><br>The basic library provides core functions to Lua.<br>If you do not include this library in your application,<br>you should check carefully whether you need to provide<br>implementations for some of its facilities.<br><br><br></p><p><br></p><hr><h3><a name="pdf-assert"><code>assert (v [, message])</code></a></h3><br>Issues an  error when<br>the value of its argument <code>v</code> is false (i.e., <b>nil</b> or <b>false</b>);<br>otherwise, returns all its arguments.<br><code>message</code> is an error message;<br>when absent, it defaults to “assertion failed!”<br><br><br><br><br><p><br></p><hr><h3><a name="pdf-collectgarbage"><code>collectgarbage ([opt [, arg]])</code></a></h3><br><br><br><p><br>This function is a generic interface to the garbage collector.<br>It performs different functions according to its first argument, <code>opt</code>:<br><br></p><ul><br><br><li><b>“<code>collect</code>“: </b><br>performs a full garbage-collection cycle.<br>This is the default option.<br></li><br><br><li><b>“<code>stop</code>“: </b><br>stops automatic execution of the garbage collector.<br>The collector will run only when explicitly invoked,<br>until a call to restart it.<br></li><br><br><li><b>“<code>restart</code>“: </b><br>restarts automatic execution of the garbage collector.<br></li><br><br><li><b>“<code>count</code>“: </b><br>returns the total memory in use by Lua (in Kbytes) and<br>a second value with the total memory in bytes modulo 1024.<br>The first value has a fractional part,<br>so the following equality is always true:<br><br><pre>     k, b = collectgarbage(“count”)<br>     assert(k1024 == math.floor(k)*1024 + b)<br></pre><p><br>(The second result is useful when Lua is compiled<br>with a non floating-point type for numbers.)<br></p></li><br><br><li><b>“<code>step</code>“: </b><br>performs a garbage-collection step.<br>The step “size” is controlled by <code>arg</code><br>(larger values mean more steps) in a non-specified way.<br>If you want to control the step size<br>you must experimentally tune the value of <code>arg</code>.<br>Returns <b>true</b> if the step finished a collection cycle.<br></li><br><br><li><b>“<code>setpause</code>“: </b><br>sets <code>arg</code> as the new value for the <em>pause</em> of<br>the collector (see <a href="#2.5">§2.5</a>).<br>Returns the previous value for <em>pause</em>.<br></li><br><br><li><b>“<code>setstepmul</code>“: </b><br>sets <code>arg</code> as the new value for the <em>step multiplier</em> of<br>the collector (see <a href="#2.5">§2.5</a>).<br>Returns the previous value for <em>step</em>.<br></li><br><br><li><b>“<code>isrunning</code>“: </b><br>returns a boolean that tells whether the collector is running<br>(i.e., not stopped).<br></li><br><br><li><b>“<code>generational</code>“: </b><br>changes the collector to generational mode.<br>This is an experimental feature (see <a href="#2.5">§2.5</a>).<br></li><br><br><li><b>“<code>incremental</code>“: </b><br>changes the collector to incremental mode.<br>This is the default mode.<br></li><br><br></ul><br><br><br><br><p><br></p><hr><h3><a name="pdf-dofile"><code>dofile ([filename])</code></a></h3><br>Opens the named file and executes its contents as a Lua chunk.<br>When called without arguments,<br><code>dofile</code> executes the contents of the standard input (<code>stdin</code>).<br>Returns all values returned by the chunk.<br>In case of errors, <code>dofile</code> propagates the error<br>to its caller (that is, <code>dofile</code> does not run in protected mode).<br><br><br><br><br><p><br></p><hr><h3><a name="pdf-error"><code>error (message [, level])</code></a></h3><br>Terminates the last protected function called<br>and returns <code>message</code> as the error message.<br>Function <code>error</code> never returns.<br><br><br><p><br>Usually, <code>error</code> adds some information about the error position<br>at the beginning of the message, if the message is a string.<br>The <code>level</code> argument specifies how to get the error position.<br>With level&nbsp;1 (the default), the error position is where the<br><code>error</code> function was called.<br>Level&nbsp;2 points the error to where the function<br>that called <code>error</code> was called; and so on.<br>Passing a level&nbsp;0 avoids the addition of error position information<br>to the message.<br><br><br><br><br></p><p><br></p><hr><h3><a name="pdf-_G"><code>_G</code></a></h3><br>A global variable (not a function) that<br>holds the global environment (see <a href="#2.2">§2.2</a>).<br>Lua itself does not use this variable;<br>changing its value does not affect any environment,<br>nor vice-versa.<br><br><br><br><br><p><br></p><hr><h3><a name="pdf-getmetatable"><code>getmetatable (object)</code></a></h3><br><br><br><p><br>If <code>object</code> does not have a metatable, returns <b>nil</b>.<br>Otherwise,<br>if the object’s metatable has a <code>“metatable”</code> field,<br>returns the associated value.<br>Otherwise, returns the metatable of the given object.<br><br><br><br><br></p><p><br></p><hr><h3><a name="pdf-ipairs"><code>ipairs (t)</code></a></h3><br><br><br><p><br>If <code>t</code> has a metamethod <code><strong>ipairs</strong></code>,<br>calls it with <code>t</code> as argument and returns the first three<br>results from the call.<br><br><br></p><p><br>Otherwise,<br>returns three values: an iterator function, the table <code>t</code>, and 0,<br>so that the construction<br><br></p><pre>     for i,v in ipairs(t) do <em>body</em> end<br></pre><p><br>will iterate over the pairs (<code>1,t[1]</code>), (<code>2,t[2]</code>), …,<br>up to the first integer key absent from the table.<br><br><br><br><br></p><p><br></p><hr><h3><a name="pdf-load"><code>load (ld [, source [, mode [, env]]])</code></a></h3><br><br><br><p><br>Loads a chunk.<br><br><br></p><p><br>If <code>ld</code> is a string, the chunk is this string.<br>If <code>ld</code> is a function,<br><code>load</code> calls it repeatedly to get the chunk pieces.<br>Each call to <code>ld</code> must return a string that concatenates<br>with previous results.<br>A return of an empty string, <b>nil</b>, or no value signals the end of the chunk.<br><br><br></p><p><br>If there are no syntactic errors,<br>returns the compiled chunk as a function;<br>otherwise, returns <b>nil</b> plus the error message.<br><br><br></p><p><br>If the resulting function has upvalues,<br>the first upvalue is set to the value of <code>env</code>,<br>if that parameter is given,<br>or to the value of the global environment.<br>(When you load a main chunk,<br>the resulting function will always have exactly one upvalue,<br>the <code>_ENV</code> variable (see <a href="#2.2">§2.2</a>).<br>When you load a binary chunk created from a function (see <a href="#pdf-string.dump"><code>string.dump</code></a>),<br>the resulting function can have arbitrary upvalues.)<br><br><br></p><p><br><code>source</code> is used as the source of the chunk for error messages<br>and debug information (see <a href="#4.9">§4.9</a>).<br>When absent,<br>it defaults to <code>ld</code>, if <code>ld</code> is a string,<br>or to “<code>=(load)</code>“ otherwise.<br><br><br></p><p><br>The string <code>mode</code> controls whether the chunk can be text or binary<br>(that is, a precompiled chunk).<br>It may be the string “<code>b</code>“ (only binary chunks),<br>“<code>t</code>“ (only text chunks),<br>or “<code>bt</code>“ (both binary and text).<br>The default is “<code>bt</code>“.<br><br><br><br><br></p><p><br></p><hr><h3><a name="pdf-loadfile"><code>loadfile ([filename [, mode [, env]]])</code></a></h3><br><br><br><p><br>Similar to <a href="#pdf-load"><code>load</code></a>,<br>but gets the chunk from file <code>filename</code><br>or from the standard input,<br>if no file name is given.<br><br><br><br><br></p><p><br></p><hr><h3><a name="pdf-next"><code>next (table [, index])</code></a></h3><br><br><br><p><br>Allows a program to traverse all fields of a table.<br>Its first argument is a table and its second argument<br>is an index in this table.<br><code>next</code> returns the next index of the table<br>and its associated value.<br>When called with <b>nil</b> as its second argument,<br><code>next</code> returns an initial index<br>and its associated value.<br>When called with the last index,<br>or with <b>nil</b> in an empty table,<br><code>next</code> returns <b>nil</b>.<br>If the second argument is absent, then it is interpreted as <b>nil</b>.<br>In particular,<br>you can use <code>next(t)</code> to check whether a table is empty.<br><br><br></p><p><br>The order in which the indices are enumerated is not specified,<br><em>even for numeric indices</em>.<br>(To traverse a table in numeric order,<br>use a numerical <b>for</b>.)<br><br><br></p><p><br>The behavior of <code>next</code> is undefined if,<br>during the traversal,<br>you assign any value to a non-existent field in the table.<br>You may however modify existing fields.<br>In particular, you may clear existing fields.<br><br><br><br><br></p><p><br></p><hr><h3><a name="pdf-pairs"><code>pairs (t)</code></a></h3><br><br><br><p><br>If <code>t</code> has a metamethod <code>pairs</code>,<br>calls it with <code>t</code> as argument and returns the first three<br>results from the call.<br><br><br></p><p><br>Otherwise,<br>returns three values: the <a href="#pdf-next"><code>next</code></a> function, the table <code>t</code>, and <b>nil</b>,<br>so that the construction<br><br></p><pre>     for k,v in pairs(t) do <em>body</em> end<br></pre><p><br>will iterate over all key–value pairs of table <code>t</code>.<br><br><br></p><p><br>See function <a href="#pdf-next"><code>next</code></a> for the caveats of modifying<br>the table during its traversal.<br><br><br><br><br></p><p><br></p><hr><h3><a name="pdf-pcall"><code>pcall (f [, arg1, ···])</code></a></h3><br><br><br><p><br>Calls function <code>f</code> with<br>the given arguments in <em>protected mode</em>.<br>This means that any error inside&nbsp;<code>f</code> is not propagated;<br>instead, <code>pcall</code> catches the error<br>and returns a status code.<br>Its first result is the status code (a boolean),<br>which is true if the call succeeds without errors.<br>In such case, <code>pcall</code> also returns all results from the call,<br>after this first result.<br>In case of any error, <code>pcall</code> returns <b>false</b> plus the error message.<br><br><br><br><br></p><p><br></p><hr><h3><a name="pdf-print"><code>print (···)</code></a></h3><br>Receives any number of arguments<br>and prints their values to <code>stdout</code>,<br>using the <a href="#pdf-tostring"><code>tostring</code></a> function to convert each argument to a string.<br><code>print</code> is not intended for formatted output,<br>but only as a quick way to show a value,<br>for instance for debugging.<br>For complete control over the output,<br>use <a href="#pdf-string.format"><code>string.format</code></a> and <a href="#pdf-io.write"><code>io.write</code></a>.<br><br><br><br><br><p><br></p><hr><h3><a name="pdf-rawequal"><code>rawequal (v1, v2)</code></a></h3><br>Checks whether <code>v1</code> is equal to <code>v2</code>,<br>without invoking any metamethod.<br>Returns a boolean.<br><br><br><br><br><p><br></p><hr><h3><a name="pdf-rawget"><code>rawget (table, index)</code></a></h3><br>Gets the real value of <code>table[index]</code>,<br>without invoking any metamethod.<br><code>table</code> must be a table;<br><code>index</code> may be any value.<br><br><br><br><br><p><br></p><hr><h3><a name="pdf-rawlen"><code>rawlen (v)</code></a></h3><br>Returns the length of the object <code>v</code>,<br>which must be a table or a string,<br>without invoking any metamethod.<br>Returns an integer number.<br><br><br><br><br><p><br></p><hr><h3><a name="pdf-rawset"><code>rawset (table, index, value)</code></a></h3><br>Sets the real value of <code>table[index]</code> to <code>value</code>,<br>without invoking any metamethod.<br><code>table</code> must be a table,<br><code>index</code> any value different from <b>nil</b> and NaN,<br>and <code>value</code> any Lua value.<br><br><br><p><br>This function returns <code>table</code>.<br><br><br><br><br></p><p><br></p><hr><h3><a name="pdf-select"><code>select (index, ···)</code></a></h3><br><br><br><p><br>If <code>index</code> is a number,<br>returns all arguments after argument number <code>index</code>;<br>a negative number indexes from the end (-1 is the last argument).<br>Otherwise, <code>index</code> must be the string <code>“#”</code>,<br>and <code>select</code> returns the total number of extra arguments it received.<br><br><br><br><br></p><p><br></p><hr><h3><a name="pdf-setmetatable"><code>setmetatable (table, metatable)</code></a></h3><br><br><br><p><br>Sets the metatable for the given table.<br>(You cannot change the metatable of other types from Lua, only from&nbsp;C.)<br>If <code>metatable</code> is <b>nil</b>,<br>removes the metatable of the given table.<br>If the original metatable has a <code>“<strong>metatable”</strong></code> field,<br>raises an error.<br><br><br></p><p><br>This function returns <code>table</code>.<br><br><br><br><br></p><p><br></p><hr><h3><a name="pdf-tonumber"><code>tonumber (e [, base])</code></a></h3><br><br><br><p><br>When called with no <code>base</code>,<br><code>tonumber</code> tries to convert its argument to a number.<br>If the argument is already a number or<br>a string convertible to a number (see <a href="#3.4.2">§3.4.2</a>),<br>then <code>tonumber</code> returns this number;<br>otherwise, it returns <b>nil</b>.<br><br><br></p><p><br>When called with <code>base</code>,<br>then <code>e</code> should be a string to be interpreted as<br>an integer numeral in that base.<br>The base may be any integer between 2 and 36, inclusive.<br>In bases above&nbsp;10, the letter ‘<code>A</code>‘ (in either upper or lower case)<br>represents&nbsp;10, ‘<code>B</code>‘ represents&nbsp;11, and so forth,<br>with ‘<code>Z</code>‘ representing 35.<br>If the string <code>e</code> is not a valid numeral in the given base,<br>the function returns <b>nil</b>.<br><br><br><br><br></p><p><br></p><hr><h3><a name="pdf-tostring"><code>tostring (v)</code></a></h3><br>Receives a value of any type and<br>converts it to a string in a reasonable format.<br>(For complete control of how numbers are converted,<br>use <a href="#pdf-string.format"><code>string.format</code></a>.)<br><br><br><p><br>If the metatable of <code>v</code> has a <code>“tostring”</code> field,<br>then <code>tostring</code> calls the corresponding value<br>with <code>v</code> as argument,<br>and uses the result of the call as its result.<br><br><br><br><br></p><p><br></p><hr><h3><a name="pdf-type"><code>type (v)</code></a></h3><br>Returns the type of its only argument, coded as a string.<br>The possible results of this function are<br>“<code>nil</code>“ (a string, not the value <b>nil</b>),<br>“<code>number</code>“,<br>“<code>string</code>“,<br>“<code>boolean</code>“,<br>“<code>table</code>“,<br>“<code>function</code>“,<br>“<code>thread</code>“,<br>and “<code>userdata</code>“.<br><br><br><br><br><p><br></p><hr><h3><a name="pdf-_VERSION"><code><em>VERSION</em></code></a></h3><br>A global variable (not a function) that<br>holds a string containing the current interpreter version.<br>The current contents of this variable is “<code>Lua 5.2</code>“.<br><br><br><br><br><p><br></p><hr><h3><a name="pdf-xpcall"><code>xpcall (f, msgh [, arg1, ···])</code></a></h3><br><br><br><p><br>This function is similar to <a href="#pdf-pcall"><code>pcall</code></a>,<br>except that it sets a new message handler <code>msgh</code>.<br><br><br><br><br><br><br><br></p><h2>6.2 – <a name="6.2">Coroutine Manipulation</a></h2><br><br><p><br>The operations related to coroutines comprise a sub-library of<br>the basic library and come inside the table <a name="pdf-coroutine"><code>coroutine</code></a>.<br>See <a href="#2.6">§2.6</a> for a general description of coroutines.<br><br><br></p><p><br></p><hr><h3><a name="pdf-coroutine.create"><code>coroutine.create (f)</code></a></h3><br><br><br><p><br>Creates a new coroutine, with body <code>f</code>.<br><code>f</code> must be a Lua function.<br>Returns this new coroutine,<br>an object with type <code>“thread”</code>.<br><br><br><br><br></p><p><br></p><hr><h3><a name="pdf-coroutine.resume"><code>coroutine.resume (co [, val1, ···])</code></a></h3><br><br><br><p><br>Starts or continues the execution of coroutine <code>co</code>.<br>The first time you resume a coroutine,<br>it starts running its body.<br>The values <code>val1</code>, … are passed<br>as the arguments to the body function.<br>If the coroutine has yielded,<br><code>resume</code> restarts it;<br>the values <code>val1</code>, … are passed<br>as the results from the yield.<br><br><br></p><p><br>If the coroutine runs without any errors,<br><code>resume</code> returns <b>true</b> plus any values passed to <code>yield</code><br>(if the coroutine yields) or any values returned by the body function<br>(if the coroutine terminates).<br>If there is any error,<br><code>resume</code> returns <b>false</b> plus the error message.<br><br><br><br><br></p><p><br></p><hr><h3><a name="pdf-coroutine.running"><code>coroutine.running ()</code></a></h3><br><br><br><p><br>Returns the running coroutine plus a boolean,<br>true when the running coroutine is the main one.<br><br><br><br><br></p><p><br></p><hr><h3><a name="pdf-coroutine.status"><code>coroutine.status (co)</code></a></h3><br><br><br><p><br>Returns the status of coroutine <code>co</code>, as a string:<br><code>“running”</code>,<br>if the coroutine is running (that is, it called <code>status</code>);<br><code>“suspended”</code>, if the coroutine is suspended in a call to <code>yield</code>,<br>or if it has not started running yet;<br><code>“normal”</code> if the coroutine is active but not running<br>(that is, it has resumed another coroutine);<br>and <code>“dead”</code> if the coroutine has finished its body function,<br>or if it has stopped with an error.<br><br><br><br><br></p><p><br></p><hr><h3><a name="pdf-coroutine.wrap"><code>coroutine.wrap (f)</code></a></h3><br><br><br><p><br>Creates a new coroutine, with body <code>f</code>.<br><code>f</code> must be a Lua function.<br>Returns a function that resumes the coroutine each time it is called.<br>Any arguments passed to the function behave as the<br>extra arguments to <code>resume</code>.<br>Returns the same values returned by <code>resume</code>,<br>except the first boolean.<br>In case of error, propagates the error.<br><br><br><br><br></p><p><br></p><hr><h3><a name="pdf-coroutine.yield"><code>coroutine.yield (···)</code></a></h3><br><br><br><p><br>Suspends the execution of the calling coroutine.<br>Any arguments to <code>yield</code> are passed as extra results to <code>resume</code>.<br><br><br><br><br><br><br><br></p><h2>6.3 – <a name="6.3">Modules</a></h2><br><br><p><br>The package library provides basic<br>facilities for loading modules in Lua.<br>It exports one function directly in the global environment:<br><a href="#pdf-require"><code>require</code></a>.<br>Everything else is exported in a table <a name="pdf-package"><code>package</code></a>.<br><br><br></p><p><br></p><hr><h3><a name="pdf-require"><code>require (modname)</code></a></h3><br><br><br><p><br>Loads the given module.<br>The function starts by looking into the <a href="#pdf-package.loaded"><code>package.loaded</code></a> table<br>to determine whether <code>modname</code> is already loaded.<br>If it is, then <code>require</code> returns the value stored<br>at <code>package.loaded[modname]</code>.<br>Otherwise, it tries to find a <em>loader</em> for the module.<br><br><br></p><p><br>To find a loader,<br><code>require</code> is guided by the <a href="#pdf-package.searchers"><code>package.searchers</code></a> sequence.<br>By changing this sequence,<br>we can change how <code>require</code> looks for a module.<br>The following explanation is based on the default configuration<br>for <a href="#pdf-package.searchers"><code>package.searchers</code></a>.<br><br><br></p><p><br>First <code>require</code> queries <code>package.preload[modname]</code>.<br>If it has a value,<br>this value (which should be a function) is the loader.<br>Otherwise <code>require</code> searches for a Lua loader using the<br>path stored in <a href="#pdf-package.path"><code>package.path</code></a>.<br>If that also fails, it searches for a C&nbsp;loader using the<br>path stored in <a href="#pdf-package.cpath"><code>package.cpath</code></a>.<br>If that also fails,<br>it tries an <em>all-in-one</em> loader (see <a href="#pdf-package.searchers"><code>package.searchers</code></a>).<br><br><br></p><p><br>Once a loader is found,<br><code>require</code> calls the loader with two arguments:<br><code>modname</code> and an extra value dependent on how it got the loader.<br>(If the loader came from a file,<br>this extra value is the file name.)<br>If the loader returns any non-nil value,<br><code>require</code> assigns the returned value to <code>package.loaded[modname]</code>.<br>If the loader does not return a non-nil value and<br>has not assigned any value to <code>package.loaded[modname]</code>,<br>then <code>require</code> assigns <b>true</b> to this entry.<br>In any case, <code>require</code> returns the<br>final value of <code>package.loaded[modname]</code>.<br><br><br></p><p><br>If there is any error loading or running the module,<br>or if it cannot find any loader for the module,<br>then <code>require</code> raises an error.<br><br><br><br><br></p><p><br></p><hr><h3><a name="pdf-package.config"><code>package.config</code></a></h3><br><br><br><p><br>A string describing some compile-time configurations for packages.<br>This string is a sequence of lines:<br><br></p><ul><br><br><li>The first line is the directory separator string.<br>Default is ‘<code>\</code>‘ for Windows and ‘<code>/</code>‘ for all other systems.</li><br><br><li>The second line is the character that separates templates in a path.<br>Default is ‘<code>;</code>‘.</li><br><br><li>The third line is the string that marks the<br>substitution points in a template.<br>Default is ‘<code>?</code>‘.</li><br><br><li>The fourth line is a string that, in a path in Windows,<br>is replaced by the executable’s directory.<br>Default is ‘<code>!</code>‘.</li><br><br><li>The fifth line is a mark to ignore all text before it<br>when building the <code>luaopen</code> function name.<br>Default is ‘<code>-</code>‘.</li><br><br></ul><br><br><br><br><p><br></p><hr><h3><a name="pdf-package.cpath"><code>package.cpath</code></a></h3><br><br><br><p><br>The path used by <a href="#pdf-require"><code>require</code></a> to search for a C&nbsp;loader.<br><br><br></p><p><br>Lua initializes the C&nbsp;path <a href="#pdf-package.cpath"><code>package.cpath</code></a> in the same way<br>it initializes the Lua path <a href="#pdf-package.path"><code>package.path</code></a>,<br>using the environment variable <a name="pdf-LUA_CPATH_5_2"><code>LUA_CPATH_5_2</code></a><br>or the environment variable <a name="pdf-LUA_CPATH"><code>LUA_CPATH</code></a><br>or a default path defined in <code>luaconf.h</code>.<br><br><br><br><br></p><p><br></p><hr><h3><a name="pdf-package.loaded"><code>package.loaded</code></a></h3><br><br><br><p><br>A table used by <a href="#pdf-require"><code>require</code></a> to control which<br>modules are already loaded.<br>When you require a module <code>modname</code> and<br><code>package.loaded[modname]</code> is not false,<br><a href="#pdf-require"><code>require</code></a> simply returns the value stored there.<br><br><br></p><p><br>This variable is only a reference to the real table;<br>assignments to this variable do not change the<br>table used by <a href="#pdf-require"><code>require</code></a>.<br><br><br><br><br></p><p><br></p><hr><h3><a name="pdf-package.loadlib"><code>package.loadlib (libname, funcname)</code></a></h3><br><br><br><p><br>Dynamically links the host program with the C&nbsp;library <code>libname</code>.<br><br><br></p><p><br>If <code>funcname</code> is “<code><em></em></code>“,<br>then it only links with the library,<br>making the symbols exported by the library<br>available to other dynamically linked libraries.<br>Otherwise,<br>it looks for a function <code>funcname</code> inside the library<br>and returns this function as a C&nbsp;function.<br>So, <code>funcname</code> must follow the <a href="#lua_CFunction"><code>lua_CFunction</code></a> prototype<br>(see <a href="#lua_CFunction"><code>lua_CFunction</code></a>).<br><br><br></p><p><br>This is a low-level function.<br>It completely bypasses the package and module system.<br>Unlike <a href="#pdf-require"><code>require</code></a>,<br>it does not perform any path searching and<br>does not automatically adds extensions.<br><code>libname</code> must be the complete file name of the C&nbsp;library,<br>including if necessary a path and an extension.<br><code>funcname</code> must be the exact name exported by the C&nbsp;library<br>(which may depend on the C&nbsp;compiler and linker used).<br><br><br></p><p><br>This function is not supported by Standard&nbsp;C.<br>As such, it is only available on some platforms<br>(Windows, Linux, Mac OS X, Solaris, BSD,<br>plus other Unix systems that support the <code>dlfcn</code> standard).<br><br><br><br><br></p><p><br></p><hr><h3><a name="pdf-package.path"><code>package.path</code></a></h3><br><br><br><p><br>The path used by <a href="#pdf-require"><code>require</code></a> to search for a Lua loader.<br><br><br></p><p><br>At start-up, Lua initializes this variable with<br>the value of the environment variable <a name="pdf-LUA_PATH_5_2"><code>LUA_PATH_5_2</code></a> or<br>the environment variable <a name="pdf-LUA_PATH"><code>LUA<em>PATH</em></code></a> or<br>with a default path defined in <code>luaconf.h</code>,<br>if those environment variables are not defined.<br>Any “<code>;;</code>“ in the value of the environment variable<br>is replaced by the default path.<br><br><br><br><br></p><p><br></p><hr><h3><a name="pdf-package.preload"><code>package.preload</code></a></h3><br><br><br><p><br>A table to store loaders for specific modules<br>(see <a href="#pdf-require"><code>require</code></a>).<br><br><br></p><p><br>This variable is only a reference to the real table;<br>assignments to this variable do not change the<br>table used by <a href="#pdf-require"><code>require</code></a>.<br><br><br><br><br></p><p><br></p><hr><h3><a name="pdf-package.searchers"><code>package.searchers</code></a></h3><br><br><br><p><br>A table used by <a href="#pdf-require"><code>require</code></a> to control how to load modules.<br><br><br></p><p><br>Each entry in this table is a <em>searcher function</em>.<br>When looking for a module,<br><a href="#pdf-require"><code>require</code></a> calls each of these searchers in ascending order,<br>with the module name (the argument given to <a href="#pdf-require"><code>require</code></a>) as its<br>sole parameter.<br>The function can return another function (the module <em>loader</em>)<br>plus an extra value that will be passed to that loader,<br>or a string explaining why it did not find that module<br>(or <b>nil</b> if it has nothing to say).<br><br><br></p><p><br>Lua initializes this table with four searcher functions.<br><br><br></p><p><br>The first searcher simply looks for a loader in the<br><a href="#pdf-package.preload"><code>package.preload</code></a> table.<br><br><br></p><p><br>The second searcher looks for a loader as a Lua library,<br>using the path stored at <a href="#pdf-package.path"><code>package.path</code></a>.<br>The search is done as described in function <a href="#pdf-package.searchpath"><code>package.searchpath</code></a>.<br><br><br></p><p><br>The third searcher looks for a loader as a C&nbsp;library,<br>using the path given by the variable <a href="#pdf-package.cpath"><code>package.cpath</code></a>.<br>Again,<br>the search is done as described in function <a href="#pdf-package.searchpath"><code>package.searchpath</code></a>.<br>For instance,<br>if the C&nbsp;path is the string<br><br></p><pre>     “./?.so;./?.dll;/usr/local/?/init.so”<br></pre><p><br>the searcher for module <code>foo</code><br>will try to open the files <code>./foo.so</code>, <code>./foo.dll</code>,<br>and <code>/usr/local/foo/init.so</code>, in that order.<br>Once it finds a C&nbsp;library,<br>this searcher first uses a dynamic link facility to link the<br>application with the library.<br>Then it tries to find a C&nbsp;function inside the library to<br>be used as the loader.<br>The name of this C&nbsp;function is the string “<code>luaopen</code>“<br>concatenated with a copy of the module name where each dot<br>is replaced by an underscore.<br>Moreover, if the module name has a hyphen,<br>its prefix up to (and including) the first hyphen is removed.<br>For instance, if the module name is <code>a.v1-b.c</code>,<br>the function name will be <code>luaopen_b_c</code>.<br><br><br></p><p><br>The fourth searcher tries an <em>all-in-one loader</em>.<br>It searches the C&nbsp;path for a library for<br>the root name of the given module.<br>For instance, when requiring <code>a.b.c</code>,<br>it will search for a C&nbsp;library for <code>a</code>.<br>If found, it looks into it for an open function for<br>the submodule;<br>in our example, that would be <code>luaopen_a_b_c</code>.<br>With this facility, a package can pack several C&nbsp;submodules<br>into one single library,<br>with each submodule keeping its original open function.<br><br><br></p><p><br>All searchers except the first one (preload) return as the extra value<br>the file name where the module was found,<br>as returned by <a href="#pdf-package.searchpath"><code>package.searchpath</code></a>.<br>The first searcher returns no extra value.<br><br><br><br><br></p><p><br></p><hr><h3><a name="pdf-package.searchpath"><code>package.searchpath (name, path [, sep [, rep]])</code></a></h3><br><br><br><p><br>Searches for the given <code>name</code> in the given <code>path</code>.<br><br><br></p><p><br>A path is a string containing a sequence of<br><em>templates</em> separated by semicolons.<br>For each template,<br>the function replaces each interrogation mark (if any)<br>in the template with a copy of <code>name</code><br>wherein all occurrences of <code>sep</code><br>(a dot, by default)<br>were replaced by <code>rep</code><br>(the system’s directory separator, by default),<br>and then tries to open the resulting file name.<br><br><br></p><p><br>For instance, if the path is the string<br><br></p><pre>     “./?.lua;./?.lc;/usr/local/?/init.lua”<br></pre><p><br>the search for the name <code>foo.a</code><br>will try to open the files<br><code>./foo/a.lua</code>, <code>./foo/a.lc</code>, and<br><code>/usr/local/foo/a/init.lua</code>, in that order.<br><br><br></p><p><br>Returns the resulting name of the first file that it can<br>open in read mode (after closing the file),<br>or <b>nil</b> plus an error message if none succeeds.<br>(This error message lists all file names it tried to open.)<br><br><br><br><br><br><br><br></p><h2>6.4 – <a name="6.4">String Manipulation</a></h2><br><br><p><br>This library provides generic functions for string manipulation,<br>such as finding and extracting substrings, and pattern matching.<br>When indexing a string in Lua, the first character is at position&nbsp;1<br>(not at&nbsp;0, as in C).<br>Indices are allowed to be negative and are interpreted as indexing backwards,<br>from the end of the string.<br>Thus, the last character is at position -1, and so on.<br><br><br></p><p><br>The string library provides all its functions inside the table<br><a name="pdf-string"><code>string</code></a>.<br>It also sets a metatable for strings<br>where the <code>__index</code> field points to the <code>string</code> table.<br>Therefore, you can use the string functions in object-oriented style.<br>For instance, <code>string.byte(s,i)</code><br>can be written as <code>s:byte(i)</code>.<br><br><br></p><p><br>The string library assumes one-byte character encodings.<br><br><br></p><p><br></p><hr><h3><a name="pdf-string.byte"><code>string.byte (s [, i [, j]])</code></a></h3><br>Returns the internal numerical codes of the characters <code>s[i]</code>,<br><code>s[i+1]</code>, …, <code>s[j]</code>.<br>The default value for <code>i</code> is&nbsp;1;<br>the default value for <code>j</code> is&nbsp;<code>i</code>.<br>These indices are corrected<br>following the same rules of function <a href="#pdf-string.sub"><code>string.sub</code></a>.<br><br><br><p><br>Numerical codes are not necessarily portable across platforms.<br><br><br><br><br></p><p><br></p><hr><h3><a name="pdf-string.char"><code>string.char (···)</code></a></h3><br>Receives zero or more integers.<br>Returns a string with length equal to the number of arguments,<br>in which each character has the internal numerical code equal<br>to its corresponding argument.<br><br><br><p><br>Numerical codes are not necessarily portable across platforms.<br><br><br><br><br></p><p><br></p><hr><h3><a name="pdf-string.dump"><code>string.dump (function)</code></a></h3><br><br><br><p><br>Returns a string containing a binary representation of the given function,<br>so that a later <a href="#pdf-load"><code>load</code></a> on this string returns<br>a copy of the function (but with new upvalues).<br><br><br><br><br></p><p><br></p><hr><h3><a name="pdf-string.find"><code>string.find (s, pattern [, init [, plain]])</code></a></h3><br><br><br><p><br>Looks for the first match of<br><code>pattern</code> in the string <code>s</code>.<br>If it finds a match, then <code>find</code> returns the indices of&nbsp;<code>s</code><br>where this occurrence starts and ends;<br>otherwise, it returns <b>nil</b>.<br>A third, optional numerical argument <code>init</code> specifies<br>where to start the search;<br>its default value is&nbsp;1 and can be negative.<br>A value of <b>true</b> as a fourth, optional argument <code>plain</code><br>turns off the pattern matching facilities,<br>so the function does a plain “find substring” operation,<br>with no characters in <code>pattern</code> being considered magic.<br>Note that if <code>plain</code> is given, then <code>init</code> must be given as well.<br><br><br></p><p><br>If the pattern has captures,<br>then in a successful match<br>the captured values are also returned,<br>after the two indices.<br><br><br><br><br></p><p><br></p><hr><h3><a name="pdf-string.format"><code>string.format (formatstring, ···)</code></a></h3><br><br><br><p><br>Returns a formatted version of its variable number of arguments<br>following the description given in its first argument (which must be a string).<br>The format string follows the same rules as the ANSI&nbsp;C function <code>sprintf</code>.<br>The only differences are that the options/modifiers<br><code></code>, <code>h</code>, <code>L</code>, <code>l</code>, <code>n</code>,<br>and <code>p</code> are not supported<br>and that there is an extra option, <code>q</code>.<br>The <code>q</code> option formats a string between double quotes,<br>using escape sequences when necessary to ensure that<br>it can safely be read back by the Lua interpreter.<br>For instance, the call<br><br></p><pre>     string.format(‘%q’, ‘a string with “quotes” and \n new line’)<br></pre><p><br>may produce the string:<br><br></p><pre>     “a string with \”quotes\” and \<br>      new line”<br></pre><br><br><p><br>Options<br><code>A</code> and <code>a</code> (when available),<br><code>E</code>, <code>e</code>, <code>f</code>,<br><code>G</code>, and <code>g</code> all expect a number as argument.<br>Options <code>c</code>, <code>d</code>,<br><code>i</code>, <code>o</code>, <code>u</code>, <code>X</code>, and <code>x</code><br>also expect a number,<br>but the range of that number may be limited by<br>the underlying C&nbsp;implementation.<br>For options <code>o</code>, <code>u</code>, <code>X</code>, and <code>x</code>,<br>the number cannot be negative.<br>Option <code>q</code> expects a string;<br>option <code>s</code> expects a string without embedded zeros.<br>If the argument to option <code>s</code> is not a string,<br>it is converted to one following the same rules of <a href="#pdf-tostring"><code>tostring</code></a>.<br><br><br><br><br></p><p><br></p><hr><h3><a name="pdf-string.gmatch"><code>string.gmatch (s, pattern)</code></a></h3><br>Returns an iterator function that,<br>each time it is called,<br>returns the next captures from <code>pattern</code> over the string <code>s</code>.<br>If <code>pattern</code> specifies no captures,<br>then the whole match is produced in each call.<br><br><br><p><br>As an example, the following loop<br>will iterate over all the words from string <code>s</code>,<br>printing one per line:<br><br></p><pre>     s = “hello world from Lua”<br>     for w in string.gmatch(s, “%a+”) do<br>       print(w)<br>     end<br></pre><p><br>The next example collects all pairs <code>key=value</code> from the<br>given string into a table:<br><br></p><pre>     t = {}<br>     s = “from=world, to=Lua”<br>     for k, v in string.gmatch(s, “(%w+)=(%w+)”) do<br>       t[k] = v<br>     end<br></pre><br><br><p><br>For this function, a caret ‘<code>^</code>‘ at the start of a pattern does not<br>work as an anchor, as this would prevent the iteration.<br><br><br><br><br></p><p><br></p><hr><h3><a name="pdf-string.gsub"><code>string.gsub (s, pattern, repl [, n])</code></a></h3><br>Returns a copy of <code>s</code><br>in which all (or the first <code>n</code>, if given)<br>occurrences of the <code>pattern</code> have been<br>replaced by a replacement string specified by <code>repl</code>,<br>which can be a string, a table, or a function.<br><code>gsub</code> also returns, as its second value,<br>the total number of matches that occurred.<br>The name <code>gsub</code> comes from <em>Global SUBstitution</em>.<br><br><br><p><br>If <code>repl</code> is a string, then its value is used for replacement.<br>The character&nbsp;<code>%</code> works as an escape character:<br>any sequence in <code>repl</code> of the form <code>%<em>d</em></code>,<br>with <em>d</em> between 1 and 9,<br>stands for the value of the <em>d</em>-th captured substring.<br>The sequence <code>%0</code> stands for the whole match.<br>The sequence <code>%%</code> stands for a single&nbsp;<code>%</code>.<br><br><br></p><p><br>If <code>repl</code> is a table, then the table is queried for every match,<br>using the first capture as the key.<br><br><br></p><p><br>If <code>repl</code> is a function, then this function is called every time a<br>match occurs, with all captured substrings passed as arguments,<br>in order.<br><br><br></p><p><br>In any case,<br>if the pattern specifies no captures,<br>then it behaves as if the whole pattern was inside a capture.<br><br><br></p><p><br>If the value returned by the table query or by the function call<br>is a string or a number,<br>then it is used as the replacement string;<br>otherwise, if it is <b>false</b> or <b>nil</b>,<br>then there is no replacement<br>(that is, the original match is kept in the string).<br><br><br></p><p><br>Here are some examples:<br><br></p><pre>     x = string.gsub(“hello world”, “(%w+)”, “%1 %1”)<br>     –&gt; x=”hello hello world world”<br><br>     x = string.gsub(“hello world”, “%w+”, “%0 %0”, 1)<br>     –&gt; x=”hello hello world”<br><br>     x = string.gsub(“hello world from Lua”, “(%w+)%s<em>(%w+)”, “%2 %1”)<br>     –&gt; x=”world hello Lua from”<br><br>     x = string.gsub(“home = $HOME, user = $USER”, “%$(%w+)”, os.getenv)<br>     –&gt; x=”home = /home/roberto, user = roberto”<br><br>     x = string.gsub(“4+5 = $return 4+5$”, “%$(.-)%$”, function (s)<br>           return load(s)()<br>         end)<br>     –&gt; x=”4+5 = 9”<br><br>     local t = {name=”lua”, version=”5.2”}<br>     x = string.gsub(“$name-$version.tar.gz”, “%$(%w+)”, t)<br>     –&gt; x=”lua-5.2.tar.gz”<br></em></pre><br><br><br><br><p><br></p><hr><h3><a name="pdf-string.len"><code>string.len (s)</code></a></h3><br>Receives a string and returns its length.<br>The empty string <code>“”</code> has length 0.<br>Embedded zeros are counted,<br>so <code>“a\000bc\000”</code> has length 5.<br><br><br><br><br><p><br></p><hr><h3><a name="pdf-string.lower"><code>string.lower (s)</code></a></h3><br>Receives a string and returns a copy of this string with all<br>uppercase letters changed to lowercase.<br>All other characters are left unchanged.<br>The definition of what an uppercase letter is depends on the current locale.<br><br><br><br><br><p><br></p><hr><h3><a name="pdf-string.match"><code>string.match (s, pattern [, init])</code></a></h3><br>Looks for the first <em>match</em> of<br><code>pattern</code> in the string <code>s</code>.<br>If it finds one, then <code>match</code> returns<br>the captures from the pattern;<br>otherwise it returns <b>nil</b>.<br>If <code>pattern</code> specifies no captures,<br>then the whole match is returned.<br>A third, optional numerical argument <code>init</code> specifies<br>where to start the search;<br>its default value is&nbsp;1 and can be negative.<br><br><br><br><br><p><br></p><hr><h3><a name="pdf-string.rep"><code>string.rep (s, n [, sep])</code></a></h3><br>Returns a string that is the concatenation of <code>n</code> copies of<br>the string <code>s</code> separated by the string <code>sep</code>.<br>The default value for <code>sep</code> is the empty string<br>(that is, no separator).<br><br><br><br><br><p><br></p><hr><h3><a name="pdf-string.reverse"><code>string.reverse (s)</code></a></h3><br>Returns a string that is the string <code>s</code> reversed.<br><br><br><br><br><p><br></p><hr><h3><a name="pdf-string.sub"><code>string.sub (s, i [, j])</code></a></h3><br>Returns the substring of <code>s</code> that<br>starts at <code>i</code>  and continues until <code>j</code>;<br><code>i</code> and <code>j</code> can be negative.<br>If <code>j</code> is absent, then it is assumed to be equal to -1<br>(which is the same as the string length).<br>In particular,<br>the call <code>string.sub(s,1,j)</code> returns a prefix of <code>s</code><br>with length <code>j</code>,<br>and <code>string.sub(s, -i)</code> returns a suffix of <code>s</code><br>with length <code>i</code>.<br><br><br><p><br>If, after the translation of negative indices,<br><code>i</code> is less than 1,<br>it is corrected to 1.<br>If <code>j</code> is greater than the string length,<br>it is corrected to that length.<br>If, after these corrections,<br><code>i</code> is greater than <code>j</code>,<br>the function returns the empty string.<br><br><br><br><br></p><p><br></p><hr><h3><a name="pdf-string.upper"><code>string.upper (s)</code></a></h3><br>Receives a string and returns a copy of this string with all<br>lowercase letters changed to uppercase.<br>All other characters are left unchanged.<br>The definition of what a lowercase letter is depends on the current locale.<br><br><br><br><h3>6.4.1 – <a name="6.4.1">Patterns</a></h3><br><br><br><h4>Character Class:</h4><p><br>A <em>character class</em> is used to represent a set of characters.<br>The following combinations are allowed in describing a character class:<br><br></p><ul><br><br><li><b><em>x</em>: </b><br>(where <em>x</em> is not one of the <em>magic characters</em><br><code>^$()%.[]+-?</code>)<br>represents the character <em>x</em> itself.<br></li><br><br><li><b><code>.</code>: </b> (a dot) represents all characters.</li><br><br><li><b><code>%a</code>: </b> represents all letters.</li><br><br><li><b><code>%c</code>: </b> represents all control characters.</li><br><br><li><b><code>%d</code>: </b> represents all digits.</li><br><br><li><b><code>%g</code>: </b> represents all printable characters except space.</li><br><br><li><b><code>%l</code>: </b> represents all lowercase letters.</li><br><br><li><b><code>%p</code>: </b> represents all punctuation characters.</li><br><br><li><b><code>%s</code>: </b> represents all space characters.</li><br><br><li><b><code>%u</code>: </b> represents all uppercase letters.</li><br><br><li><b><code>%w</code>: </b> represents all alphanumeric characters.</li><br><br><li><b><code>%x</code>: </b> represents all hexadecimal digits.</li><br><br><li><b><code>%<em>x</em></code>: </b> (where <em>x</em> is any non-alphanumeric character)<br>represents the character <em>x</em>.<br>This is the standard way to escape the magic characters.<br>Any punctuation character (even the non magic)<br>can be preceded by a ‘<code>%</code>‘<br>when used to represent itself in a pattern.<br></li><br><br><li><b><code>[<em>set</em>]</code>: </b><br>represents the class which is the union of all<br>characters in <em>set</em>.<br>A range of characters can be specified by<br>separating the end characters of the range,<br>in ascending order, with a ‘<code>-</code>‘,<br>All classes <code>%</code><em>x</em> described above can also be used as<br>components in <em>set</em>.<br>All other characters in <em>set</em> represent themselves.<br>For example, <code>[%w<em>]</em></code> (or <code>[%w]</code>)<br>represents all alphanumeric characters plus the underscore,<br><code>[0-7]</code> represents the octal digits,<br>and <code>[0-7%l%-]</code> represents the octal digits plus<br>the lowercase letters plus the ‘<code>-</code>‘ character.<br><br><br><p><br>The interaction between ranges and classes is not defined.<br>Therefore, patterns like <code>[%a-z]</code> or <code>[a-%%]</code><br>have no meaning.<br></p></li><br><br><li><b><code>[^<em>set</em>]</code>: </b><br>represents the complement of <em>set</em>,<br>where <em>set</em> is interpreted as above.<br></li><br><br></ul><p><br>For all classes represented by single letters (<code>%a</code>, <code>%c</code>, etc.),<br>the corresponding uppercase letter represents the complement of the class.<br>For instance, <code>%S</code> represents all non-space characters.<br><br><br></p><p><br>The definitions of letter, space, and other character groups<br>depend on the current locale.<br>In particular, the class <code>[a-z]</code> may not be equivalent to <code>%l</code>.<br><br><br><br><br><br></p><h4>Pattern Item:</h4><p><br>A <em>pattern item</em> can be<br><br></p><ul><br><br><li><br>a single character class,<br>which matches any single character in the class;<br></li><br><br><li><br>a single character class followed by ‘<code><em></em></code>‘,<br>which matches 0 or more repetitions of characters in the class.<br>These repetition items will always match the longest possible sequence;<br></li><br><br><li><br>a single character class followed by ‘<code>+</code>‘,<br>which matches 1 or more repetitions of characters in the class.<br>These repetition items will always match the longest possible sequence;<br></li><br><br><li><br>a single character class followed by ‘<code>-</code>‘,<br>which also matches 0 or more repetitions of characters in the class.<br>Unlike ‘<code></code>‘,<br>these repetition items will always match the shortest possible sequence;<br></li><br><br><li><br>a single character class followed by ‘<code>?</code>‘,<br>which matches 0 or 1 occurrence of a character in the class;<br></li><br><br><li><br><code>%<em>n</em></code>, for <em>n</em> between 1 and 9;<br>such item matches a substring equal to the <em>n</em>-th captured string<br>(see below);<br></li><br><br><li><br><code>%b<em>xy</em></code>, where <em>x</em> and <em>y</em> are two distinct characters;<br>such item matches strings that start with&nbsp;<em>x</em>, end with&nbsp;<em>y</em>,<br>and where the <em>x</em> and <em>y</em> are <em>balanced</em>.<br>This means that, if one reads the string from left to right,<br>counting <em>+1</em> for an <em>x</em> and <em>-1</em> for a <em>y</em>,<br>the ending <em>y</em> is the first <em>y</em> where the count reaches 0.<br>For instance, the item <code>%b()</code> matches expressions with<br>balanced parentheses.<br></li><br><br><li><br><code>%f[<em>set</em>]</code>, a <em>frontier pattern</em>;<br>such item matches an empty string at any position such that<br>the next character belongs to <em>set</em><br>and the previous character does not belong to <em>set</em>.<br>The set <em>set</em> is interpreted as previously described.<br>The beginning and the end of the subject are handled as if<br>they were the character ‘<code>\0</code>‘.<br></li><br><br></ul><br><br><br><br><br><h4>Pattern:</h4><p><br>A <em>pattern</em> is a sequence of pattern items.<br>A caret ‘<code>^</code>‘ at the beginning of a pattern anchors the match at the<br>beginning of the subject string.<br>A ‘<code>$</code>‘ at the end of a pattern anchors the match at the<br>end of the subject string.<br>At other positions,<br>‘<code>^</code>‘ and ‘<code>$</code>‘ have no special meaning and represent themselves.<br><br><br><br><br><br></p><h4>Captures:</h4><p><br>A pattern can contain sub-patterns enclosed in parentheses;<br>they describe <em>captures</em>.<br>When a match succeeds, the substrings of the subject string<br>that match captures are stored (<em>captured</em>) for future use.<br>Captures are numbered according to their left parentheses.<br>For instance, in the pattern <code>“(a<em>(.)%w(%s</em>))”</code>,<br>the part of the string matching <code>“a<em>(.)%w(%s</em>)”</code> is<br>stored as the first capture (and therefore has number&nbsp;1);<br>the character matching “<code>.</code>“ is captured with number&nbsp;2,<br>and the part matching “<code>%s<em></em></code>“ has number&nbsp;3.<br><br><br></p><p><br>As a special case, the empty capture <code>()</code> captures<br>the current string position (a number).<br>For instance, if we apply the pattern <code>“()aa()”</code> on the<br>string <code>“flaaap”</code>, there will be two captures: 3&nbsp;and&nbsp;5.<br><br><br><br><br><br><br><br><br><br><br><br></p><h2>6.5 – <a name="6.5">Table Manipulation</a></h2><br><br><p><br>This library provides generic functions for table manipulation.<br>It provides all its functions inside the table <a name="pdf-table"><code>table</code></a>.<br><br><br></p><p><br>Remember that, whenever an operation needs the length of a table,<br>the table should be a proper sequence<br>or have a <code>__len</code> metamethod (see <a href="#3.4.6">§3.4.6</a>).<br>All functions ignore non-numeric keys<br>in tables given as arguments.<br><br><br></p><p><br>For performance reasons,<br>all table accesses (get/set) performed by these functions are raw.<br><br><br></p><p><br></p><hr><h3><a name="pdf-table.concat"><code>table.concat (list [, sep [, i [, j]]])</code></a></h3><br><br><br><p><br>Given a list where all elements are strings or numbers,<br>returns the string <code>list[i]..sep..list[i+1] ··· sep..list[j]</code>.<br>The default value for <code>sep</code> is the empty string,<br>the default for <code>i</code> is 1,<br>and the default for <code>j</code> is <code>#list</code>.<br>If <code>i</code> is greater than <code>j</code>, returns the empty string.<br><br><br><br><br></p><p><br></p><hr><h3><a name="pdf-table.insert"><code>table.insert (list, [pos,] value)</code></a></h3><br><br><br><p><br>Inserts element <code>value</code> at position <code>pos</code> in <code>list</code>,<br>shifting up the elements<br><code>list[pos], list[pos+1], ···, list[#list]</code>.<br>The default value for <code>pos</code> is <code>#list+1</code>,<br>so that a call <code>table.insert(t,x)</code> inserts <code>x</code> at the end<br>of list <code>t</code>.<br><br><br><br><br></p><p><br></p><hr><h3><a name="pdf-table.pack"><code>table.pack (···)</code></a></h3><br><br><br><p><br>Returns a new table with all parameters stored into keys 1, 2, etc.<br>and with a field “<code>n</code>“ with the total number of parameters.<br>Note that the resulting table may not be a sequence.<br><br><br><br><br></p><p><br></p><hr><h3><a name="pdf-table.remove"><code>table.remove (list [, pos])</code></a></h3><br><br><br><p><br>Removes from <code>list</code> the element at position <code>pos</code>,<br>returning the value of the removed element.<br>When <code>pos</code> is an integer between 1 and <code>#list</code>,<br>it shifts down the elements<br><code>list[pos+1], list[pos+2], ···, list[#list]</code><br>and erases element <code>list[#list]</code>;<br>The index <code>pos</code> can also be 0 when <code>#list</code> is 0,<br>or <code>#list + 1</code>;<br>in those cases, the function erases the element <code>list[pos]</code>.<br><br><br></p><p><br>The default value for <code>pos</code> is <code>#list</code>,<br>so that a call <code>table.remove(t)</code> removes the last element<br>of list <code>t</code>.<br><br><br><br><br></p><p><br></p><hr><h3><a name="pdf-table.sort"><code>table.sort (list [, comp])</code></a></h3><br><br><br><p><br>Sorts list elements in a given order, <em>in-place</em>,<br>from <code>list[1]</code> to <code>list[#list]</code>.<br>If <code>comp</code> is given,<br>then it must be a function that receives two list elements<br>and returns true when the first element must come<br>before the second in the final order<br>(so that <code>not comp(list[i+1],list[i])</code> will be true after the sort).<br>If <code>comp</code> is not given,<br>then the standard Lua operator <code>&lt;</code> is used instead.<br><br><br></p><p><br>The sort algorithm is not stable;<br>that is, elements considered equal by the given order<br>may have their relative positions changed by the sort.<br><br><br><br><br></p><p><br></p><hr><h3><a name="pdf-table.unpack"><code>table.unpack (list [, i [, j]])</code></a></h3><br><br><br><p><br>Returns the elements from the given table.<br>This function is equivalent to<br><br></p><pre>     return list[i], list[i+1], ···, list[j]<br></pre><p><br>By default, <code>i</code> is&nbsp;1 and <code>j</code> is <code>#list</code>.<br><br><br><br><br><br><br><br></p><h2>6.6 – <a name="6.6">Mathematical Functions</a></h2><br><br><p><br>This library is an interface to the standard C&nbsp;math library.<br>It provides all its functions inside the table <a name="pdf-math"><code>math</code></a>.<br><br><br></p><p><br></p><hr><h3><a name="pdf-math.abs"><code>math.abs (x)</code></a></h3><br><br><br><p><br>Returns the absolute value of <code>x</code>.<br><br><br><br><br></p><p><br></p><hr><h3><a name="pdf-math.acos"><code>math.acos (x)</code></a></h3><br><br><br><p><br>Returns the arc cosine of <code>x</code> (in radians).<br><br><br><br><br></p><p><br></p><hr><h3><a name="pdf-math.asin"><code>math.asin (x)</code></a></h3><br><br><br><p><br>Returns the arc sine of <code>x</code> (in radians).<br><br><br><br><br></p><p><br></p><hr><h3><a name="pdf-math.atan"><code>math.atan (x)</code></a></h3><br><br><br><p><br>Returns the arc tangent of <code>x</code> (in radians).<br><br><br><br><br></p><p><br></p><hr><h3><a name="pdf-math.atan2"><code>math.atan2 (y, x)</code></a></h3><br><br><br><p><br>Returns the arc tangent of <code>y/x</code> (in radians),<br>but uses the signs of both parameters to find the<br>quadrant of the result.<br>(It also handles correctly the case of <code>x</code> being zero.)<br><br><br><br><br></p><p><br></p><hr><h3><a name="pdf-math.ceil"><code>math.ceil (x)</code></a></h3><br><br><br><p><br>Returns the smallest integer larger than or equal to <code>x</code>.<br><br><br><br><br></p><p><br></p><hr><h3><a name="pdf-math.cos"><code>math.cos (x)</code></a></h3><br><br><br><p><br>Returns the cosine of <code>x</code> (assumed to be in radians).<br><br><br><br><br></p><p><br></p><hr><h3><a name="pdf-math.cosh"><code>math.cosh (x)</code></a></h3><br><br><br><p><br>Returns the hyperbolic cosine of <code>x</code>.<br><br><br><br><br></p><p><br></p><hr><h3><a name="pdf-math.deg"><code>math.deg (x)</code></a></h3><br><br><br><p><br>Returns the angle <code>x</code> (given in radians) in degrees.<br><br><br><br><br></p><p><br></p><hr><h3><a name="pdf-math.exp"><code>math.exp (x)</code></a></h3><br><br><br><p><br>Returns the value <em>e<sup>x</sup></em>.<br><br><br><br><br></p><p><br></p><hr><h3><a name="pdf-math.floor"><code>math.floor (x)</code></a></h3><br><br><br><p><br>Returns the largest integer smaller than or equal to <code>x</code>.<br><br><br><br><br></p><p><br></p><hr><h3><a name="pdf-math.fmod"><code>math.fmod (x, y)</code></a></h3><br><br><br><p><br>Returns the remainder of the division of <code>x</code> by <code>y</code><br>that rounds the quotient towards zero.<br><br><br><br><br></p><p><br></p><hr><h3><a name="pdf-math.frexp"><code>math.frexp (x)</code></a></h3><br><br><br><p><br>Returns <code>m</code> and <code>e</code> such that <em>x = m2<sup>e</sup></em>,<br><code>e</code> is an integer and the absolute value of <code>m</code> is<br>in the range <em>[0.5, 1)</em><br>(or zero when <code>x</code> is zero).<br><br><br><br><br></p><p><br></p><hr><h3><a name="pdf-math.huge"><code>math.huge</code></a></h3><br><br><br><p><br>The value <code>HUGE_VAL</code>,<br>a value larger than or equal to any other numerical value.<br><br><br><br><br></p><p><br></p><hr><h3><a name="pdf-math.ldexp"><code>math.ldexp (m, e)</code></a></h3><br><br><br><p><br>Returns <em>m2<sup>e</sup></em> (<code>e</code> should be an integer).<br><br><br><br><br></p><p><br></p><hr><h3><a name="pdf-math.log"><code>math.log (x [, base])</code></a></h3><br><br><br><p><br>Returns the logarithm of <code>x</code> in the given base.<br>The default for <code>base</code> is <em>e</em><br>(so that the function returns the natural logarithm of <code>x</code>).<br><br><br><br><br></p><p><br></p><hr><h3><a name="pdf-math.max"><code>math.max (x, ···)</code></a></h3><br><br><br><p><br>Returns the maximum value among its arguments.<br><br><br><br><br></p><p><br></p><hr><h3><a name="pdf-math.min"><code>math.min (x, ···)</code></a></h3><br><br><br><p><br>Returns the minimum value among its arguments.<br><br><br><br><br></p><p><br></p><hr><h3><a name="pdf-math.modf"><code>math.modf (x)</code></a></h3><br><br><br><p><br>Returns two numbers,<br>the integral part of <code>x</code> and the fractional part of <code>x</code>.<br><br><br><br><br></p><p><br></p><hr><h3><a name="pdf-math.pi"><code>math.pi</code></a></h3><br><br><br><p><br>The value of <em>π</em>.<br><br><br><br><br></p><p><br></p><hr><h3><a name="pdf-math.pow"><code>math.pow (x, y)</code></a></h3><br><br><br><p><br>Returns <em>x<sup>y</sup></em>.<br>(You can also use the expression <code>x^y</code> to compute this value.)<br><br><br><br><br></p><p><br></p><hr><h3><a name="pdf-math.rad"><code>math.rad (x)</code></a></h3><br><br><br><p><br>Returns the angle <code>x</code> (given in degrees) in radians.<br><br><br><br><br></p><p><br></p><hr><h3><a name="pdf-math.random"><code>math.random ([m [, n]])</code></a></h3><br><br><br><p><br>This function is an interface to the simple<br>pseudo-random generator function <code>rand</code> provided by Standard&nbsp;C.<br>(No guarantees can be given for its statistical properties.)<br><br><br></p><p><br>When called without arguments,<br>returns a uniform pseudo-random real number<br>in the range <em>[0,1)</em>.<br>When called with an integer number <code>m</code>,<br><code>math.random</code> returns<br>a uniform pseudo-random integer in the range <em>[1, m]</em>.<br>When called with two integer numbers <code>m</code> and <code>n</code>,<br><code>math.random</code> returns a uniform pseudo-random<br>integer in the range <em>[m, n]</em>.<br><br><br><br><br></p><p><br></p><hr><h3><a name="pdf-math.randomseed"><code>math.randomseed (x)</code></a></h3><br><br><br><p><br>Sets <code>x</code> as the “seed”<br>for the pseudo-random generator:<br>equal seeds produce equal sequences of numbers.<br><br><br><br><br></p><p><br></p><hr><h3><a name="pdf-math.sin"><code>math.sin (x)</code></a></h3><br><br><br><p><br>Returns the sine of <code>x</code> (assumed to be in radians).<br><br><br><br><br></p><p><br></p><hr><h3><a name="pdf-math.sinh"><code>math.sinh (x)</code></a></h3><br><br><br><p><br>Returns the hyperbolic sine of <code>x</code>.<br><br><br><br><br></p><p><br></p><hr><h3><a name="pdf-math.sqrt"><code>math.sqrt (x)</code></a></h3><br><br><br><p><br>Returns the square root of <code>x</code>.<br>(You can also use the expression <code>x^0.5</code> to compute this value.)<br><br><br><br><br></p><p><br></p><hr><h3><a name="pdf-math.tan"><code>math.tan (x)</code></a></h3><br><br><br><p><br>Returns the tangent of <code>x</code> (assumed to be in radians).<br><br><br><br><br></p><p><br></p><hr><h3><a name="pdf-math.tanh"><code>math.tanh (x)</code></a></h3><br><br><br><p><br>Returns the hyperbolic tangent of <code>x</code>.<br><br><br><br><br><br><br><br></p><h2>6.7 – <a name="6.7">Bitwise Operations</a></h2><br><br><p><br>This library provides bitwise operations.<br>It provides all its functions inside the table <a name="pdf-bit32"><code>bit32</code></a>.<br><br><br></p><p><br>Unless otherwise stated,<br>all functions accept numeric arguments in the range<br><em>(-2<sup>51</sup>,+2<sup>51</sup>)</em>;<br>each argument is normalized to<br>the remainder of its division by <em>2<sup>32</sup></em><br>and truncated to an integer (in some unspecified way),<br>so that its final value falls in the range <em>[0,2<sup>32</sup> - 1]</em>.<br>Similarly, all results are in the range <em>[0,2<sup>32</sup> - 1]</em>.<br>Note that <code>bit32.bnot(0)</code> is <code>0xFFFFFFFF</code>,<br>which is different from <code>-1</code>.<br><br><br></p><p><br></p><hr><h3><a name="pdf-bit32.arshift"><code>bit32.arshift (x, disp)</code></a></h3><br><br><br><p><br>Returns the number <code>x</code> shifted <code>disp</code> bits to the right.<br>The number <code>disp</code> may be any representable integer.<br>Negative displacements shift to the left.<br><br><br></p><p><br>This shift operation is what is called arithmetic shift.<br>Vacant bits on the left are filled<br>with copies of the higher bit of <code>x</code>;<br>vacant bits on the right are filled with zeros.<br>In particular,<br>displacements with absolute values higher than 31<br>result in zero or <code>0xFFFFFFFF</code> (all original bits are shifted out).<br><br><br><br><br></p><p><br></p><hr><h3><a name="pdf-bit32.band"><code>bit32.band (···)</code></a></h3><br><br><br><p><br>Returns the bitwise <em>and</em> of its operands.<br><br><br><br><br></p><p><br></p><hr><h3><a name="pdf-bit32.bnot"><code>bit32.bnot (x)</code></a></h3><br><br><br><p><br>Returns the bitwise negation of <code>x</code>.<br>For any integer <code>x</code>,<br>the following identity holds:<br><br></p><pre>     assert(bit32.bnot(x) == (-1 - x) % 2^32)<br></pre><br><br><br><br><p><br></p><hr><h3><a name="pdf-bit32.bor"><code>bit32.bor (···)</code></a></h3><br><br><br><p><br>Returns the bitwise <em>or</em> of its operands.<br><br><br><br><br></p><p><br></p><hr><h3><a name="pdf-bit32.btest"><code>bit32.btest (···)</code></a></h3><br><br><br><p><br>Returns a boolean signaling<br>whether the bitwise <em>and</em> of its operands is different from zero.<br><br><br><br><br></p><p><br></p><hr><h3><a name="pdf-bit32.bxor"><code>bit32.bxor (···)</code></a></h3><br><br><br><p><br>Returns the bitwise <em>exclusive or</em> of its operands.<br><br><br><br><br></p><p><br></p><hr><h3><a name="pdf-bit32.extract"><code>bit32.extract (n, field [, width])</code></a></h3><br><br><br><p><br>Returns the unsigned number formed by the bits<br><code>field</code> to <code>field + width - 1</code> from <code>n</code>.<br>Bits are numbered from 0 (least significant) to 31 (most significant).<br>All accessed bits must be in the range <em>[0, 31]</em>.<br><br><br></p><p><br>The default for <code>width</code> is 1.<br><br><br><br><br></p><p><br></p><hr><h3><a name="pdf-bit32.replace"><code>bit32.replace (n, v, field [, width])</code></a></h3><br><br><br><p><br>Returns a copy of <code>n</code> with<br>the bits <code>field</code> to <code>field + width - 1</code><br>replaced by the value <code>v</code>.<br>See <a href="#pdf-bit32.extract"><code>bit32.extract</code></a> for details about <code>field</code> and <code>width</code>.<br><br><br><br><br></p><p><br></p><hr><h3><a name="pdf-bit32.lrotate"><code>bit32.lrotate (x, disp)</code></a></h3><br><br><br><p><br>Returns the number <code>x</code> rotated <code>disp</code> bits to the left.<br>The number <code>disp</code> may be any representable integer.<br><br><br></p><p><br>For any valid displacement,<br>the following identity holds:<br><br></p><pre>     assert(bit32.lrotate(x, disp) == bit32.lrotate(x, disp % 32))<br></pre><p><br>In particular,<br>negative displacements rotate to the right.<br><br><br><br><br></p><p><br></p><hr><h3><a name="pdf-bit32.lshift"><code>bit32.lshift (x, disp)</code></a></h3><br><br><br><p><br>Returns the number <code>x</code> shifted <code>disp</code> bits to the left.<br>The number <code>disp</code> may be any representable integer.<br>Negative displacements shift to the right.<br>In any direction, vacant bits are filled with zeros.<br>In particular,<br>displacements with absolute values higher than 31<br>result in zero (all bits are shifted out).<br><br><br></p><p><br>For positive displacements,<br>the following equality holds:<br><br></p><pre>     assert(bit32.lshift(b, disp) == (b  2^disp) % 2^32)<br></pre><br><br><br><br><p><br></p><hr><h3><a name="pdf-bit32.rrotate"><code>bit32.rrotate (x, disp)</code></a></h3><br><br><br><p><br>Returns the number <code>x</code> rotated <code>disp</code> bits to the right.<br>The number <code>disp</code> may be any representable integer.<br><br><br></p><p><br>For any valid displacement,<br>the following identity holds:<br><br></p><pre>     assert(bit32.rrotate(x, disp) == bit32.rrotate(x, disp % 32))<br></pre><p><br>In particular,<br>negative displacements rotate to the left.<br><br><br><br><br></p><p><br></p><hr><h3><a name="pdf-bit32.rshift"><code>bit32.rshift (x, disp)</code></a></h3><br><br><br><p><br>Returns the number <code>x</code> shifted <code>disp</code> bits to the right.<br>The number <code>disp</code> may be any representable integer.<br>Negative displacements shift to the left.<br>In any direction, vacant bits are filled with zeros.<br>In particular,<br>displacements with absolute values higher than 31<br>result in zero (all bits are shifted out).<br><br><br></p><p><br>For positive displacements,<br>the following equality holds:<br><br></p><pre>     assert(bit32.rshift(b, disp) == math.floor(b % 2^32 / 2^disp))<br></pre><br><br><p><br>This shift operation is what is called logical shift.<br><br><br><br><br><br><br><br></p><h2>6.8 – <a name="6.8">Input and Output Facilities</a></h2><br><br><p><br>The I/O library provides two different styles for file manipulation.<br>The first one uses implicit file descriptors;<br>that is, there are operations to set a default input file and a<br>default output file,<br>and all input/output operations are over these default files.<br>The second style uses explicit file descriptors.<br><br><br></p><p><br>When using implicit file descriptors,<br>all operations are supplied by table <a name="pdf-io"><code>io</code></a>.<br>When using explicit file descriptors,<br>the operation <a href="#pdf-io.open"><code>io.open</code></a> returns a file descriptor<br>and then all operations are supplied as methods of the file descriptor.<br><br><br></p><p><br>The table <code>io</code> also provides<br>three predefined file descriptors with their usual meanings from C:<br><a name="pdf-io.stdin"><code>io.stdin</code></a>, <a name="pdf-io.stdout"><code>io.stdout</code></a>, and <a name="pdf-io.stderr"><code>io.stderr</code></a>.<br>The I/O library never closes these files.<br><br><br></p><p><br>Unless otherwise stated,<br>all I/O functions return <b>nil</b> on failure<br>(plus an error message as a second result and<br>a system-dependent error code as a third result)<br>and some value different from <b>nil</b> on success.<br>On non-Posix systems,<br>the computation of the error message and error code<br>in case of errors<br>may be not thread safe,<br>because they rely on the global C variable <code>errno</code>.<br><br><br></p><p><br></p><hr><h3><a name="pdf-io.close"><code>io.close ([file])</code></a></h3><br><br><br><p><br>Equivalent to <code>file:close()</code>.<br>Without a <code>file</code>, closes the default output file.<br><br><br><br><br></p><p><br></p><hr><h3><a name="pdf-io.flush"><code>io.flush ()</code></a></h3><br><br><br><p><br>Equivalent to <code>io.output():flush()</code>.<br><br><br><br><br></p><p><br></p><hr><h3><a name="pdf-io.input"><code>io.input ([file])</code></a></h3><br><br><br><p><br>When called with a file name, it opens the named file (in text mode),<br>and sets its handle as the default input file.<br>When called with a file handle,<br>it simply sets this file handle as the default input file.<br>When called without parameters,<br>it returns the current default input file.<br><br><br></p><p><br>In case of errors this function raises the error,<br>instead of returning an error code.<br><br><br><br><br></p><p><br></p><hr><h3><a name="pdf-io.lines"><code>io.lines ([filename ···])</code></a></h3><br><br><br><p><br>Opens the given file name in read mode<br>and returns an iterator function that<br>works like <code>file:lines(···)</code> over the opened file.<br>When the iterator function detects the end of file,<br>it returns <b>nil</b> (to finish the loop) and automatically closes the file.<br><br><br></p><p><br>The call <code>io.lines()</code> (with no file name) is equivalent<br>to <code>io.input():lines()</code>;<br>that is, it iterates over the lines of the default input file.<br>In this case it does not close the file when the loop ends.<br><br><br></p><p><br>In case of errors this function raises the error,<br>instead of returning an error code.<br><br><br><br><br></p><p><br></p><hr><h3><a name="pdf-io.open"><code>io.open (filename [, mode])</code></a></h3><br><br><br><p><br>This function opens a file,<br>in the mode specified in the string <code>mode</code>.<br>It returns a new file handle,<br>or, in case of errors, <b>nil</b> plus an error message.<br><br><br></p><p><br>The <code>mode</code> string can be any of the following:<br><br></p><ul><br><li><b>“<code>r</code>“: </b> read mode (the default);</li><br><li><b>“<code>w</code>“: </b> write mode;</li><br><li><b>“<code>a</code>“: </b> append mode;</li><br><li><b>“<code>r+</code>“: </b> update mode, all previous data is preserved;</li><br><li><b>“<code>w+</code>“: </b> update mode, all previous data is erased;</li><br><li><b>“<code>a+</code>“: </b> append update mode, previous data is preserved,<br>  writing is only allowed at the end of file.</li><br></ul><p><br>The <code>mode</code> string can also have a ‘<code>b</code>‘ at the end,<br>which is needed in some systems to open the file in binary mode.<br><br><br><br><br></p><p><br></p><hr><h3><a name="pdf-io.output"><code>io.output ([file])</code></a></h3><br><br><br><p><br>Similar to <a href="#pdf-io.input"><code>io.input</code></a>, but operates over the default output file.<br><br><br><br><br></p><p><br></p><hr><h3><a name="pdf-io.popen"><code>io.popen (prog [, mode])</code></a></h3><br><br><br><p><br>This function is system dependent and is not available<br>on all platforms.<br><br><br></p><p><br>Starts program <code>prog</code> in a separated process and returns<br>a file handle that you can use to read data from this program<br>(if <code>mode</code> is <code>“r”</code>, the default)<br>or to write data to this program<br>(if <code>mode</code> is <code>“w”</code>).<br><br><br><br><br></p><p><br></p><hr><h3><a name="pdf-io.read"><code>io.read (···)</code></a></h3><br><br><br><p><br>Equivalent to <code>io.input():read(···)</code>.<br><br><br><br><br></p><p><br></p><hr><h3><a name="pdf-io.tmpfile"><code>io.tmpfile ()</code></a></h3><br><br><br><p><br>Returns a handle for a temporary file.<br>This file is opened in update mode<br>and it is automatically removed when the program ends.<br><br><br><br><br></p><p><br></p><hr><h3><a name="pdf-io.type"><code>io.type (obj)</code></a></h3><br><br><br><p><br>Checks whether <code>obj</code> is a valid file handle.<br>Returns the string <code>“file”</code> if <code>obj</code> is an open file handle,<br><code>“closed file”</code> if <code>obj</code> is a closed file handle,<br>or <b>nil</b> if <code>obj</code> is not a file handle.<br><br><br><br><br></p><p><br></p><hr><h3><a name="pdf-io.write"><code>io.write (···)</code></a></h3><br><br><br><p><br>Equivalent to <code>io.output():write(···)</code>.<br><br><br><br><br></p><p><br></p><hr><h3><a name="pdf-file:close"><code>file:close ()</code></a></h3><br><br><br><p><br>Closes <code>file</code>.<br>Note that files are automatically closed when<br>their handles are garbage collected,<br>but that takes an unpredictable amount of time to happen.<br><br><br></p><p><br>When closing a file handle created with <a href="#pdf-io.popen"><code>io.popen</code></a>,<br><a href="#pdf-file:close"><code>file:close</code></a> returns the same values<br>returned by <a href="#pdf-os.execute"><code>os.execute</code></a>.<br><br><br><br><br></p><p><br></p><hr><h3><a name="pdf-file:flush"><code>file:flush ()</code></a></h3><br><br><br><p><br>Saves any written data to <code>file</code>.<br><br><br><br><br></p><p><br></p><hr><h3><a name="pdf-file:lines"><code>file:lines (···)</code></a></h3><br><br><br><p><br>Returns an iterator function that,<br>each time it is called,<br>reads the file according to the given formats.<br>When no format is given,<br>uses “<em>l” as a default.<br>As an example, the construction<br><br></em></p><pre>     for c in file:lines(1) do <em>body</em> end<br></pre><p><br>will iterate over all characters of the file,<br>starting at the current position.<br>Unlike <a href="#pdf-io.lines"><code>io.lines</code></a>, this function does not close the file<br>when the loop ends.<br><br><br></p><p><br>In case of errors this function raises the error,<br>instead of returning an error code.<br><br><br><br><br></p><p><br></p><hr><h3><a name="pdf-file:read"><code>file:read (···)</code></a></h3><br><br><br><p><br>Reads the file <code>file</code>,<br>according to the given formats, which specify what to read.<br>For each format,<br>the function returns a string (or a number) with the characters read,<br>or <b>nil</b> if it cannot read data with the specified format.<br>When called without formats,<br>it uses a default format that reads the next line<br>(see below).<br><br><br></p><p><br>The available formats are<br><br></p><ul><br><br><li><b>“<code>n</code>“: </b><br>reads a number;<br>this is the only format that returns a number instead of a string.<br></li><br><br><li><b>“<code><em>a</em></code>“: </b><br>reads the whole file, starting at the current position.<br>On end of file, it returns the empty string.<br></li><br><br><li><b>“<code>l</code>“: </b><br>reads the next line skipping the end of line,<br>returning <b>nil</b> on end of file.<br>This is the default format.<br></li><br><br><li><b>“<code><em>L</em></code>“: </b><br>reads the next line keeping the end of line (if present),<br>returning <b>nil</b> on end of file.<br></li><br><br><li><b><em>number</em>: </b><br>reads a string with up to this number of bytes,<br>returning <b>nil</b> on end of file.<br>If number is zero,<br>it reads nothing and returns an empty string,<br>or <b>nil</b> on end of file.<br></li><br><br></ul><br><br><br><br><p><br></p><hr><h3><a name="pdf-file:seek"><code>file:seek ([whence [, offset]])</code></a></h3><br><br><br><p><br>Sets and gets the file position,<br>measured from the beginning of the file,<br>to the position given by <code>offset</code> plus a base<br>specified by the string <code>whence</code>, as follows:<br><br></p><ul><br><li><b>“<code>set</code>“: </b> base is position 0 (beginning of the file);</li><br><li><b>“<code>cur</code>“: </b> base is current position;</li><br><li><b>“<code>end</code>“: </b> base is end of file;</li><br></ul><p><br>In case of success, <code>seek</code> returns the final file position,<br>measured in bytes from the beginning of the file.<br>If <code>seek</code> fails, it returns <b>nil</b>,<br>plus a string describing the error.<br><br><br></p><p><br>The default value for <code>whence</code> is <code>“cur”</code>,<br>and for <code>offset</code> is 0.<br>Therefore, the call <code>file:seek()</code> returns the current<br>file position, without changing it;<br>the call <code>file:seek(“set”)</code> sets the position to the<br>beginning of the file (and returns 0);<br>and the call <code>file:seek(“end”)</code> sets the position to the<br>end of the file, and returns its size.<br><br><br><br><br></p><p><br></p><hr><h3><a name="pdf-file:setvbuf"><code>file:setvbuf (mode [, size])</code></a></h3><br><br><br><p><br>Sets the buffering mode for an output file.<br>There are three available modes:<br><br></p><ul><br><br><li><b>“<code>no</code>“: </b><br>no buffering; the result of any output operation appears immediately.<br></li><br><br><li><b>“<code>full</code>“: </b><br>full buffering; output operation is performed only<br>when the buffer is full or when<br>you explicitly <code>flush</code> the file (see <a href="#pdf-io.flush"><code>io.flush</code></a>).<br></li><br><br><li><b>“<code>line</code>“: </b><br>line buffering; output is buffered until a newline is output<br>or there is any input from some special files<br>(such as a terminal device).<br></li><br><br></ul><p><br>For the last two cases, <code>size</code><br>specifies the size of the buffer, in bytes.<br>The default is an appropriate size.<br><br><br><br><br></p><p><br></p><hr><h3><a name="pdf-file:write"><code>file:write (···)</code></a></h3><br><br><br><p><br>Writes the value of each of its arguments to <code>file</code>.<br>The arguments must be strings or numbers.<br><br><br></p><p><br>In case of success, this function returns <code>file</code>.<br>Otherwise it returns <b>nil</b> plus a string describing the error.<br><br><br><br><br><br><br><br></p><h2>6.9 – <a name="6.9">Operating System Facilities</a></h2><br><br><p><br>This library is implemented through table <a name="pdf-os"><code>os</code></a>.<br><br><br></p><p><br></p><hr><h3><a name="pdf-os.clock"><code>os.clock ()</code></a></h3><br><br><br><p><br>Returns an approximation of the amount in seconds of CPU time<br>used by the program.<br><br><br><br><br></p><p><br></p><hr><h3><a name="pdf-os.date"><code>os.date ([format [, time]])</code></a></h3><br><br><br><p><br>Returns a string or a table containing date and time,<br>formatted according to the given string <code>format</code>.<br><br><br></p><p><br>If the <code>time</code> argument is present,<br>this is the time to be formatted<br>(see the <a href="#pdf-os.time"><code>os.time</code></a> function for a description of this value).<br>Otherwise, <code>date</code> formats the current time.<br><br><br></p><p><br>If <code>format</code> starts with ‘<code>!</code>‘,<br>then the date is formatted in Coordinated Universal Time.<br>After this optional character,<br>if <code>format</code> is the string “<code>t</code>“,<br>then <code>date</code> returns a table with the following fields:<br><code>year</code> (four digits), <code>month</code> (1–12), <code>day</code> (1–31),<br><code>hour</code> (0–23), <code>min</code> (0–59), <code>sec</code> (0–61),<br><code>wday</code> (weekday, Sunday is&nbsp;1),<br><code>yday</code> (day of the year),<br>and <code>isdst</code> (daylight saving flag, a boolean).<br>This last field may be absent<br>if the information is not available.<br><br><br></p><p><br>If <code>format</code> is not “<code><em>t</em></code>“,<br>then <code>date</code> returns the date as a string,<br>formatted according to the same rules as the ANSI&nbsp;C function <code>strftime</code>.<br><br><br></p><p><br>When called without arguments,<br><code>date</code> returns a reasonable date and time representation that depends on<br>the host system and on the current locale<br>(that is, <code>os.date()</code> is equivalent to <code>os.date(“%c”)</code>).<br><br><br></p><p><br>On non-Posix systems,<br>this function may be not thread safe<br>because of its reliance on C&nbsp;function <code>gmtime</code> and C&nbsp;function <code>localtime</code>.<br><br><br><br><br></p><p><br></p><hr><h3><a name="pdf-os.difftime"><code>os.difftime (t2, t1)</code></a></h3><br><br><br><p><br>Returns the number of seconds from time <code>t1</code> to time <code>t2</code>.<br>In POSIX, Windows, and some other systems,<br>this value is exactly <code>t2</code><em>-</em><code>t1</code>.<br><br><br><br><br></p><p><br></p><hr><h3><a name="pdf-os.execute"><code>os.execute ([command])</code></a></h3><br><br><br><p><br>This function is equivalent to the ANSI&nbsp;C function <code>system</code>.<br>It passes <code>command</code> to be executed by an operating system shell.<br>Its first result is <b>true</b><br>if the command terminated successfully,<br>or <b>nil</b> otherwise.<br>After this first result<br>the function returns a string and a number,<br>as follows:<br><br></p><ul><br><br><li><b>“<code>exit</code>“: </b><br>the command terminated normally;<br>the following number is the exit status of the command.<br></li><br><br><li><b>“<code>signal</code>“: </b><br>the command was terminated by a signal;<br>the following number is the signal that terminated the command.<br></li><br><br></ul><br><br><p><br>When called without a <code>command</code>,<br><code>os.execute</code> returns a boolean that is true if a shell is available.<br><br><br><br><br></p><p><br></p><hr><h3><a name="pdf-os.exit"><code>os.exit ([code [, close])</code></a></h3><br><br><br><p><br>Calls the ANSI&nbsp;C function <code>exit</code> to terminate the host program.<br>If <code>code</code> is <b>true</b>,<br>the returned status is <code>EXIT_SUCCESS</code>;<br>if <code>code</code> is <b>false</b>,<br>the returned status is <code>EXIT_FAILURE</code>;<br>if <code>code</code> is a number,<br>the returned status is this number.<br>The default value for <code>code</code> is <b>true</b>.<br><br><br></p><p><br>If the optional second argument <code>close</code> is true,<br>closes the Lua state before exiting.<br><br><br><br><br></p><p><br></p><hr><h3><a name="pdf-os.getenv"><code>os.getenv (varname)</code></a></h3><br><br><br><p><br>Returns the value of the process environment variable <code>varname</code>,<br>or <b>nil</b> if the variable is not defined.<br><br><br><br><br></p><p><br></p><hr><h3><a name="pdf-os.remove"><code>os.remove (filename)</code></a></h3><br><br><br><p><br>Deletes the file (or empty directory, on POSIX systems)<br>with the given name.<br>If this function fails, it returns <b>nil</b>,<br>plus a string describing the error and the error code.<br><br><br><br><br></p><p><br></p><hr><h3><a name="pdf-os.rename"><code>os.rename (oldname, newname)</code></a></h3><br><br><br><p><br>Renames file or directory named <code>oldname</code> to <code>newname</code>.<br>If this function fails, it returns <b>nil</b>,<br>plus a string describing the error and the error code.<br><br><br><br><br></p><p><br></p><hr><h3><a name="pdf-os.setlocale"><code>os.setlocale (locale [, category])</code></a></h3><br><br><br><p><br>Sets the current locale of the program.<br><code>locale</code> is a system-dependent string specifying a locale;<br><code>category</code> is an optional string describing which category to change:<br><code>“all”</code>, <code>“collate”</code>, <code>“ctype”</code>,<br><code>“monetary”</code>, <code>“numeric”</code>, or <code>“time”</code>;<br>the default category is <code>“all”</code>.<br>The function returns the name of the new locale,<br>or <b>nil</b> if the request cannot be honored.<br><br><br></p><p><br>If <code>locale</code> is the empty string,<br>the current locale is set to an implementation-defined native locale.<br>If <code>locale</code> is the string “<code>C</code>“,<br>the current locale is set to the standard C locale.<br><br><br></p><p><br>When called with <b>nil</b> as the first argument,<br>this function only returns the name of the current locale<br>for the given category.<br><br><br></p><p><br>This function may be not thread safe<br>because of its reliance on C&nbsp;function <code>setlocale</code>.<br><br><br><br><br></p><p><br></p><hr><h3><a name="pdf-os.time"><code>os.time ([table])</code></a></h3><br><br><br><p><br>Returns the current time when called without arguments,<br>or a time representing the date and time specified by the given table.<br>This table must have fields <code>year</code>, <code>month</code>, and <code>day</code>,<br>and may have fields<br><code>hour</code> (default is 12),<br><code>min</code> (default is 0),<br><code>sec</code> (default is 0),<br>and <code>isdst</code> (default is <b>nil</b>).<br>For a description of these fields, see the <a href="#pdf-os.date"><code>os.date</code></a> function.<br><br><br></p><p><br>The returned value is a number, whose meaning depends on your system.<br>In POSIX, Windows, and some other systems,<br>this number counts the number<br>of seconds since some given start time (the “epoch”).<br>In other systems, the meaning is not specified,<br>and the number returned by <code>time</code> can be used only as an argument to<br><a href="#pdf-os.date"><code>os.date</code></a> and <a href="#pdf-os.difftime"><code>os.difftime</code></a>.<br><br><br><br><br></p><p><br></p><hr><h3><a name="pdf-os.tmpname"><code>os.tmpname ()</code></a></h3><br><br><br><p><br>Returns a string with a file name that can<br>be used for a temporary file.<br>The file must be explicitly opened before its use<br>and explicitly removed when no longer needed.<br><br><br></p><p><br>On POSIX systems,<br>this function also creates a file with that name,<br>to avoid security risks.<br>(Someone else might create the file with wrong permissions<br>in the time between getting the name and creating the file.)<br>You still have to open the file to use it<br>and to remove it (even if you do not use it).<br><br><br></p><p><br>When possible,<br>you may prefer to use <a href="#pdf-io.tmpfile"><code>io.tmpfile</code></a>,<br>which automatically removes the file when the program ends.<br><br><br><br><br><br><br><br></p><h2>6.10 – <a name="6.10">The Debug Library</a></h2><br><br><p><br>This library provides<br>the functionality of the debug interface (<a href="#4.9">§4.9</a>) to Lua programs.<br>You should exert care when using this library.<br>Several of its functions<br>violate basic assumptions about Lua code<br>(e.g., that variables local to a function<br>cannot be accessed from outside;<br>that userdata metatables cannot be changed by Lua code;<br>that Lua programs do not crash)<br>and therefore can compromise otherwise secure code.<br>Moreover, some functions in this library may be slow.<br><br><br></p><p><br>All functions in this library are provided<br>inside the <a name="pdf-debug"><code>debug</code></a> table.<br>All functions that operate over a thread<br>have an optional first argument which is the<br>thread to operate over.<br>The default is always the current thread.<br><br><br></p><p><br></p><hr><h3><a name="pdf-debug.debug"><code>debug.debug ()</code></a></h3><br><br><br><p><br>Enters an interactive mode with the user,<br>running each string that the user enters.<br>Using simple commands and other debug facilities,<br>the user can inspect global and local variables,<br>change their values, evaluate expressions, and so on.<br>A line containing only the word <code>cont</code> finishes this function,<br>so that the caller continues its execution.<br><br><br></p><p><br>Note that commands for <code>debug.debug</code> are not lexically nested<br>within any function and so have no direct access to local variables.<br><br><br><br><br></p><p><br></p><hr><h3><a name="pdf-debug.gethook"><code>debug.gethook ([thread])</code></a></h3><br><br><br><p><br>Returns the current hook settings of the thread, as three values:<br>the current hook function, the current hook mask,<br>and the current hook count<br>(as set by the <a href="#pdf-debug.sethook"><code>debug.sethook</code></a> function).<br><br><br><br><br></p><p><br></p><hr><h3><a name="pdf-debug.getinfo"><code>debug.getinfo ([thread,] f [, what])</code></a></h3><br><br><br><p><br>Returns a table with information about a function.<br>You can give the function directly<br>or you can give a number as the value of <code>f</code>,<br>which means the function running at level <code>f</code> of the call stack<br>of the given thread:<br>level&nbsp;0 is the current function (<code>getinfo</code> itself);<br>level&nbsp;1 is the function that called <code>getinfo</code><br>(except for tail calls, which do not count on the stack);<br>and so on.<br>If <code>f</code> is a number larger than the number of active functions,<br>then <code>getinfo</code> returns <b>nil</b>.<br><br><br></p><p><br>The returned table can contain all the fields returned by <a href="#lua_getinfo"><code>lua_getinfo</code></a>,<br>with the string <code>what</code> describing which fields to fill in.<br>The default for <code>what</code> is to get all information available,<br>except the table of valid lines.<br>If present,<br>the option ‘<code>f</code>‘<br>adds a field named <code>func</code> with the function itself.<br>If present,<br>the option ‘<code>L</code>‘<br>adds a field named <code>activelines</code> with the table of<br>valid lines.<br><br><br></p><p><br>For instance, the expression <code>debug.getinfo(1,”n”).name</code> returns<br>a table with a name for the current function,<br>if a reasonable name can be found,<br>and the expression <code>debug.getinfo(print)</code><br>returns a table with all available information<br>about the <a href="#pdf-print"><code>print</code></a> function.<br><br><br><br><br></p><p><br></p><hr><h3><a name="pdf-debug.getlocal"><code>debug.getlocal ([thread,] f, local)</code></a></h3><br><br><br><p><br>This function returns the name and the value of the local variable<br>with index <code>local</code> of the function at level <code>f</code> of the stack.<br>This function accesses not only explicit local variables,<br>but also parameters, temporaries, etc.<br><br><br></p><p><br>The first parameter or local variable has index&nbsp;1, and so on,<br>until the last active variable.<br>Negative indices refer to vararg parameters;<br>-1 is the first vararg parameter.<br>The function returns <b>nil</b> if there is no variable with the given index,<br>and raises an error when called with a level out of range.<br>(You can call <a href="#pdf-debug.getinfo"><code>debug.getinfo</code></a> to check whether the level is valid.)<br><br><br></p><p><br>Variable names starting with ‘<code>(</code>‘ (open parenthesis)<br>represent internal variables<br>(loop control variables, temporaries, varargs, and C&nbsp;function locals).<br><br><br></p><p><br>The parameter <code>f</code> may also be a function.<br>In that case, <code>getlocal</code> returns only the name of function parameters.<br><br><br><br><br></p><p><br></p><hr><h3><a name="pdf-debug.getmetatable"><code>debug.getmetatable (value)</code></a></h3><br><br><br><p><br>Returns the metatable of the given <code>value</code><br>or <b>nil</b> if it does not have a metatable.<br><br><br><br><br></p><p><br></p><hr><h3><a name="pdf-debug.getregistry"><code>debug.getregistry ()</code></a></h3><br><br><br><p><br>Returns the registry table (see <a href="#4.5">§4.5</a>).<br><br><br><br><br></p><p><br></p><hr><h3><a name="pdf-debug.getupvalue"><code>debug.getupvalue (f, up)</code></a></h3><br><br><br><p><br>This function returns the name and the value of the upvalue<br>with index <code>up</code> of the function <code>f</code>.<br>The function returns <b>nil</b> if there is no upvalue with the given index.<br><br><br><br><br></p><p><br></p><hr><h3><a name="pdf-debug.getuservalue"><code>debug.getuservalue (u)</code></a></h3><br><br><br><p><br>Returns the Lua value associated to <code>u</code>.<br>If <code>u</code> is not a userdata,<br>returns <b>nil</b>.<br><br><br><br><br></p><p><br></p><hr><h3><a name="pdf-debug.sethook"><code>debug.sethook ([thread,] hook, mask [, count])</code></a></h3><br><br><br><p><br>Sets the given function as a hook.<br>The string <code>mask</code> and the number <code>count</code> describe<br>when the hook will be called.<br>The string mask may have the following characters,<br>with the given meaning:<br><br></p><ul><br><li><b>‘<code>c</code>‘: </b> the hook is called every time Lua calls a function;</li><br><li><b>‘<code>r</code>‘: </b> the hook is called every time Lua returns from a function;</li><br><li><b>‘<code>l</code>‘: </b> the hook is called every time Lua enters a new line of code.</li><br></ul><p><br>With a <code>count</code> different from zero,<br>the hook is called after every <code>count</code> instructions.<br><br><br></p><p><br>When called without arguments,<br><a href="#pdf-debug.sethook"><code>debug.sethook</code></a> turns off the hook.<br><br><br></p><p><br>When the hook is called, its first parameter is a string<br>describing the event that has triggered its call:<br><code>“call”</code> (or <code>“tail call”</code>),<br><code>“return”</code>,<br><code>“line”</code>, and <code>“count”</code>.<br>For line events,<br>the hook also gets the new line number as its second parameter.<br>Inside a hook,<br>you can call <code>getinfo</code> with level&nbsp;2 to get more information about<br>the running function<br>(level&nbsp;0 is the <code>getinfo</code> function,<br>and level&nbsp;1 is the hook function).<br><br><br><br><br></p><p><br></p><hr><h3><a name="pdf-debug.setlocal"><code>debug.setlocal ([thread,] level, local, value)</code></a></h3><br><br><br><p><br>This function assigns the value <code>value</code> to the local variable<br>with index <code>local</code> of the function at level <code>level</code> of the stack.<br>The function returns <b>nil</b> if there is no local<br>variable with the given index,<br>and raises an error when called with a <code>level</code> out of range.<br>(You can call <code>getinfo</code> to check whether the level is valid.)<br>Otherwise, it returns the name of the local variable.<br><br><br></p><p><br>See <a href="#pdf-debug.getlocal"><code>debug.getlocal</code></a> for more information about<br>variable indices and names.<br><br><br><br><br></p><p><br></p><hr><h3><a name="pdf-debug.setmetatable"><code>debug.setmetatable (value, table)</code></a></h3><br><br><br><p><br>Sets the metatable for the given <code>value</code> to the given <code>table</code><br>(which can be <b>nil</b>).<br>Returns <code>value</code>.<br><br><br><br><br></p><p><br></p><hr><h3><a name="pdf-debug.setupvalue"><code>debug.setupvalue (f, up, value)</code></a></h3><br><br><br><p><br>This function assigns the value <code>value</code> to the upvalue<br>with index <code>up</code> of the function <code>f</code>.<br>The function returns <b>nil</b> if there is no upvalue<br>with the given index.<br>Otherwise, it returns the name of the upvalue.<br><br><br><br><br></p><p><br></p><hr><h3><a name="pdf-debug.setuservalue"><code>debug.setuservalue (udata, value)</code></a></h3><br><br><br><p><br>Sets the given <code>value</code> as<br>the Lua value associated to the given <code>udata</code>.<br><code>value</code> must be a table or <b>nil</b>;<br><code>udata</code> must be a full userdata.<br><br><br></p><p><br>Returns <code>udata</code>.<br><br><br><br><br></p><p><br></p><hr><h3><a name="pdf-debug.traceback"><code>debug.traceback ([thread,] [message [, level]])</code></a></h3><br><br><br><p><br>If <code>message</code> is present but is neither a string nor <b>nil</b>,<br>this function returns <code>message</code> without further processing.<br>Otherwise,<br>it returns a string with a traceback of the call stack.<br>An optional <code>message</code> string is appended<br>at the beginning of the traceback.<br>An optional <code>level</code> number tells at which level<br>to start the traceback<br>(default is 1, the function calling <code>traceback</code>).<br><br><br><br><br></p><p><br></p><hr><h3><a name="pdf-debug.upvalueid"><code>debug.upvalueid (f, n)</code></a></h3><br><br><br><p><br>Returns an unique identifier (as a light userdata)<br>for the upvalue numbered <code>n</code><br>from the given function.<br><br><br></p><p><br>These unique identifiers allow a program to check whether different<br>closures share upvalues.<br>Lua closures that share an upvalue<br>(that is, that access a same external local variable)<br>will return identical ids for those upvalue indices.<br><br><br><br><br></p><p><br></p><hr><h3><a name="pdf-debug.upvaluejoin"><code>debug.upvaluejoin (f1, n1, f2, n2)</code></a></h3><br><br><br><p><br>Make the <code>n1</code>-th upvalue of the Lua closure <code>f1</code><br>refer to the <code>n2</code>-th upvalue of the Lua closure <code>f2</code>.<br><br><br><br><br><br><br><br></p><h1>7 – <a name="7">Lua Standalone</a></h1><br><br><p><br>Although Lua has been designed as an extension language,<br>to be embedded in a host C&nbsp;program,<br>it is also frequently used as a standalone language.<br>An interpreter for Lua as a standalone language,<br>called simply <code>lua</code>,<br>is provided with the standard distribution.<br>The standalone interpreter includes<br>all standard libraries, including the debug library.<br>Its usage is:<br><br></p><pre>     lua [options] [script [args]]<br></pre><p><br>The options are:<br><br></p><ul><br><li><b><code>-e <em>stat</em></code>: </b> executes string <em>stat</em>;</li><br><li><b><code>-l <em>mod</em></code>: </b> “requires” <em>mod</em>;</li><br><li><b><code>-i</code>: </b> enters interactive mode after running <em>script</em>;</li><br><li><b><code>-v</code>: </b> prints version information;</li><br><li><b><code>-E</code>: </b> ignores environment variables;</li><br><li><b><code>–</code>: </b> stops handling options;</li><br><li><b><code>-</code>: </b> executes <code>stdin</code> as a file and stops handling options.</li><br></ul><p><br>After handling its options, <code>lua</code> runs the given <em>script</em>,<br>passing to it the given <em>args</em> as string arguments.<br>When called without arguments,<br><code>lua</code> behaves as <code>lua -v -i</code><br>when the standard input (<code>stdin</code>) is a terminal,<br>and as <code>lua -</code> otherwise.<br><br><br></p><p><br>When called without option <code>-E</code>,<br>the interpreter checks for an environment variable <a name="pdf-LUA_INIT_5_2"><code>LUA_INIT_5_2</code></a><br>(or <a name="pdf-LUA_INIT"><code>LUA_INIT</code></a> if it is not defined)<br>before running any argument.<br>If the variable content has the format <code>@<em>filename</em></code>,<br>then <code>lua</code> executes the file.<br>Otherwise, <code>lua</code> executes the string itself.<br><br><br></p><p><br>When called with option <code>-E</code>,<br>besides ignoring <code>LUA_INIT</code>,<br>Lua also ignores<br>the values of <code>LUA_PATH</code> and <code>LUA_CPATH</code>,<br>setting the values of<br><a href="#pdf-package.path"><code>package.path</code></a> and <a href="#pdf-package.cpath"><code>package.cpath</code></a><br>with the default paths defined in <code>luaconf.h</code>.<br><br><br></p><p><br>All options are handled in order, except <code>-i</code> and <code>-E</code>.<br>For instance, an invocation like<br><br></p><pre>     $ lua -e’a=1’ -e ‘print(a)’ script.lua<br></pre><p><br>will first set <code>a</code> to 1, then print the value of <code>a</code>,<br>and finally run the file <code>script.lua</code> with no arguments.<br>(Here <code>$</code> is the shell prompt. Your prompt may be different.)<br><br><br></p><p><br>Before starting to run the script,<br><code>lua</code> collects all arguments in the command line<br>in a global table called <code>arg</code>.<br>The script name is stored at index 0,<br>the first argument after the script name goes to index 1,<br>and so on.<br>Any arguments before the script name<br>(that is, the interpreter name plus the options)<br>go to negative indices.<br>For instance, in the call<br><br></p><pre>     $ lua -la b.lua t1 t2<br></pre><p><br>the interpreter first runs the file <code>a.lua</code>,<br>then creates a table<br><br></p><pre>     arg = { [-2] = “lua”, [-1] = “-la”,<br>             [0] = “b.lua”,<br>             [1] = “t1”, [2] = “t2” }<br></pre><p><br>and finally runs the file <code>b.lua</code>.<br>The script is called with <code>arg[1]</code>, <code>arg[2]</code>, …<br>as arguments;<br>it can also access these arguments with the vararg expression ‘<code>…</code>‘.<br><br><br></p><p><br>In interactive mode,<br>if you write an incomplete statement,<br>the interpreter waits for its completion<br>by issuing a different prompt.<br><br><br></p><p><br>In case of unprotected errors in the script,<br>the interpreter reports the error to the standard error stream.<br>If the error object is a string,<br>the interpreter adds a stack traceback to it.<br>Otherwise, if the error object has a metamethod <code><strong>tostring</strong></code>,<br>the interpreter calls this metamethod to produce the final message.<br>Finally, if the error object is <b>nil</b>,<br>the interpreter does not report the error.<br><br><br></p><p><br>When finishing normally,<br>the interpreter closes its main Lua state<br>(see <a href="#lua_close"><code>lua_close</code></a>).<br>The script can avoid this step by<br>calling <a href="#pdf-os.exit"><code>os.exit</code></a> to terminate.<br><br><br></p><p><br>To allow the use of Lua as a<br>script interpreter in Unix systems,<br>the standalone interpreter skips<br>the first line of a chunk if it starts with <code>#</code>.<br>Therefore, Lua scripts can be made into executable programs<br>by using <code>chmod +x</code> and the&nbsp;<code>#!</code> form,<br>as in<br><br></p><pre>     #!/usr/local/bin/lua<br></pre><p><br>(Of course,<br>the location of the Lua interpreter may be different in your machine.<br>If <code>lua</code> is in your <code>PATH</code>,<br>then<br><br></p><pre>     #!/usr/bin/env lua<br></pre><p><br>is a more portable solution.)<br><br><br><br></p><h1>8 – <a name="8">Incompatibilities with the Previous Version</a></h1><br><br><p><br>Here we list the incompatibilities that you may find when moving a program<br>from Lua&nbsp;5.1 to Lua&nbsp;5.2.<br>You can avoid some incompatibilities by compiling Lua with<br>appropriate options (see file <code>luaconf.h</code>).<br>However,<br>all these compatibility options will be removed in the next version of Lua.<br>Similarly,<br>all features marked as deprecated in Lua&nbsp;5.1<br>have been removed in Lua&nbsp;5.2.<br><br><br><br></p><h2>8.1 – <a name="8.1">Changes in the Language</a></h2><br><ul><br><br><li><br>The concept of <em>environment</em> changed.<br>Only Lua functions have environments.<br>To set the environment of a Lua function,<br>use the variable <code>_ENV</code> or the function <a href="#pdf-load"><code>load</code></a>.<br><br><br><p><br>C functions no longer have environments.<br>Use an upvalue with a shared table if you need to keep<br>shared state among several C functions.<br>(You may use <a href="#luaL_setfuncs"><code>luaL_setfuncs</code></a> to open a C library<br>with all functions sharing a common upvalue.)<br><br><br></p><p><br>To manipulate the “environment” of a userdata<br>(which is now called user value),<br>use the new functions<br><a href="#lua_getuservalue"><code>lua_getuservalue</code></a> and <a href="#lua_setuservalue"><code>lua_setuservalue</code></a>.<br></p></li><br><br><li><br>Lua identifiers cannot use locale-dependent letters.<br></li><br><br><li><br>Doing a step or a full collection in the garbage collector<br>does not restart the collector if it has been stopped.<br></li><br><br><li><br>Weak tables with weak keys now perform like <em>ephemeron tables</em>.<br></li><br><br><li><br>The event <em>tail return</em> in debug hooks was removed.<br>Instead, tail calls generate a special new event,<br><em>tail call</em>, so that the debugger can know that<br>there will not be a corresponding return event.<br></li><br><br><li><br>Equality between function values has changed.<br>Now, a function definition may not create a new value;<br>it may reuse some previous value if there is no<br>observable difference to the new function.<br></li><br><br></ul><br><br><br><br><br><h2>8.2 – <a name="8.2">Changes in the Libraries</a></h2><br><ul><br><br><li><br>Function <code>module</code> is deprecated.<br>It is easy to set up a module with regular Lua code.<br>Modules are not expected to set global variables.<br></li><br><br><li><br>Functions <code>setfenv</code> and <code>getfenv</code> were removed,<br>because of the changes in environments.<br></li><br><br><li><br>Function <code>math.log10</code> is deprecated.<br>Use <a href="#pdf-math.log"><code>math.log</code></a> with 10 as its second argument, instead.<br></li><br><br><li><br>Function <code>loadstring</code> is deprecated.<br>Use <code>load</code> instead; it now accepts string arguments<br>and are exactly equivalent to <code>loadstring</code>.<br></li><br><br><li><br>Function <code>table.maxn</code> is deprecated.<br>Write it in Lua if you really need it.<br></li><br><br><li><br>Function <code>os.execute</code> now returns <b>true</b> when command<br>terminates successfully and <b>nil</b> plus error information<br>otherwise.<br></li><br><br><li><br>Function <code>unpack</code> was moved into the table library<br>and therefore must be called as <a href="#pdf-table.unpack"><code>table.unpack</code></a>.<br></li><br><br><li><br>Character class <code>%z</code> in patterns is deprecated,<br>as now patterns may contain ‘<code>\0</code>‘ as a regular character.<br></li><br><br><li><br>The table <code>package.loaders</code> was renamed <code>package.searchers</code>.<br></li><br><br><li><br>Lua does not have bytecode verification anymore.<br>So, all functions that load code<br>(<a href="#pdf-load"><code>load</code></a> and <a href="#pdf-loadfile"><code>loadfile</code></a>)<br>are potentially insecure when loading untrusted binary data.<br>(Actually, those functions were already insecure because<br>of flaws in the verification algorithm.)<br>When in doubt,<br>use the <code>mode</code> argument of those functions<br>to restrict them to loading textual chunks.<br></li><br><br><li><br>The standard paths in the official distribution may<br>change between versions.<br></li><br><br></ul><br><br><br><br><br><h2>8.3 – <a name="8.3">Changes in the API</a></h2><br><ul><br><br><li><br>Pseudoindex <code>LUA_GLOBALSINDEX</code> was removed.<br>You must get the global environment from the registry<br>(see <a href="#4.5">§4.5</a>).<br></li><br><br><li><br>Pseudoindex <code>LUA_ENVIRONINDEX</code><br>and functions <code>lua_getfenv</code>/<code>lua_setfenv</code><br>were removed,<br>as C&nbsp;functions no longer have environments.<br></li><br><br><li><br>Function <code>luaL_register</code> is deprecated.<br>Use <a href="#luaL_setfuncs"><code>luaL_setfuncs</code></a> so that your module does not create globals.<br>(Modules are not expected to set global variables anymore.)<br></li><br><br><li><br>The <code>osize</code> argument to the allocation function<br>may not be zero when creating a new block,<br>that is, when <code>ptr</code> is <code>NULL</code><br>(see <a href="#lua_Alloc"><code>lua_Alloc</code></a>).<br>Use only the test <code>ptr == NULL</code> to check whether<br>the block is new.<br></li><br><br><li><br>Finalizers (<code>gc</code> metamethods) for userdata are called in the<br>reverse order that they were marked for finalization,<br>not that they were created (see <a href="#2.5.1">§2.5.1</a>).<br>(Most userdata are marked immediately after they are created.)<br>Moreover,<br>if the metatable does not have a <code>__gc</code> field when set,<br>the finalizer will not be called,<br>even if it is set later.<br></li><br><br><li><br><code>luaL_typerror</code> was removed.<br>Write your own version if you need it.<br></li><br><br><li><br>Function <code>lua_cpcall</code> is deprecated.<br>You can simply push the function with <a href="#lua_pushcfunction"><code>lua_pushcfunction</code></a><br>and call it with <a href="#lua_pcall"><code>lua_pcall</code></a>.<br></li><br><br><li><br>Functions <code>lua_equal</code> and <code>lua_lessthan</code> are deprecated.<br>Use the new <a href="#lua_compare"><code>lua_compare</code></a> with appropriate options instead.<br></li><br><br><li><br>Function <code>lua_objlen</code> was renamed <a href="#lua_rawlen"><code>lua_rawlen</code></a>.<br></li><br><br><li><br>Function <a href="#lua_load"><code>lua_load</code></a> has an extra parameter, <code>mode</code>.<br>Pass <code>NULL</code> to simulate the old behavior.<br></li><br><br><li><br>Function <a href="#lua_resume"><code>lua_resume</code></a> has an extra parameter, <code>from</code>.<br>Pass <code>NULL</code> or the thread doing the call.<br></li><br><br></ul><br><br><br><br><br><h1>9 – <a name="9">The Complete Syntax of Lua</a></h1><br><br><p><br>Here is the complete syntax of Lua in extended BNF.<br>(It does not describe operator precedences.)<br><br><br><br><br></p><pre><br>    chunk ::= block<br><br>    block ::= {stat} [retstat]<br><br>    stat ::=  ‘<b>;</b>’ |<br>         varlist ‘<b>=</b>’ explist |<br>         functioncall |<br>         label |<br>         <b>break</b> |<br>         <b>goto</b> Name |<br>         <b>do</b> block <b>end</b> |<br>         <b>while</b> exp <b>do</b> block <b>end</b> |<br>         <b>repeat</b> block <b>until</b> exp |<br>         <b>if</b> exp <b>then</b> block {<b>elseif</b> exp <b>then</b> block} [<b>else</b> block] <b>end</b> |<br>         <b>for</b> Name ‘<b>=</b>’ exp ‘<b>,</b>’ exp [‘<b>,</b>’ exp] <b>do</b> block <b>end</b> |<br>         <b>for</b> namelist <b>in</b> explist <b>do</b> block <b>end</b> |<br>         <b>function</b> funcname funcbody |<br>         <b>local</b> <b>function</b> Name funcbody |<br>         <b>local</b> namelist [‘<b>=</b>’ explist]<br><br>    retstat ::= <b>return</b> [explist] [‘<b>;</b>’]<br><br>    label ::= ‘<b>::</b>’ Name ‘<b>::</b>’<br><br>    funcname ::= Name {‘<b>.</b>’ Name} [‘<b>:</b>’ Name]<br><br>    varlist ::= var {‘<b>,</b>’ var}<br><br>    var ::=  Name | prefixexp ‘<b>[</b>’ exp ‘<b>]</b>’ | prefixexp ‘<b>.</b>’ Name<br><br>    namelist ::= Name {‘<b>,</b>’ Name}<br><br>    explist ::= exp {‘<b>,</b>’ exp}<br><br>    exp ::=  <b>nil</b> | <b>false</b> | <b>true</b> | Number | String | ‘<b>…</b>’ | functiondef |<br>         prefixexp | tableconstructor | exp binop exp | unop exp<br><br>    prefixexp ::= var | functioncall | ‘<b>(</b>’ exp ‘<b>)</b>’<br><br>    functioncall ::=  prefixexp args | prefixexp ‘<b>:</b>’ Name args<br><br>    args ::=  ‘<b>(</b>’ [explist] ‘<b>)</b>’ | tableconstructor | String<br><br>    functiondef ::= <b>function</b> funcbody<br><br>    funcbody ::= ‘<b>(</b>’ [parlist] ‘<b>)</b>’ block <b>end</b><br><br>    parlist ::= namelist [‘<b>,</b>’ ‘<b>…</b>’] | ‘<b>…</b>’<br><br>    tableconstructor ::= ‘<b>{</b>’ [fieldlist] ‘<b>}</b>’<br><br>    fieldlist ::= field {fieldsep field} [fieldsep]<br><br>    field ::= ‘<b>[</b>’ exp ‘<b>]</b>’ ‘<b>=</b>’ exp | Name ‘<b>=</b>’ exp | exp<br><br>    fieldsep ::= ‘<b>,</b>’ | ‘<b>;</b>’<br><br>    binop ::= ‘<b>+</b>’ | ‘<b>-</b>’ | ‘<b></b>’ | ‘<b>/</b>’ | ‘<b>^</b>’ | ‘<b>%</b>’ | ‘<b>..</b>’ |<br>         ‘<b>&lt;</b>’ | ‘<b>&lt;=</b>’ | ‘<b>&gt;</b>’ | ‘<b>&gt;=</b>’ | ‘<b>==</b>’ | ‘<b>~=</b>’ |<br>         <b>and</b> | <b>or</b><br><br>    unop ::= ‘<b>-</b>’ | <b>not</b> | ‘<b>#</b>’<br><br></pre><br><br><p><br></p><hr><br><small class="footer"><br>Last update:<br>Thu Mar 21 13:01:53 BRT 2013<br></small><br><p><br></p><hr><br><small class="footer"><br>中文版最近更新:<br>2013-08-12 13:04<br></small><br><!--
Last change: revised for Lua 5.2.2
--><br><br><br><br></body></html>
</div><script type="text/javascript" src="/js/share.js?v=0.0.0" async></script><a data-url="https://kanmars.github.io/2015/01/04/2015-01-04-lua/" data-id="ciwjetzl3008048vqq2oezdvz" class="article-share-link">Aktie</a><div class="tags"><a href="/tags/it/">it</a><a href="/tags/server/">server</a></div><div class="post-nav"><a href="/2015/02/15/2015-02-15-dianfeng/" class="pre">技术的巅峰</a><a href="/2014/11/28/2014-11-28-Linux_LVM/" class="next">[KANMARS原创] - 逻辑卷管理器LVM</a></div><div data-thread-key="2015/01/04/2015-01-04-lua/" data-title="lua使用手册" data-url="https://kanmars.github.io/2015/01/04/2015-01-04-lua/" class="ds-share flat"><div class="ds-share-inline"><ul class="ds-share-icons-16"><li data-toggle="ds-share-icons-more"><a href="javascript:void(0);" class="ds-more">分享到：</a></li><li><a href="javascript:void(0);" data-service="weibo" class="ds-weibo">微博</a></li><li><a href="javascript:void(0);" data-service="qzone" class="ds-qzone">QQ空间</a></li><li><a href="javascript:void(0);" data-service="qqt" class="ds-qqt">腾讯微博</a></li><li><a href="javascript:void(0);" data-service="wechat" class="ds-wechat">微信</a></li></ul><div class="ds-share-icons-more"></div></div></div><div data-thread-key="2015/01/04/2015-01-04-lua/" data-title="lua使用手册" data-url="https://kanmars.github.io/2015/01/04/2015-01-04-lua/" data-author-key="1" class="ds-thread"></div></div></div></div><div class="pure-u-1-4 hidden_mid_and_down"><div id="sidebar"><div class="widget"><form action="//www.baidu.com/baidu" method="get" accept-charset="utf-8" target="_blank" class="search-form"><input type="search" name="word" maxlength="20" placeholder="Search"/><input type="hidden" name="si" value="https://kanmars.github.io"/><input name="tn" type="hidden" value="bds"/><input name="cl" type="hidden" value="3"/><input name="ct" type="hidden" value="2097152"/><input name="s" type="hidden" value="on"/></form></div><div class="widget"><div class="widget-title"><i class="fa fa-folder-o"> Kategorien</i></div></div><div class="widget"><div class="widget-title"><i class="fa fa-star-o"> Tags</i></div><div class="tagcloud"><a href="/tags/jetty/" style="font-size: 15px;">jetty</a> <a href="/tags/it/" style="font-size: 15px;">it</a> <a href="/tags/architecture/" style="font-size: 15px;">architecture</a> <a href="/tags/itlife/" style="font-size: 15px;">itlife</a> <a href="/tags/rsa/" style="font-size: 15px;">rsa</a> <a href="/tags/tb/" style="font-size: 15px;">tb</a> <a href="/tags/drawline/" style="font-size: 15px;">drawline</a> <a href="/tags/life/" style="font-size: 15px;">life</a> <a href="/tags/strategy/" style="font-size: 15px;">strategy</a> <a href="/tags/tblife/" style="font-size: 15px;">tblife</a> <a href="/tags/java/" style="font-size: 15px;">java</a> <a href="/tags/linux/" style="font-size: 15px;">linux</a> <a href="/tags/spring/" style="font-size: 15px;">spring</a> <a href="/tags/server/" style="font-size: 15px;">server</a> <a href="/tags/c/" style="font-size: 15px;">c</a> <a href="/tags/c/" style="font-size: 15px;">c++</a> <a href="/tags/lua/" style="font-size: 15px;">lua</a> <a href="/tags/android/" style="font-size: 15px;">android</a> <a href="/tags/javascript/" style="font-size: 15px;">javascript</a> <a href="/tags/neuralnetwork/" style="font-size: 15px;">neuralnetwork</a> <a href="/tags/cpu/" style="font-size: 15px;">cpu</a> <a href="/tags/disk/" style="font-size: 15px;">disk</a> <a href="/tags/fidsk/" style="font-size: 15px;">fidsk</a> <a href="/tags/fstab/" style="font-size: 15px;">fstab</a> <a href="/tags/lvm/" style="font-size: 15px;">lvm</a> <a href="/tags/aix/" style="font-size: 15px;">aix</a></div></div><div class="widget"><div class="widget-title"><i class="fa fa-file-o"> Letzte</i></div><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/2016/11/18/2016-11-18-springmvc_source_004_viewresolver/">[KANMARS原创]-SpringMVC源码解析(4) - 视图处理器</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/11/18/2016-11-18-springmvc_source_003_requestprocess/">[KANMARS原创]-SpringMVC源码解析(3) - 请求处理过程</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/11/17/2016-11-17-springmvc_source_002_start/">[KANMARS原创]-SpringMVC源码解析(2) - 启动过程</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/11/17/2016-11-17-springmvc_source_001_introduce/">[KANMARS原创]-SpringMVC源码解析(1) - 简介</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/11/04/2016-11-04-SomeThingAndNothing/">SomeThingAndNothing</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/10/25/2016-10-25-news-LongRoad/">news It's a Long Road</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/10/19/2016-10-19-Scale-Services/">On Designing and Deploying Internet-Scale Services</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/10/18/2016-10-18-dubbo_source_006_summarize/">[KANMARS原创]-DUBBO源码解析(6)-summarize</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/10/18/2016-10-18-dubbo_source_005_consumerCall/">[KANMARS原创]-DUBBO源码解析(5)-consumerCall</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/09/19/2016-09-08-dubbo_source_004_referenceBean/">[KANMARS原创]-DUBBO源码解析(4)-referenceBean</a></li></ul></div><div class="widget"><div class="comments-title"><i class="fa fa-comment-o"> Letzte Kommentare</i></div><div data-num-items="5" data-show-avatars="0" data-show-time="1" data-show-admin="0" data-excerpt-length="32" data-show-title="1" class="ds-recent-comments"></div></div><div class="widget"><div class="widget-title"><i class="fa fa-external-link"> Blogroll</i></div><ul></ul><a href="http://www.linux.cn" title="Linux-CN" target="_blank">Linux-CN</a><ul></ul><a href="http://www.gome.com.cn" title="国美互联网" target="_blank">国美互联网</a><ul></ul><a href="http://jr.gome.com.cn" title="国美金融" target="_blank">国美金融</a></div></div></div><div class="pure-u-1 pure-u-md-3-4"><div id="footer">© <a href="/." rel="nofollow">KANMARS的博客.</a> Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a><a rel="nofollow" target="_blank" href="https://github.com/tufu9441/maupassant-hexo"> Theme</a> by<a rel="nofollow" target="_blank" href="https://github.com/pagecho"> Cho.</a></div></div></div><a id="rocket" href="#top" class="show"></a><script type="text/javascript" src="/js/totop.js?v=0.0.0" async></script><script type="text/javascript" src="//cdn.bootcss.com/fancybox/2.1.5/jquery.fancybox.pack.js" async></script><script type="text/javascript" src="/js/fancybox.js?v=0.0.0" async></script><link rel="stylesheet" type="text/css" href="/css/jquery.fancybox.css?v=0.0.0"><script>var duoshuoQuery = {short_name:'kanmars'};
(function() {
    var ds = document.createElement('script');
    ds.type = 'text/javascript';ds.async = true;
    ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
    ds.charset = 'UTF-8';
    (document.getElementsByTagName('head')[0]
        || document.getElementsByTagName('body')[0]).appendChild(ds);
})();
</script><script type="text/javascript" src="/js/codeblock-resizer.js?v=0.0.0"></script><script type="text/javascript" src="/js/smartresize.js?v=0.0.0"></script></div></body></html>