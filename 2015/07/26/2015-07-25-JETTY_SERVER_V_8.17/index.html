<!DOCTYPE html><html lang="null"><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description"><title>[KANMARS原创] - JETTY服务器源码全解析：从Jetty的组件结构，到Jetty是如何运行的 | KANMARS的博客</title><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/normalize/5.0.0/normalize.min.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/pure/0.6.0/pure-min.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/pure/0.6.0/grids-responsive-min.css"><link rel="stylesheet" type="text/css" href="/css/style.css?v=0.0.0"><link rel="stylesheet" href="//cdn.bootcss.com/font-awesome/4.7.0/css/font-awesome.min.css"><script type="text/javascript" src="//cdn.bootcss.com/jquery/3.1.1/jquery.min.js"></script><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">[KANMARS原创] - JETTY服务器源码全解析：从Jetty的组件结构，到Jetty是如何运行的</h1><a id="logo" href="/.">KANMARS的博客</a><p class="description">helloword 2046。趁着，我会喜怒你会哀乐，唱几分钟情歌。</p></div><div id="nav-menu"><a href="/." class="current"><i class="fa fa-home"> Start</i></a><a href="/archives/"><i class="fa fa-archive"> Archiv</i></a><a href="/2016/04/23/2016-04-23-mysongs/"><i class="fa fa-user"> Über</i></a></div></div><div id="layout" class="pure-g"><div class="pure-u-1 pure-u-md-3-4"><div class="content_container"><div class="post"><h1 class="post-title">[KANMARS原创] - JETTY服务器源码全解析：从Jetty的组件结构，到Jetty是如何运行的</h1><div class="post-meta">Jul 26, 2015</div><a data-thread-key="2015/07/26/2015-07-25-JETTY_SERVER_V_8.17/" href="/2015/07/26/2015-07-25-JETTY_SERVER_V_8.17/#comments" class="ds-thread-count"></a><div class="post-content"><p><br>&nbsp;<br></p><br><p><br>    今天学习了一下Jetty的代码，版本为V8.1.17.v20150415<br></p><br><p><br>    做个笔记，以防忘记<br></p><br><p><br>    比较专业的jetty架构解析，可以参考如下链接<br></p><br><p><br>    <a href="http://my.oschina.net/tryUcatchUfinallyU/blog?disp=1&amp;catalog=300813&amp;sort=time&amp;p=2" target="_blank" rel="external">http://my.oschina.net/tryUcatchUfinallyU/blog?disp=1&amp;catalog=300813&amp;sort=time&amp;p=2</a><br></p><br><p><br>    <a href="http://www.ibm.com/developerworks/cn/web/wa-lo-jetty/" target="_blank" rel="external">http://www.ibm.com/developerworks/cn/web/wa-lo-jetty/</a><br></p><br><p><br>    <a href="http://ipjmc.iteye.com/blog/1839999" target="_blank" rel="external">http://ipjmc.iteye.com/blog/1839999</a><br></p><br><p><br>    <a href="http://www.blogjava.net/DLevin/archive/2014/05/07/413158.html" target="_blank" rel="external">http://www.blogjava.net/DLevin/archive/2014/05/07/413158.html</a><br></p><br><p><br>    最好看完这11+1+1+1篇文章之后再看我写的以下内容，否则容易急功近利……<br></p><br><p><br>    <br><br></p><br><p><br>    ——————————————————————————————————————————————————————————————<br></p><br><p><br>    ——————————————————————————<span style="background-color:#000000;color:#E53333;">伟大的分割线</span>——————————————————————————————<br></p><br><p><br>    ——————————————————————————————————————————————————————————————<br></p><br><p><br>    <br><br></p><br><p><br>    jetty的架构为基于LifyCycle的架构，每个组件都实现了该接口，具有LifyCyle的生命周期<br></p><br><p><br>    public interface LifeCycle{<br><br>&nbsp;&nbsp;&nbsp; public void start() throws Exception;<br><br>&nbsp;&nbsp;&nbsp; public void stop() throws Exception;<br><br>&nbsp;&nbsp;&nbsp; public boolean isRunning();<br><br>&nbsp;&nbsp;&nbsp; public boolean isStarted();<br><br>&nbsp;&nbsp;&nbsp; public boolean isStarting();<br><br>&nbsp;&nbsp;&nbsp; public boolean isStopping();<br><br>&nbsp;&nbsp;&nbsp; public boolean isStopped();<br><br>&nbsp;&nbsp;&nbsp; public boolean isFailed();<br><br>&nbsp;&nbsp;&nbsp; public void addLifeCycleListener(LifeCycle.Listener listener);<br><br>&nbsp;&nbsp;&nbsp; public void removeLifeCycleListener(LifeCycle.Listener listener);<br><br>&nbsp;&nbsp;&nbsp; public interface Listener extends EventListener<br><br>&nbsp;&nbsp;&nbsp; {<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; public void lifeCycleStarting(LifeCycle event);<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; public void lifeCycleStarted(LifeCycle event);<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; public void lifeCycleFailure(LifeCycle event,Throwable cause);<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; public void lifeCycleStopping(LifeCycle event);<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; public void lifeCycleStopped(LifeCycle event);<br><br>&nbsp;&nbsp;&nbsp; }<br><br>}<br></p><br><p><br>    通过实现该接口，一个Class类就具有了生命周期，可以作为Jetty的组件来管理<br></p><br><p><br>    ——————————————————————————————————————————————————————————————<br></p><br><p><br>    ——————————————————————————<span style="background-color:#000000;color:#E53333;">伟大的分割线</span>——————————————————————————————<br></p><br><p><br>    ——————————————————————————————————————————————————————————————<br></p><br><p><br>    我们看一段简单的代码，这段代码实现了一个简单的web服务器<br></p><br><p><br>    ——————-pom.xml<br></p><br><p><br>    &lt;dependencies&gt;<br><br>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&lt;dependency&gt;<br><br>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&lt;groupId&gt;org.eclipse.jetty&lt;/groupId&gt;<br><br>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&lt;artifactId&gt;jetty-server&lt;/artifactId&gt;<br><br>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&lt;version&gt;8.1.17.v20150415&lt;/version&gt;<br><br>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&lt;/dependency&gt;<br><br>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&lt;dependency&gt;<br><br>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&lt;groupId&gt;org.eclipse.jetty&lt;/groupId&gt;<br><br>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&lt;artifactId&gt;jetty-webapp&lt;/artifactId&gt;<br><br>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&lt;version&gt;8.1.17.v20150415&lt;/version&gt;<br><br>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&lt;/dependency&gt;<br><br>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&lt;dependency&gt;<br><br>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&lt;groupId&gt;org.eclipse.jetty&lt;/groupId&gt;<br><br>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&lt;artifactId&gt;jetty-servlet&lt;/artifactId&gt;<br><br>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&lt;version&gt;8.1.17.v20150415&lt;/version&gt;<br><br>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&lt;/dependency&gt;<br><br>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&lt;dependency&gt;<br><br>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&lt;groupId&gt;org.eclipse.jetty&lt;/groupId&gt;<br><br>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&lt;artifactId&gt;jetty-jsp&lt;/artifactId&gt;<br><br>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&lt;version&gt;8.1.17.v20150415&lt;/version&gt;<br><br>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&lt;/dependency&gt;<br><br>&nbsp;&nbsp; &nbsp;&lt;/dependencies&gt;<br></p><br><p><br>    ——————————main方法<br></p><br><p><br>    public static void main(String[] args) throws Exception {<br><br>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;Server server = new Server();<br><br>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;QueuedThreadPool threadPool = new QueuedThreadPool();<br><br>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;threadPool.setMinThreads(10);<br><br>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;threadPool.setMaxThreads(100);<br><br>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;threadPool.setDetailedDump(false);<br><br>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;server.setThreadPool(threadPool);<br><br>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;<br><br>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;<br><br>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;SelectChannelConnector selectChannelConnector = new SelectChannelConnector();<br><br>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;selectChannelConnector.setHost(“0.0.0.0”);<br><br>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;selectChannelConnector.setPort(8080);<br><br>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;selectChannelConnector.setMaxIdleTime(3000000);<br><br>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;selectChannelConnector.setAcceptors(2);<br><br>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;selectChannelConnector.setStatsOn(false);<br><br>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;selectChannelConnector.setConfidentialPort(8443);<br><br>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;selectChannelConnector.setLowResourcesConnections(20000);<br><br>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;selectChannelConnector.setLowResourceMaxIdleTime(5000);<br><br>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;<br><br>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;server.addConnector(selectChannelConnector);<br><br>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;<br><br>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;<br><br>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;WebAppContext webAppContext = new WebAppContext();<br><br>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;webAppContext.setContextPath(“/“);<br><br>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;webAppContext.setWar(“E:/workspace/workspace-jetty/webapp/target/webapp.war”);<br><br>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;server.setHandler(webAppContext);<br><br>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;server.start();<br><br>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;server.join();<br><br>&nbsp;&nbsp; &nbsp;}<br></p><br><p><br>    以上代码即为：把webapp.war作为一个服务发布出去。<br></p><br><p><br>    <br><br></p><br><p><br>    ——————————————————————————————————————————————————————————————<br></p><br><p><br>    ———————————————————————-<span style="background-color:#000000;color:#E53333;">Jetty服务器的组成结构</span>————————————————————————————-<br></p><br>——————————————————————————————————————————————————————————————<br><p><br>    <br><br></p><br><p><br>    首先我们来分析jetty的组成结构<br></p><br><p><br>    &nbsp;&nbsp;&nbsp; 如上一个main方法示例所示：一个jetty服务器由以下四部分组成：<br></p><br><p><br>    &nbsp;&nbsp;&nbsp; <span style="background-color:#000000;color:#E53333;">Connector</span>&nbsp;&nbsp;&nbsp; ———–&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <span style="background-color:#000000;color:#E53333;">Server</span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ———–&nbsp;&nbsp;&nbsp;&nbsp; <span style="background-color:#000000;color:#E53333;">ThreadPool</span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ———-&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <span style="background-color:#000000;color:#E53333;">Handler</span><br></p><br><p><br>    &nbsp;&nbsp;&nbsp; 从Jetty发布包中的etc/jetty.xml中你可以清楚的看到对应配置&nbsp;&nbsp;&nbsp;<br></p><br><p><br>    &nbsp;&nbsp;&nbsp; 如果想启动一个jetty服务器这四个组件必不可少<br></p><br><p><br>    &nbsp;&nbsp;&nbsp; 如果要想明确一下这四种组件的具体作用，可以大致定义如下：<br></p><br><p><br>    &nbsp;&nbsp;&nbsp; <span style="background-color:#FFE500;">1、Connector</span>：常用的是SelectChannelConnector，<br></p><br><p><br>    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 重要变量如下：<br></p><br><p><br>    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;private final SelectorManager _manager = new ConnectorSelectorManager();&nbsp;&nbsp;&nbsp; –连接选择管理器<br></p><br><p><br>    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 重要方法如下：<br></p><br><p><br>    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;open&nbsp;&nbsp;&nbsp; 打开一个新的SocketChannel通道<br></p><br><p><br>    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;accept&nbsp;&nbsp;&nbsp; 尝试accept一个连接，如果发生连接，则将连接注册到SelectorManager中<br></p><br><p><br>    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;newConnection&nbsp;&nbsp;&nbsp; 新建一个AsyncHttpConnection<br></p><br><p><br>    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;newEndPoint&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 新建一个SelectChannelEndPoint&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br></p><br><p><br>    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;doStart&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 组件启动方法<br></p><br><p><br>    &nbsp;&nbsp;&nbsp; <span style="background-color:#FFE500;">2、Server</span>：Jetty启动类<br></p><br><p><br>    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 重要变量如下：<br></p><br><p><br>    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;private final Container _container=new Container();&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 组件容器<br></p><br><p><br>    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;private ThreadPool _threadPool;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 线程池<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;private Connector[] _connectors;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 连接<br></p><br><p><br>    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 重要方法如下：<br></p><br><p><br>    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;doStart&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 组件启动方法<br></p><br><p><br>    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; doStop&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 组件停止方法<br></p><br><p><br>    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; start&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 继承自AbstractLifeCycle的启动方法<br></p><br><p><br>    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; stop&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;继承自AbstractLifeCycle的停止方法<br></p><br><p><br>    &nbsp;&nbsp;&nbsp; <span style="background-color:#FFE500;">3、ThreadPool</span>：Jetty线程池,常用实现类为QueuedThreadPool<br></p><br><p><br>    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 重要变量如下：<br></p><br><p><br>    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;private final ConcurrentLinkedQueue&lt;Thread&gt; _threads=new ConcurrentLinkedQueue&lt;Thread&gt;();&nbsp;&nbsp;&nbsp; 可用线程<br></p><br><p><br>    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;private BlockingQueue&lt;Runnable&gt; _jobs;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 需要执行的任务<br></p><br><p><br>    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;private Runnable _runnable = new Runnable()……&nbsp;&nbsp;&nbsp; 默认启动任务：从_jobs中poll出一个任务并执行<br></p><br><p><br>    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 重要方法如下<br></p><br><p><br>    <br><br></p><br><p><br>    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;doStart&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 组件启动方法<br></p><br><p><br>    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; doStop&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 组件停止方法<br></p><br><p><br>    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; dispatch&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 将job任务增加到执行队列_jobs等待执行<br></p><br><p><br>    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;startThread&nbsp;&nbsp;&nbsp; 在调用doStart时触发，启动_minThreads指定个数的“默认线程”_runnable默认任务<br></p><br><p><br>    &nbsp;&nbsp;&nbsp; <span style="background-color:#FFE500;">4、Handler</span>：即处理器，Jetty使用了Handler处理器的架构<br></p><br><p><br>    &nbsp;&nbsp;&nbsp;&nbsp;参见<a href="http://my.oschina.net/tryUcatchUfinallyU/blog/110553" target="_blank" rel="external">http://my.oschina.net/tryUcatchUfinallyU/blog/110553</a><br></p><br><p><br>    &nbsp;&nbsp;&nbsp;<em>&nbsp;</em><em>从设计模板角度来看 Handler 的设计实际上就是一个责任链模式，接口类 HandlerCollection<br>可以帮助开发者构建一个链，而另一个接口类 ScopeHandler<br>可以帮助你控制这个链的访问顺序。另外一个用到的设计模板就是观察者模式，用这个设计模式控制了整个 Jetty 的生命周期，只要继承了<br>LifeCycle 接口，你的对象就可以交给 Jetty 来统一管理了。所以扩展 Jetty<br>非常简单，也很容易让人理解，整体架构上的简单也带来了无比的好处，Jetty 可以很容易被扩展和裁剪。</em><br></p><br><p><br>    <br><br></p><br><p><br>    &nbsp;&nbsp;&nbsp; Handler的接口如下：<br></p><br><blockquote><br>    <blockquote><br>        <blockquote><br>            <p><br>                public interface Handler extends LifeCycle, Destroyable{<br><br>&nbsp;&nbsp;&nbsp; public void handle(String target, Request baseRequest, HttpServletRequest request, HttpServletResponse response)<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; throws IOException, ServletException;<br><br>&nbsp;&nbsp;&nbsp; public void setServer(Server server);<br><br>&nbsp;&nbsp;&nbsp; public Server getServer();<br><br>&nbsp;&nbsp;&nbsp; public void destroy();<br><br>}<br>            </p><br>        </blockquote><br>    </blockquote><br></blockquote><br><p><br>    &nbsp;&nbsp;&nbsp; HandlerContainer接口如下：<br></p><br><blockquote><br>    <blockquote><br>        <blockquote><br>            <p><br>                public interface HandlerContainer extends LifeCycle{<br><br>&nbsp;&nbsp;&nbsp; public Handler[] getHandlers();<br><br>&nbsp;&nbsp;&nbsp; public Handler[] getChildHandlers();<br><br>&nbsp;&nbsp;&nbsp; public Handler[] getChildHandlersByClass(Class&lt;?&gt; byclass);<br><br>&nbsp;&nbsp;&nbsp; public &lt;T extends Handler&gt; T getChildHandlerByClass(Class&lt;T&gt; byclass);<br><br>}<br>            </p><br>        </blockquote><br>    </blockquote><br></blockquote><br><p><br>    &nbsp;&nbsp;&nbsp; 由代码可知：Handler的作用就是，对Request和Response对象进行处理，使之完成相应的功能。<br></p><br><p><br>    <br><br></p><br><p><br>    &nbsp;&nbsp;&nbsp; 示例中的Handler是WebAppContext，此外，Handler还可以是HandlerList和HandlerCollection，其区别在于HandlerList在责任链模式下，如果一个请求被标记为已处理过或者已经报异常，则不会继续处理；而HandlerCollection无论什么情况，会执行所有的Handler。<br></p><br><p><br>    &nbsp;&nbsp;&nbsp; 对WebAppContext的分析需要较大篇幅，本文不予分析。<br></p><br><p><br>    <br><br></p><br><p><br>    ——————————————————————————————————————————————————————————————<br></p><br><p><br>    ———————————————————————-<span style="background-color:#000000;color:#E53333;">Jetty服务器的启动顺序</span>————————————————————————————-<br></p><br>——————————————————————————————————————————————————————————————<br><p><br>    <br><br></p><br><p><br>    接下来我们来分析Jetty的启动顺序，网上的流程图很多，凑巧我的编辑器不能画图，所以我将启动顺序用写的方式写出来。<br></p><br><p><br>    1、new Server()<br></p><br><p><br>    &nbsp;&nbsp;&nbsp; 1.1&nbsp;&nbsp;&nbsp; 初始化server对象<br></p><br><p><br>    &nbsp;&nbsp;&nbsp; 1.2&nbsp;&nbsp;&nbsp; 初始化Container容器<br></p><br><p><br>    2、new QueuedThreadPool()<br></p><br><p><br>    &nbsp;&nbsp;&nbsp; 2.1&nbsp;&nbsp;&nbsp; 初始化_threads线程队列<br></p><br><p><br>    3、server.setThreadPool(threadPool);&nbsp;&nbsp;&nbsp; 对服务器设置线程池<br></p><br><p><br>    &nbsp;&nbsp;&nbsp; 3.1&nbsp;&nbsp;&nbsp; 调用server的祖宗类AggregateLifeCycle.addBean方法，将bean注册入_beans<br></p><br><p><br>    &nbsp;&nbsp;&nbsp; 3.2&nbsp;&nbsp;&nbsp;&nbsp;_container.addBean(threadPool)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ——————–JettyV8.17版本似乎有BUG？此处代码会判断_listeners为0时不能加入对象，类似“空腹吃饭有害健康”的笑话。<br></p><br><p><br>    4、new SelectChannelConnector()&nbsp;&nbsp;&nbsp; 新建一个ChannelConnector<br></p><br><p><br>    &nbsp;&nbsp;&nbsp; 4.1&nbsp;&nbsp;&nbsp; 初始化&nbsp;&nbsp;&nbsp;&nbsp;private final SelectorManager _manager = new ConnectorSelectorManager();&nbsp;&nbsp;&nbsp;&nbsp;<br></p><br><p><br>    &nbsp;&nbsp;&nbsp; 4.2&nbsp;&nbsp;&nbsp; 调用addBean方法将_manager注册到SelectChannelConnector的祖宗类AggregateLifeCycle._beans中<br></p><br><p><br>    &nbsp;&nbsp;&nbsp; 4.3 &nbsp;&nbsp; 设置&nbsp; int&nbsp; _acceptors&nbsp;&nbsp;&nbsp; 根据(Runtime.getRuntime().availableProcessors+3)/4设置_acceptor的数量<br></p><br><p><br>    5、server.addConnector(selectChannelConnector);&nbsp;&nbsp;&nbsp; 对服务器增加Connector<br></p><br><p><br>    &nbsp;&nbsp;&nbsp; 5.1&nbsp;&nbsp;&nbsp; 更新server._connectors&nbsp;&nbsp;&nbsp; 数组对象为新的connector数组<br></p><br><p><br>    6、new WebAppContext()&nbsp;&nbsp;&nbsp; 新建Handler&nbsp;&nbsp;&nbsp; 比较复杂，不在此说明<br></p><br><p><br>    <br><br></p><br><p><br>    7、server.setHandler(webAppContext);&nbsp;&nbsp;&nbsp;&nbsp;<br></p><br><p><br>    &nbsp;&nbsp;&nbsp; 7.1&nbsp;&nbsp;&nbsp;&nbsp;_handler=handler赋值为hander<br></p><br><p><br>    &nbsp;&nbsp;&nbsp; 7.2 &nbsp;&nbsp; handler.setServer(getServer());&nbsp;&nbsp;&nbsp; 建立server和handler的连接关系<br></p><br><p><br>    8、server.start();启动Jetty服务器<br></p><br><p><br>    &nbsp;&nbsp;&nbsp; 8.1&nbsp;&nbsp;&nbsp; server调用继承自AbstractLifeCycle的start方法<br></p><br><p><br>    &nbsp;&nbsp;&nbsp; 8.1.1&nbsp;&nbsp;&nbsp; server调用继承自AbstractLifeCycle的setStarting()方法<br></p><br><p><br>    &nbsp;&nbsp;&nbsp; 8.1.2&nbsp;&nbsp;&nbsp;&nbsp;server调用自身实现的抽象方法dostart<br></p><br><p><br>    &nbsp;&nbsp;&nbsp; 8.1.2.1&nbsp;&nbsp;&nbsp; server.dostart方法中ShutdownMonitor.getInstance().start()启动停机监控<br></p><br><p><br>    &nbsp;&nbsp;&nbsp; 8.1.2.2&nbsp;&nbsp;&nbsp; server.dostart方法中HttpGenerator设置服务器版本号8.1.17.v20150415<br></p><br><p><br>    &nbsp;&nbsp;&nbsp; 8.1.2.3&nbsp;&nbsp;&nbsp;&nbsp;server.dostart方法中super.doStart();<br></p><br><p><br>    &nbsp;&nbsp;&nbsp; 8.1.2.3.1&nbsp;&nbsp;&nbsp; server的父类HandlerWrapper.doStart()，调用父类doStart<br></p><br><p><br>    &nbsp;&nbsp;&nbsp; 8.1.2.3.1.1&nbsp;&nbsp;&nbsp; 如果server的_handler不为空，则执行_handler.start();&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ——————————–<br></p><br><p><br>    &nbsp;&nbsp;&nbsp; 8.1.2.3.1.2&nbsp;&nbsp;&nbsp; 调用server的父类HandlerWrapper的父类AbstractHandler的父类AggregateLifeCycle的doStart方法<br></p><br><p><br>    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 8.1.2.3.1.2.1&nbsp;&nbsp;&nbsp; 循环调用_beans.start()方法-》触发所有通过server.addBean注册到_beans中的组件的继承自LifeCycle的start方法<br></p><br><p><br>    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 8.1.2.3.1.2.2&nbsp;&nbsp;&nbsp; 设置server对象的已启动标志_started为true<br></p><br><p><br>    &nbsp;&nbsp;&nbsp; 8.1.2.3.1.3&nbsp;&nbsp;&nbsp;&nbsp;调用server的父类HandlerWrapper的父类AbstractHandler的父类AggregateLifeCycle的父类AbstractLifeCycle的dostart方法<br></p><br><p><br>    &nbsp;&nbsp;&nbsp; 8.1.2.4&nbsp;&nbsp;&nbsp;&nbsp;server.dostart方法中：由于server.addConnector时，没有addBean，所以在8.1.2.3.1.2.1步骤没有调用connector的start方法<br></p><br><p><br>    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 因此,server.dostart中，循环调用_connectors.start<br></p><br><p><br>    &nbsp;&nbsp;&nbsp; 8.1.3&nbsp;&nbsp;&nbsp;&nbsp;server调用继承自AbstractLifeCycle的setStarted()方法<br><br>&nbsp;&nbsp;&nbsp; 8.2&nbsp;&nbsp;&nbsp; server调用继承自AbstractLifeCycle的start结束<br></p><br><p><br>    9、接步骤8.1.2.3.1.1启动Handler继承自AbstractLifeCycle的start方法<br></p><br><p><br>    10、接步骤8.1.2.3.1.2启动AggregateLifeCycle._beans中注册的LifyCycle<br></p><br><p><br>    &nbsp;&nbsp;&nbsp; 10.1&nbsp;&nbsp;&nbsp; 启动步骤3.1通过server.addBean注册到AggregateLifeCycle._beans中的LifeCycle-&gt;QueuedThreadPool.start<br></p><br><p><br>    &nbsp;&nbsp;&nbsp; 10.1.1&nbsp;&nbsp;&nbsp; 调用_beans.start，即QueuedThreadPool.start<br></p><br><p><br>    &nbsp;&nbsp;&nbsp; 10.1.2&nbsp;&nbsp;&nbsp; QueuedThreadPool调用继承自父类AbstractLifeCycle的start方法<br></p><br><p><br>    &nbsp;&nbsp;&nbsp; 10.1.2.1&nbsp;&nbsp;&nbsp;&nbsp;QueuedThreadPool调用继承自父类AbstractLifeCycle的setStarting方法<br></p><br><p><br>    &nbsp;&nbsp;&nbsp;&nbsp;10.1.2.2 &nbsp;&nbsp; QueuedThreadPool调用自身实现的doStart方法<br></p><br><p><br>    &nbsp;&nbsp;&nbsp; 10.1.2.2.1&nbsp;&nbsp;&nbsp;&nbsp;QueuedThreadPool调用继承自父类AbstractLifeCycle的doStart方法<br></p><br><p><br>    &nbsp;&nbsp;&nbsp; 10.1.2.2.2&nbsp;&nbsp;&nbsp;&nbsp;QueuedThreadPool如果_jobs，任务队列为空，则对任务队列赋初始值ArrayBlockingQueue或者BlockingArrayQueue<br></p><br><p><br>    &nbsp;&nbsp;&nbsp; 10.1.2.2.3&nbsp;&nbsp;&nbsp;&nbsp;QueuedThreadPool调用循环while(isRunning() &amp;&amp; threads&lt;_minThreads)，新建_minThreads<br></p><br><p><br>    &nbsp;&nbsp;&nbsp; 10.1.2.2.3.1&nbsp;&nbsp;&nbsp;&nbsp;QueuedThreadPool循环初始化线程时，调用startThread方法，新建线程<br></p><br><p><br>    &nbsp;&nbsp;&nbsp; 10.1.2.2.3.1.1&nbsp;&nbsp;&nbsp;&nbsp;QueuedThreadPool.startThread调用newThread(_runnable)方法，创建一个实现了_runable接口的线程<br></p><br><p><br>    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 备注：_runable接口功能为为从_jobs中取出一个任务，并且调用该任务的_job.run方法<br></p><br><p><br>    &nbsp;&nbsp;&nbsp; 10.1.2.2.3.1.2&nbsp;&nbsp;&nbsp; 启动新创建的_runable线程<br></p><br><p><br>    &nbsp;&nbsp;&nbsp; 10.1.2.2.4&nbsp;&nbsp;&nbsp;&nbsp;QueuedThreadPool结束调用doStart方法<br></p><br><p><br>    &nbsp;&nbsp;&nbsp; 10.1.2.3 &nbsp;&nbsp; QueuedThreadPool调用继承自父类AbstractLifeCycle的setStarted方法<br></p><br><p><br>    &nbsp;&nbsp;&nbsp; 10.1.3&nbsp;&nbsp;&nbsp;&nbsp;QueuedThreadPool结束调用继承自父类AbstractLifeCycle的start方法<br></p><br><p><br>    11、接步骤8.1.2.4,server.doStart方法中，启动Connector组件，调用try{_connectors[i].start();}<br></p><br><p><br>    &nbsp;&nbsp;&nbsp;&nbsp;（由于_connector没有注册到AggregateLifeCycle._beans中，也有可能是故意为之，使connector最后执行）<br></p><br><p><br>    &nbsp;&nbsp;&nbsp; 11.1&nbsp;&nbsp;&nbsp;&nbsp;SelectChannelConnector调用继承自父类AbstractLifeCycle的start方法<br></p><br><p><br>    &nbsp;&nbsp;&nbsp; 11.1.1&nbsp;&nbsp;&nbsp;&nbsp;SelectChannelConnector调用继承自父类AbstractLifeCycle的setStarting方法<br></p><br><p><br>    &nbsp;&nbsp;&nbsp; 11.1.2&nbsp;&nbsp;&nbsp;&nbsp;SelectChannelConnector调用自身实现的doStart方法<br></p><br><p><br>    &nbsp;&nbsp;&nbsp; 11.1.2.1&nbsp;&nbsp;&nbsp;&nbsp;SelectChannelConnector调用父类AbstractConnector的doStart方法<br></p><br><p><br>    &nbsp;&nbsp;&nbsp; 11.1.2.2&nbsp;&nbsp;&nbsp;&nbsp;SelectChannelConnector调用自身实现的open方法<br></p><br><p><br>    &nbsp;&nbsp;&nbsp; 11.1.2.2.1&nbsp;&nbsp;&nbsp;&nbsp;SelectChannelConnector初始化ServerSocketChannel _acceptChannel;<br></p><br><p><br>    &nbsp;&nbsp;&nbsp; 11.1.2.2.2&nbsp;&nbsp;&nbsp;&nbsp;SelectChannelConnector将ServerSocketChannel _acceptChannel绑定到指定端口new InetSocketAddress(getPort())<br><br>&nbsp;&nbsp;&nbsp; 11.1.2.2.3&nbsp;&nbsp;&nbsp;&nbsp;SelectChannelConnector调用AggregateLifeCycle.addBean方法，将_acceptChannel注册入AggregateLifeCycle._beans<br></p><br><p><br>    &nbsp;&nbsp;&nbsp; 11.1.2.3&nbsp;&nbsp;&nbsp;&nbsp;SelectChannelConnector结束调用自身实现的open方法<br></p><br><p><br>    &nbsp;&nbsp;&nbsp; 11.1.2.4&nbsp;&nbsp;&nbsp;&nbsp;SelectChannelConnector调用父类AbstractConnector的父类AggregateLifeCycle的doStart方法<br></p><br><p><br>    &nbsp;&nbsp;&nbsp; 11.1.2.5&nbsp;&nbsp;&nbsp;&nbsp;SelectChannelConnector的祖宗类AggregateLifeCycle检查_beans是否已经全部启动，如果没有启动，则调用start方法<br></p><br><p><br>    &nbsp;&nbsp;&nbsp; 11.1.2.5.1&nbsp;&nbsp;&nbsp; 在步骤4.2中，ConnectorSelectorManager被注册到了SelectChannelConnector的祖宗类AggregateLifeCycle._beans中，此处SelectChannelConnector的隐含对象ConnectorSelectorManager的start方法被调用<br></p><br><p><br>    &nbsp;&nbsp;&nbsp; 11.1.2.5.2&nbsp;&nbsp;&nbsp;&nbsp;ConnectorSelectorManager调用继承自祖宗类AbstractLifeCycle的.start方法<br></p><br><p><br>    &nbsp;&nbsp;&nbsp; 11.1.2.5.3&nbsp;&nbsp;&nbsp;&nbsp;ConnectorSelectorManager调用继承自祖宗类AbstractLifeCycle的.setStarting方法<br></p><br><p><br>    &nbsp;&nbsp;&nbsp; 11.1.2.5.4&nbsp;&nbsp;&nbsp;&nbsp;ConnectorSelectorManager调用继承自父类SelectorManager实现的.doStart()方法<br></p><br><p><br>    &nbsp;&nbsp;&nbsp; 11.1.2.5.4.1&nbsp;&nbsp;&nbsp; ConnectorSelectorManager的父类SelectorManager初始化_selectSet[]数组为新的SelectSet数组<br></p><br><p><br>    &nbsp;&nbsp;&nbsp; 11.1.2.5.4.2&nbsp;&nbsp;&nbsp; ConnectorSelectorManager的父类SelectorManager调用父类AbstractLifeCycle.doStart()方法，空方法<br></p><br><p><br>    &nbsp;&nbsp;&nbsp; 11.1.2.5.4.3&nbsp;&nbsp;&nbsp;&nbsp;SelectorManager.doStart中对SelectSet进行循环<br></p><br><p><br>    &nbsp;&nbsp;&nbsp; 11.1.2.5.4.3.1&nbsp;&nbsp;&nbsp; 创建新的Runable接口对象”循环调用SelectSet.doSelect”<br></p><br><p><br>    &nbsp;&nbsp;&nbsp; 11.1.2.5.4.3.2&nbsp;&nbsp;&nbsp; 将Runable接口对象通过调用ConnectorSelectorManager.dispatch方法，委托给QueuedThreadPool执行<br></p><br><p><br>    &nbsp;&nbsp;&nbsp; 11.1.2.5.5&nbsp;&nbsp;&nbsp; ConnectorSelectorManager结束调用继承自父类SelectorManager实现的.doStart()方法<br></p><br><p><br>    &nbsp;&nbsp;&nbsp; 11.1.2.5.6&nbsp;&nbsp;&nbsp;&nbsp;ConnectorSelectorManager调用继承自祖宗类AbstractLifeCycle的.setStarted方法<br></p><br><p><br>    &nbsp;&nbsp;&nbsp; 11.1.2.6&nbsp;&nbsp;&nbsp;&nbsp;SelectChannelConnector的祖宗类AggregateLifeCycle设置_started启动标志为已启动<br></p><br><p><br>    &nbsp;&nbsp;&nbsp; 11.1.2.7&nbsp;&nbsp;&nbsp; SelectChannelConnector的祖宗类AggregateLifeCycle调用父类AbstractLifeCycle.doStart()空方法<br></p><br><p><br>    &nbsp;&nbsp;&nbsp; 11.1.2.8 &nbsp;&nbsp; SelectChannelConnector结束调用父类AbstractConnector的父类AggregateLifeCycle的doStart方法<br></p><br><p><br>    &nbsp;&nbsp;&nbsp; 11.1.2.9 &nbsp;&nbsp; SelectChannelConnector结束调用父类AbstractConnector的doStart方法<br></p><br><p><br>    &nbsp;&nbsp;&nbsp; 11.1.2.10&nbsp;&nbsp;&nbsp;&nbsp;SelectChannelConnector根据_acceptorThreads配置，创建相应数量的Acceptor委托给_threadPool执行<br></p><br><p><br>    &nbsp;&nbsp;&nbsp; 11.1.3 &nbsp;&nbsp; SelectChannelConnector结束调用自身实现的doStart方法<br></p><br><p><br>    &nbsp;&nbsp;&nbsp; 11.2&nbsp;&nbsp;&nbsp;&nbsp;SelectChannelConnector调用继承自父类AbstractLifeCycle的setStarted方法<br></p><br><p><br>    &nbsp;&nbsp;&nbsp; 11.3&nbsp;&nbsp;&nbsp;&nbsp;SelectChannelConnector的start结束。<br></p><br><p><br>    12、接步骤11.1.2.10,SelectChannelConnector根据_acceptorThreads配置，创建相应数量的Acceptor委托给_threadPool执行<br></p><br><p><br>    &nbsp;&nbsp;&nbsp; 12.1&nbsp;&nbsp;&nbsp; AbstractConnector的内部类Acceptor开始运行<br></p><br><p><br>    &nbsp;&nbsp;&nbsp; 12.2&nbsp;&nbsp;&nbsp; Acceptor调用accept方法（由于是SelectorChannelConnector创建了父类AbstractConnector的内部类Acceptor对象，则Acceptor对象调用的AbstractConnector的抽象方法accept，最终调用的是SelectorChannelConnector的accept方法）<br></p><br><p><br>    &nbsp;&nbsp;&nbsp; 12.3&nbsp;&nbsp;&nbsp;&nbsp;Acceptor调用SelectorChannelConnector的accept方法<br></p><br><p><br>    &nbsp;&nbsp;&nbsp; 12.4&nbsp;&nbsp;&nbsp;&nbsp;SelectorChannelConnector.accept方法中开始accept阻塞SocketChannel channel = server.accept();<br></p><br><p><br>    &nbsp;&nbsp;&nbsp; 12.5&nbsp;&nbsp;&nbsp; 客户端发起连接<br></p><br><p><br>    &nbsp;&nbsp;&nbsp; 12.6&nbsp;&nbsp;&nbsp; 阻塞释放<br></p><br><p><br>    &nbsp;&nbsp;&nbsp; 12.7&nbsp;&nbsp;&nbsp;&nbsp;SelectorChannelConnector.accept方法中，调用_manager.register(channel);，即SelectorManager.register(SocketChannel channel)<br></p><br><p><br>    &nbsp;&nbsp;&nbsp; 12.8&nbsp;&nbsp;&nbsp; 用取余算法随机取一个SelectorManager._selectSet[i]的SelecSet<br><br>&nbsp;&nbsp;&nbsp; 12.9&nbsp;&nbsp;&nbsp; 将变更事件放入SelectSet中，调用wakup函数唤醒在SelectSet上睡眠的线程<br></p><br><p><br>    13、接步骤11.1.2.5.4.3.2&nbsp;&nbsp;&nbsp;&nbsp;将Runable接口对象”循环调用SelectSet.doSelect”通过调用ConnectorSelectorManager.dispatch方法，委托给QueuedThreadPool执行<br></p><br><p><br>    &nbsp;&nbsp;&nbsp; 13.1&nbsp;&nbsp;&nbsp; SelectSet调用doSelect方法<br></p><br><p><br>    &nbsp;&nbsp;&nbsp; 13.2&nbsp;&nbsp;&nbsp; 从SelectSet内部对象ConcurrentLinkedQueue&lt;Object&gt; _changes变更事件队列中poll出一个事件<br></p><br><p><br>    &nbsp;&nbsp;&nbsp; 13.2.1&nbsp;&nbsp;&nbsp; 如果poll出的事件是EndPoint，进行相应处理<br></p><br><p><br>    &nbsp;&nbsp;&nbsp; 13.2.2&nbsp;&nbsp;&nbsp; 如果poll出的事件是ChannelAndAttachment，进行相应处理<br></p><br><p><br>    &nbsp;&nbsp;&nbsp; 13.2.3&nbsp;&nbsp;&nbsp; 如果poll出的事件是ChangeTask，则直接运行<br></p><br><p><br>    &nbsp;&nbsp;&nbsp; 13.2.4&nbsp;&nbsp;&nbsp; 如果poll出的事件是Runnable，则委托给线程池运行<br></p><br><p><br>    &nbsp;&nbsp;&nbsp; 13.2.5 &nbsp;&nbsp; 如果poll出的事件是SocketChannel<br></p><br><p><br>    &nbsp;&nbsp;&nbsp; 13.2.5.1&nbsp;&nbsp;&nbsp; 在当前SelectSet的专用Selector上注册一个channel的read事件&nbsp;&nbsp;&nbsp;&nbsp;<br></p><br><p><br>    &nbsp;&nbsp;&nbsp; 13.2.5.2&nbsp;&nbsp;&nbsp; 调用createEndPoint方法创建一个SelectChannelEndPoint<br></p><br><p><br>    &nbsp;&nbsp;&nbsp; 13.2.5.2.1 &nbsp;&nbsp; 调用newEndPoint方法，创建一个SelectChannelEndPoint<br></p><br><p><br>    &nbsp;&nbsp;&nbsp; 13.2.5.2.2 &nbsp;&nbsp; 调用ConnectorSelectorManager.newEndPoint方法，return SelectChannelConnector.this.newEndPoint(channel,selectSet,sKey);<br></p><br><p><br>    &nbsp;&nbsp;&nbsp; 13.2.5.2.3 &nbsp;&nbsp; SelectChannelEndPoint endp= new SelectChannelEndPoint(channel,selectSet,key, SelectChannelConnector.this._maxIdleTime);<br></p><br><p><br>    &nbsp;&nbsp;&nbsp; 13.2.5.2.4 &nbsp;&nbsp; endp设置Connection为selectSet.getManager().newConnection(channel,endp, key.attachment())<br></p><br><p><br>    &nbsp;&nbsp;&nbsp; 13.2.5.2.4.1 &nbsp;&nbsp; 调用ConnectorSelectorManager.newConnection方法，创造一个new AsyncHttpConnection(SelectChannelConnector.this,endpoint,getServer());<br></p><br><p><br>    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 内部已经生成一系列解析HTTP的工具，如：<br></p><br><p><br>    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;HttpBuffersImpl _buffers = new HttpBuffersImpl();<br></p><br><p><br>    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;protected final Parser _parser;<br></p><br><p><br>    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;protected final Request _request;<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;protected final HttpFields _requestFields;<br></p><br><p><br>    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; protected final Generator _generator;<br></p><br><p><br>    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;protected final HttpFields _responseFields;<br></p><br><p><br>    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;protected final Response _response;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 等<br></p><br><p><br>    &nbsp;&nbsp;&nbsp; 13.2.5.3&nbsp;&nbsp;&nbsp; 调用key.attach(endpoint);将SelectChannelEndPoint附加到channel读事件的key上<br></p><br><p><br>    &nbsp;&nbsp;&nbsp; 13.2.5.4&nbsp;&nbsp;&nbsp; 调用SelectChannelEndPoint.schedule()<br></p><br><p><br>    &nbsp;&nbsp;&nbsp; 13.2.5.4.1&nbsp;&nbsp;&nbsp; 正常情况下，调用SelectChannelEndPoint.dispatch<br></p><br><p><br>    &nbsp;&nbsp;&nbsp; 13.2.5.4.2&nbsp;&nbsp;&nbsp; 调用_manager.dispatch(_handler);即ConnectorSelectorManager.dispatcher方法，将_handler交给线程池执行<br></p><br><p><br>    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; _handler接口如下<br></p><br><p><br>    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;private final Runnable _handler = new Runnable()<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;public void run() { handle(); }<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;};<br></p><br><p><br>    &nbsp;&nbsp;&nbsp; 13.2.5.4.3&nbsp;&nbsp;&nbsp; 即：线程池会运行_handler接口，调用SelectChannelEndPoint.handle方法<br></p><br><p><br>    &nbsp;&nbsp;&nbsp; 13.2.5.4.3.1&nbsp;&nbsp;&nbsp; 调用AsyncConnection next = (AsyncConnection)_connection.handle();&nbsp;&nbsp;&nbsp; 此处的AsyncConnection是在步骤13.2.5.2.4.1中生成<br></p><br><p><br>    &nbsp;&nbsp;&nbsp; 13.2.5.4.3.1.1&nbsp;&nbsp;&nbsp; 调用AsyncHttpConnection.handle()方法<br></p><br><p><br>    &nbsp;&nbsp;&nbsp; 13.2.5.4.3.1.2&nbsp;&nbsp;&nbsp; 调用AsyncHttpConnection的父类AbstractHttpConnection的类变量_parser的parseAvailable()方法<br></p><br><p><br>    &nbsp;&nbsp;&nbsp; 13.2.5.4.3.1.2.1&nbsp;&nbsp;&nbsp; 调用_parser的parseNext()方法<br></p><br><p><br>    &nbsp;&nbsp;&nbsp; 13.2.5.4.3.1.2.2&nbsp;&nbsp;&nbsp; 生成_buffer=getHeaderBuffer();–&gt;从AsyncHttpConnection中获取new 时初始化的buffer<br></p><br><p><br>    &nbsp;&nbsp;&nbsp; 13.2.5.4.3.1.2.3&nbsp;&nbsp;&nbsp; 调用_parser的fill()方法给_buffer填充数据<br></p><br><p><br>    &nbsp;&nbsp;&nbsp; 13.2.5.4.3.1.2.3.1 &nbsp;&nbsp; 调用_endp.fill(_buffer)，即SelectChannelEndPoint.fill(_buffer)<br></p><br><p><br>    &nbsp;&nbsp;&nbsp; 13.2.5.4.3.1.2.3.2 &nbsp;&nbsp; 调用SelectChannelEndPoint的父类ChannelEndPoint.fill(_buffer)方法<br></p><br><p><br>    &nbsp;&nbsp;&nbsp; 13.2.5.4.3.1.2.3.3 &nbsp;&nbsp; 调用SelectChannelEndPoint的父类ChannelEndPoint的_channel.read(bbuf)方法填充数据，即：SocketChannelImpl.fill(bbuf)<br></p><br><p><br>    &nbsp;&nbsp;&nbsp; 13.2.5.4.3.1.2.3.4&nbsp;&nbsp;&nbsp; 结束调用_endp.fill(_buffer)，即SelectChannelEndPoint.fill(_buffer)<br></p><br><p><br>    &nbsp;&nbsp;&nbsp; 13.2.5.4.3.1.2.4&nbsp;&nbsp;&nbsp; 结束调用_parser的fill()方法给_buffer填充数据<br></p><br><p><br>    &nbsp;&nbsp;&nbsp; 13.2.5.4.3.1.2.5&nbsp;&nbsp;&nbsp; _parser开始解析http报文（起始代码HttpParse.java 343行while (_state&lt;STATE_END &amp;&amp; length–&gt;0)）<br></p><br><p><br>    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 此处Http报文解析写的很经典，通过定义一定的状态位，控制解析报文的状态，从-14状态直至最终结束，推荐学习之，虽然这种写法很奇葩……<br></p><br><p><br>    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;让我想起了以前我有幸参观的伟大的、独一无二的、软件定制巨头南天公司的一伙人写的一个配置文件的解析，也是一个while循环，读取配置文件<br></p><br><blockquote><br>    <blockquote><br>        <blockquote><br>            <p><br>                &nbsp;&nbsp;&nbsp; // States<br><br>&nbsp;&nbsp;&nbsp; public static final int STATE_START=-14;<br><br>&nbsp;&nbsp;&nbsp; public static final int STATE_FIELD0=-13;<br><br>&nbsp;&nbsp;&nbsp; public static final int STATE_SPACE1=-12;<br><br>&nbsp;&nbsp;&nbsp; public static final int STATE_STATUS=-11;<br><br>&nbsp;&nbsp;&nbsp; public static final int STATE_URI=-10;<br><br>&nbsp;&nbsp;&nbsp; public static final int STATE_SPACE2=-9;<br><br>&nbsp;&nbsp;&nbsp; public static final int STATE_END0=-8;<br><br>&nbsp;&nbsp;&nbsp; public static final int STATE_END1=-7;<br><br>&nbsp;&nbsp;&nbsp; public static final int STATE_FIELD2=-6;<br><br>&nbsp;&nbsp;&nbsp; public static final int STATE_HEADER=-5;<br><br>&nbsp;&nbsp;&nbsp; public static final int STATE_HEADER_NAME=-4;<br><br>&nbsp;&nbsp;&nbsp; public static final int STATE_HEADER_IN_NAME=-3;<br><br>&nbsp;&nbsp;&nbsp; public static final int STATE_HEADER_VALUE=-2;<br><br>&nbsp;&nbsp;&nbsp; public static final int STATE_HEADER_IN_VALUE=-1;<br><br>&nbsp;&nbsp;&nbsp; public static final int STATE_END=0;<br><br>&nbsp;&nbsp;&nbsp; public static final int STATE_EOF_CONTENT=1;<br><br>&nbsp;&nbsp;&nbsp; public static final int STATE_CONTENT=2;<br><br>&nbsp;&nbsp;&nbsp; public static final int STATE_CHUNKED_CONTENT=3;<br><br>&nbsp;&nbsp;&nbsp; public static final int STATE_CHUNK_SIZE=4;<br><br>&nbsp;&nbsp;&nbsp; public static final int STATE_CHUNK_PARAMS=5;<br><br>&nbsp;&nbsp;&nbsp; public static final int STATE_CHUNK=6;<br><br>&nbsp;&nbsp;&nbsp; public static final int STATE_SEEKING_EOF=7;<br>            </p><br>        </blockquote><br>    </blockquote><br></blockquote><br><p><br>    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 通过状态位的逐渐提升，逐步完成了method,url,version,header……等一系列报文的解析<br></p><br><p><br>    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 以jetty8.17版本为例：<br></p><br><p><br>    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;HttpParser379行完成Method解析<br></p><br><p><br>    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;HttpParser438行完成URI解析<br></p><br><p><br>    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; HttpParser491行完成对AbstractHttpConnection的request信息：Method,Uri,Protoco;的注入<br></p><br><p><br>    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 通过调用AbstractHttpConnection.startRequest(Buffer method, Buffer uri, Buffer version)注入三个信息<br></p><br><p><br>    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; HttpParser520,522行，完成了一对Header和value的解析<br></p><br><p><br>    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; HttpParser596行，完成了_hander对Header的注入<br></p><br><p><br>    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 通过调用AbstractHttpConnection.parsedHeader(Buffer name, Buffer value)<br></p><br><p><br>    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 在_requestFields中add(name,value)<br><br>&nbsp;&nbsp;&nbsp;&nbsp;13.2.5.4.3.1.2.6&nbsp;&nbsp;&nbsp; 在HttpParser644行—-》在未知response状态的情况下，假设_contentLength=HttpTokens.NO_CONTENT;（619行,原因是：如果头部既没有长度532行又没有549行chunk，就认为是没有内容的，那么就是无长度的）<br></p><br><p><br>    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 进入644行_handler.headerComplete();<br></p><br><p><br>    &nbsp;&nbsp;&nbsp; 13.2.5.4.3.1.2.7&nbsp;&nbsp;&nbsp; 调用AbstractHttpConnection.headerComplete()<br></p><br><p><br>    &nbsp;&nbsp;&nbsp;&nbsp;13.2.5.4.3.1.2.7.1 &nbsp;&nbsp; 调用AbstractHttpConnection.headerComplete()<br></p><br><p><br>    &nbsp;&nbsp;&nbsp; 13.2.5.4.3.1.2.7.2&nbsp;&nbsp;&nbsp; 设置_generator.setVersion(11)代表http1.1<br></p><br><p><br>    &nbsp;&nbsp;&nbsp; 13.2.5.4.3.1.2.7.3&nbsp;&nbsp;&nbsp; 进入http1.1的switch处理分支<br></p><br><p><br>    &nbsp;&nbsp;&nbsp; 13.2.5.4.3.1.2.7.4&nbsp;&nbsp;&nbsp; 进入AbstractHttpConnection.handleRequest分支<br></p><br><p><br>    &nbsp;&nbsp;&nbsp;&nbsp;13.2.5.4.3.1.2.7.5&nbsp;&nbsp;&nbsp;&nbsp;AbstractHttpConnection对uri进行处理，生成path,info<br></p><br><p><br>    &nbsp;&nbsp;&nbsp; 13.2.5.4.3.1.2.7.6 &nbsp;&nbsp; AbstractHttpConnection调用_request.setPathInfo(info)<br></p><br><p><br>    &nbsp;&nbsp;&nbsp; 13.2.5.4.3.1.2.7.7&nbsp;&nbsp;&nbsp;&nbsp;AbstractHttpConnection第494行server.handle(this);调用server方法处理AbstractHttpConnection，实现类为AsyncHttpConnection<br></p><br><p><br>    &nbsp;&nbsp;&nbsp; 13.2.5.4.3.1.2.7.8&nbsp;&nbsp;&nbsp; Server调用public void handle(AbstractHttpConnection connection)方法<br></p><br><p><br>    &nbsp;&nbsp;&nbsp; 13.2.5.4.3.1.2.7.8.1&nbsp;&nbsp;&nbsp;&nbsp;生成 target,Request,Response对象<br></p><br><p><br>    &nbsp;&nbsp;&nbsp;&nbsp;13.2.5.4.3.1.2.7.8.2&nbsp;&nbsp;&nbsp; 调用Server.handle(String target, Request baseRequest, HttpServletRequest request, HttpServletResponse response)方法<br></p><br><p><br>    &nbsp;&nbsp;&nbsp; 13.2.5.4.3.1.2.7.8.3&nbsp;&nbsp;&nbsp; 调用Server._handler.handle(target,baseRequest, request, response)<br></p><br><p><br>    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 即：WebAppContext.handle(String target, Request baseRequest, HttpServletRequest request, HttpServletResponse response)方法<br></p><br><p><br>    &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;……….<br></p><br><p><br>    &nbsp;&nbsp;&nbsp; 13.2.5.4.3.1.3 &nbsp;&nbsp; 结束调用AsyncHttpConnection的父类AbstractHttpConnection的类变量_parser的parseAvailable()方法<br></p><br><p><br>    &nbsp;&nbsp;&nbsp; 13.2.5.4.3.1.4&nbsp;&nbsp;&nbsp; 调用_endp.flush()，将输出内容传输到客户端浏览器上。<br></p><br><p><br>    <br><br></p><br><p><br>    ——————————————————————————————————————————————————————————————<br></p><br><p><br>    至此Jetty<br>服务器的启动顺序展示完毕：<br></p><br><p><br>    上文展示了从Jetty启动、生命周期对象初始化、建立IO监听、到一个客户端发起连接、客户端输入Http报文，输入事件经各组件之间的消息传递、报文交给处理器解析执行、最终交给WebAppCOntext的Handle处理的全过程<br></p><br><p><br>    从上文调用顺序可以看到,Jetty的模块化十分清晰，结构简单可靠，扩展性强，举个例子，如果你想用Jetty改造一下，做成一个其他协议的通讯框架，仅需在步骤13.2.5.4.3.1上扩展一个自己的Connection即可<br></p><br><p><br>    <br><br></p><br><p><br>    </p><p><br>        ——————————————————————————————————————————————————————————————<br>    </p><br>    <p><br>        ———————————————————————-<span style="background-color:#000000;color:#E53333;">Handle处理过程</span>————————————————————————————-<br>    </p><br>——————————————————————————————————————————————————————————————<br><p></p><br><p><br>    下文要说一下Handle处理的过程<br></p><br><p><br>    关于Handle最好先阅读一下这两篇文章，以补充一下基础知识:<br></p><br><p><br>    <a href="http://my.oschina.net/tryUcatchUfinallyU/blog/112972" target="_blank" rel="external">http://my.oschina.net/tryUcatchUfinallyU/blog/112972</a><br></p><br><p><br>    <a href="http://www.blogjava.net/DLevin/archive/2014/05/07/413158.html" target="_blank" rel="external">http://www.blogjava.net/DLevin/archive/2014/05/07/413158.html</a><br></p><br><p><br>    ——————————————————————————————————————————————————————————————<br></p><br><p><br>    Handler接口如下，可以看到，主要执行的是handle方法<br></p><br><blockquote><br>    <blockquote><br>        <blockquote><br>            <p><br>                public interface Handler extends LifeCycle, Destroyable{<br><br>&nbsp;&nbsp;&nbsp; public void handle(String target, Request baseRequest, HttpServletRequest request, HttpServletResponse response)<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; throws IOException, ServletException;<br><br>&nbsp;&nbsp;&nbsp; public void setServer(Server server);<br><br>&nbsp;&nbsp;&nbsp; public Server getServer();<br><br>&nbsp;&nbsp;&nbsp; public void destroy();<br><br>}<br>            </p><br>        </blockquote><br>    </blockquote><br></blockquote><br><p><br>    其子类中比较重要的有：<br></p><br><p><br>    &nbsp;&nbsp;&nbsp; <span style="background-color:#000000;color:#E53333;">HandlerCollection</span>&nbsp;&nbsp;&nbsp; 具有Handler的集合，可以按照顺序全部执行内部的handler<br></p><br><p><br>    &nbsp;&nbsp;&nbsp; <span style="color:#E53333;background-color:#000000;">HandlerList</span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 具有Handler的列表，按照顺序执行内部handler，如果内部发生异常或者request标记为已处理，则不再继续向下执行<br></p><br><p><br>    &nbsp;&nbsp;&nbsp; <span style="background-color:#000000;color:#E53333;">HandlerWrapper</span>&nbsp;&nbsp;&nbsp;&nbsp; 是内部一个_handler的包装，实现了HandlerContainer和LifyCycle接口，具有略微高级一点的功能。<br></p><br><p><br>    &nbsp;&nbsp;&nbsp; <span style="background-color:#000000;color:#E53333;">ScopedHandler</span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 内部有两个方法doScoped和doHandle，类文档如是说：<br></p><br><blockquote><br>    <blockquote><br>        <blockquote><br>            <p><br>                &nbsp;<span style="background-color:#FFFFFF;color:#003399;"><em> &lt;p&gt;For example if Scoped handlers A, B &amp; C were chained together, then </em></span><br><br><span style="background-color:#FFFFFF;color:#003399;">&nbsp; the calling order would be:&lt;pre&gt;</span><br><br><span style="background-color:#FFFFFF;color:#003399;">&nbsp;<em> A.handle(…)</em></span><br><br><span style="background-color:#FFFFFF;color:#003399;">&nbsp;&nbsp;&nbsp; A.doScope(…)</span><br><br><span style="background-color:#FFFFFF;color:#003399;">&nbsp;<em>&nbsp;&nbsp;&nbsp;&nbsp; B.doScope(…)</em></span><br><br><span style="background-color:#FFFFFF;color:#003399;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; C.doScope(…)</span><br><br><span style="background-color:#FFFFFF;color:#003399;">&nbsp;<em>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; A.doHandle(…)</em></span><br><br><span style="background-color:#FFFFFF;color:#003399;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; B.doHandle(…)</span><br><br><span style="background-color:#FFFFFF;color:#003399;">&nbsp;<em>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; C.doHandle(…)&nbsp; &nbsp;</em></span><br><br><span style="background-color:#FFFFFF;color:#003399;">&nbsp; &lt;pre&gt;</span><br><br><span style="background-color:#FFFFFF;color:#003399;">&nbsp;<em> </em></span><br><br><span style="background-color:#FFFFFF;color:#003399;">&nbsp; &lt;p&gt;If non scoped handler X was in the chained A, B, X &amp; C, then </span><br><br><span style="background-color:#FFFFFF;color:#003399;">&nbsp;<em> the calling order would be:&lt;pre&gt;</em></span><br><br><span style="background-color:#FFFFFF;color:#003399;">&nbsp; A.handle(…)</span><br><br><span style="background-color:#FFFFFF;color:#003399;">&nbsp;<em>&nbsp;&nbsp; A.doScope(…)</em></span><br><br><span style="background-color:#FFFFFF;color:#003399;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; B.doScope(…)</span><br><br><span style="background-color:#FFFFFF;color:#003399;">&nbsp;<em>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; C.doScope(…)</em></span><br><br><span style="background-color:#FFFFFF;color:#003399;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; A.doHandle(…)</span><br><br><span style="background-color:#FFFFFF;color:#003399;">&nbsp;<em>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; B.doHandle(…)</em></span><br><br><span style="background-color:#FFFFFF;color:#003399;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; X.handle(…)</span><br><br><span style="background-color:#FFFFFF;color:#003399;">&nbsp;<em>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; C.handle(…)</em></span><br><br><span style="background-color:#FFFFFF;color:#003399;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; C.doHandle(…)&nbsp;&nbsp; </span><br>            </p><br>        </blockquote><br>    </blockquote><br></blockquote><br><p><br>    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 但我认为这是一个然并卵的功能：请看ScopedHandler.handle的代码：<br></p><br><blockquote><br>    <blockquote><br>        <blockquote><br>            <p><br>                <span style="background-color:#FFFFFF;">public final void <span style="background-color:#000000;color:#E53333;">handle</span>(String target, Request baseRequest, HttpServletRequest request, HttpServletResponse response) throws IOException, ServletException</span><br><br><span style="background-color:#FFFFFF;">&nbsp;&nbsp;&nbsp; {</span><br><br><span style="background-color:#FFFFFF;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (_outerScope==null) &nbsp;</span><br><br><span style="background-color:#FFFFFF;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; doScope(target,baseRequest,request, response);</span><br><br><span style="background-color:#FFFFFF;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; else </span><br><br><span style="background-color:#FFFFFF;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; doHandle(target,baseRequest,request, response);</span><br><br><span style="background-color:#FFFFFF;">&nbsp;&nbsp;&nbsp; }</span><br>            </p><br>            <p><br>                <span style="background-color:#FFFFFF;">public final void <span style="background-color:#000000;color:#E53333;">nextScope</span>(String target, Request baseRequest, HttpServletRequest request, HttpServletResponse response) </span><br><br><span style="background-color:#FFFFFF;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; throws IOException, ServletException</span><br><br><span style="background-color:#FFFFFF;">&nbsp;&nbsp;&nbsp; {</span><br><br><span style="background-color:#FFFFFF;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (_nextScope!=null)</span><br><br><span style="background-color:#FFFFFF;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; _nextScope.doScope(target,baseRequest,request, response);</span><br><br><span style="background-color:#FFFFFF;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; else if (_outerScope!=null)</span><br><br><span style="background-color:#FFFFFF;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; _outerScope.doHandle(target,baseRequest,request, response);</span><br><br><span style="background-color:#FFFFFF;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; else </span><br><br><span style="background-color:#FFFFFF;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; doHandle(target,baseRequest,request, response);</span><br><br><span style="background-color:#FFFFFF;">&nbsp;&nbsp;&nbsp; }</span><br>            </p><br>            <p><br>                <span style="background-color:#FFFFFF;">public final void <span style="background-color:#000000;color:#E53333;">nextHandle</span>(String target, final Request baseRequest, HttpServletRequest request, HttpServletResponse response) throws IOException, ServletException</span><br><br><span style="background-color:#FFFFFF;">&nbsp;&nbsp;&nbsp; {</span><br><br><span style="background-color:#FFFFFF;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (_nextScope!=null &amp;&amp; _nextScope==_handler)</span><br><br><span style="background-color:#FFFFFF;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; _nextScope.doHandle(target,baseRequest,request, response);</span><br><br><span style="background-color:#FFFFFF;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; else if (_handler!=null)</span><br><br><span style="background-color:#FFFFFF;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; _handler.handle(target,baseRequest, request, response);</span><br><br><span style="background-color:#FFFFFF;">&nbsp;&nbsp;&nbsp; }</span><br>            </p><br>        </blockquote><br>    </blockquote><br></blockquote><br><p><br>    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;关键在于方法中的_nextScope和_outerScope究竟是什么东西<br></p><br><p><br>    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 在SocpeHandler的doStart方法中可以看到：<br></p><br><p><br>    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;_outerScope就是处理序列中第一个doStart的ScopedHandle，而_nextScope是当前ScopedHandle的父类HandleWrapper的实例变量_handler<br></p><br><p><br>    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 换句话说：只有用一种极其奇葩的写法，才能实现如文档说明的效果：参见<a href="http://www.blogjava.net/DLevin/archive/2014/05/07/413158.html文档" target="_blank" rel="external">http://www.blogjava.net/DLevin/archive/2014/05/07/413158.html文档</a><br></p><br><p><br>    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; N句话总结之：<br></p><br><p><br>    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 1、在实现中，其Handler链表由HandlerWrapper构建，在doStart()方法中计算_nextScope字段以及<br>_outerScope字段，在handle()方法中，如果_outerScope为null，则调用doScope()方法，否则调用<br>doHandle()方法；<br></p><br><p><br>    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 2、在执行完doScope()方法后，调用nextScope()方法，该方法顺着_nextScope链表走，直到尽头，后调用doHandle()方法；<br></p><br><p><br>    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 3、而doHandle()方法在完成是调用nextHandle()方法，它也沿着_nextScope链表走，只要_nextScope和<br>_handler相同，则调用其doHandle()方法，但是如果_nextScope和_handler不同，则调用_handler中的<br>handle()方法，用于处理在ScopedHandler链表中插入非ScopedHandler的情况<br></p><br><p><br>    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 使用示例可以参见jetty中的testCase，也可以参照下例：<br></p><br><blockquote><br>    <blockquote><br>        <blockquote><br>            <p><br>                public class App003 {<br><br><br><br>&nbsp;&nbsp; &nbsp;public static void main(String[] args) throws Exception {<br><br>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;Server server = new Server();<br><br>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;QueuedThreadPool threadPool = new QueuedThreadPool();<br><br>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;threadPool.setMaxThreads(100);<br><br>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;server.setThreadPool(threadPool);<br>            </p><br>            <p><br>                &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; SelectChannelConnector selectChannelConnector = new SelectChannelConnector();<br><br>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;selectChannelConnector.setHost(“0.0.0.0”);<br><br>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;selectChannelConnector.setPort(8080);<br><br>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;server.addConnector(selectChannelConnector);<br><br>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;<br><br>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;ScopedHandlerA sa = new ScopedHandlerA();<br><br>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;ScopedHandlerB sb = new ScopedHandlerB();<br><br>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;ScopedHandlerC sc = new ScopedHandlerC();<br><br>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;HandlerWrapperA ha = new HandlerWrapperA();<br><br>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;<br><br>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;sa.setHandler(sb);<br><br>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;sb.setHandler(ha);<br><br>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;ha.setHandler(sc);<br><br>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; <br><br>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;server.setHandler(sa);<br><br>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;server.start();<br><br>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;server.join();<br><br>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;<br><br>&nbsp;&nbsp; &nbsp;}<br><br>&nbsp;&nbsp; &nbsp;<br><br>&nbsp;&nbsp; &nbsp;public static class ScopedHandlerA extends ScopedHandler{<br><br>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;public void doScope(String target, Request baseRequest,<br><br>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;HttpServletRequest request, HttpServletResponse response)<br><br>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;throws IOException, ServletException {<br><br>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;System.out.println(“SHA-Scoped–&gt;”);<br><br>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;nextScope(target, baseRequest, request, response);<br><br>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;System.out.println(“&lt;–SHA-Scoped”);<br><br>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;}<br><br>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;public void doHandle(String target, Request baseRequest,<br><br>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;HttpServletRequest request, HttpServletResponse response)<br><br>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;throws IOException, ServletException {<br><br>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;System.out.println(“SHA-Handle–&gt;”);<br><br>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;nextHandle(target, baseRequest, request, response);<br><br>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;System.out.println(“&lt;–SHA-Handle”);<br><br>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;}<br><br>&nbsp;&nbsp; &nbsp;}<br><br>&nbsp;&nbsp; &nbsp;<br><br>&nbsp;&nbsp; &nbsp;public static class ScopedHandlerB extends ScopedHandler{<br><br>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;public void doScope(String target, Request baseRequest,<br><br>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;HttpServletRequest request, HttpServletResponse response)<br><br>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;throws IOException, ServletException {<br><br>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;System.out.println(“SHB-Scoped–&gt;”);<br><br>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;nextScope(target, baseRequest, request, response);<br><br>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;System.out.println(“&lt;–SHB-Scoped”);<br><br>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;}<br><br>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;public void doHandle(String target, Request baseRequest,<br><br>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;HttpServletRequest request, HttpServletResponse response)<br><br>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;throws IOException, ServletException {<br><br>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;System.out.println(“SHB-Handle–&gt;”);<br><br>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;nextHandle(target, baseRequest, request, response);<br><br>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;System.out.println(“&lt;–SHB-Handle”);<br><br>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;}<br><br>&nbsp;&nbsp; &nbsp;}<br><br>&nbsp;&nbsp; &nbsp;<br><br>&nbsp;&nbsp; &nbsp;public static class ScopedHandlerC extends ScopedHandler{<br><br>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;public void doScope(String target, Request baseRequest,<br><br>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;HttpServletRequest request, HttpServletResponse response)<br><br>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;throws IOException, ServletException {<br><br>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;System.out.println(“SHC-Scoped–&gt;”);<br><br>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;nextScope(target, baseRequest, request, response);<br><br>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;System.out.println(“&lt;–SHC-Scoped”);<br><br>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;}<br><br>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;public void doHandle(String target, Request baseRequest,<br><br>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;HttpServletRequest request, HttpServletResponse response)<br><br>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;throws IOException, ServletException {<br><br>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;System.out.println(“SHC-Handle–&gt;”);<br><br>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;nextHandle(target, baseRequest, request, response);<br><br>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;System.out.println(“&lt;–SHC-Handle”);<br><br>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;}<br><br>&nbsp;&nbsp; &nbsp;}<br><br>&nbsp;&nbsp; &nbsp;public static class HandlerWrapperA extends HandlerWrapper{<br><br>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;public void handle(String target, Request baseRequest,<br><br>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;HttpServletRequest request, HttpServletResponse response)<br><br>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;throws IOException, ServletException {<br><br>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;System.out.println(“h-Handle–&gt;”);<br><br>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;super.handle(target, baseRequest, request, response);<br><br>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;System.out.println(“&lt;–h-Handle”);<br><br>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;}<br><br>&nbsp;&nbsp; &nbsp;}<br><br>}<br>            </p><br>            <p><br>                执行结果如下：<br>            </p><br>            <p><br>                SHA-Scoped–&gt;<br><br>SHB-Scoped–&gt;<br><br>SHC-Scoped–&gt;<br><br>SHA-Handle–&gt;<br><br>SHB-Handle–&gt;<br><br>h-Handle–&gt;<br><br>SHC-Handle–&gt;<br><br>&lt;–SHC-Handle<br><br>&lt;–h-Handle<br><br>&lt;–SHB-Handle<br><br>&lt;–SHA-Handle<br><br>&lt;–SHC-Scoped<br><br>&lt;–SHB-Scoped<br><br>&lt;–SHA-Scoped<br>            </p><br>        </blockquote><br>    </blockquote><br></blockquote><br><p><br>    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 这种写法就会形成如文档描述的效果，但我个人认为这是一个然并卵的功能：<br></p><br><p><br>    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 它的优点如下：<br></p><br><p><br>    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 1、可以在不同的handler之间集中执行scoped代码，例如配置加载等功能<br></p><br><p><br>    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 2、可以随时选择中断不同层级的scoped运行<br></p><br><p><br>    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 但缺点非常严重<br></p><br><p><br>    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 1、构造方法奇特，需要对Handle,HandleWrapper,ScopedHandle等十分了解<br></p><br><p><br>    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 2、逻辑比较复杂，对嵌套递归写法的熟练度要求是“必须为50%，多一点少一点都不行”，开发人员对递归的熟练度低于50%则看不懂，高于50%则会换其他的写法。<br></p><br><p><br>    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 3、代码组装难懂，需要用多个HandleWrapper才能组装成Handle链，与责任链模式相比堪称四不像结构。<br></p><br><p><br>    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 4、代码使用复杂，必须将handle,doScope,doHandle,nextScope,nextHandle形成正确的顺序，才可以调用成功。<br></p><br><p><br>    <br><br></p><br><p><br>    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 换做是我，我会把三个scope和2个handler拆分成3*2+2=8个handler，直线结构的程序要比这四处乱跳的jumpto要更加稳固、更容易维护。<br></p><br><p><br>    <br><br></p><br><p><br>    &nbsp;&nbsp;&nbsp; <span style="background-color:#000000;color:#E53333;">ContextHandle</span>：继承自ScopedHandler，最重要的方法是doScope和doHandle<br></p><br><p><br>    &nbsp;&nbsp;&nbsp; <span style="background-color:#000000;color:#E53333;">ServletContextHandler</span>：继承自ContextHandler，重要的是重写了的ContextHandler.startContext方法<br></p><br><p><br>    &nbsp;&nbsp;&nbsp; <span style="background-color:#000000;color:#E53333;">WebAppContext</span>：继承自ServletContextHandler，重要的是实现了web应用支持的doStart，和从ContextHandle中继承来的doHandle方法。<br></p><br><p><br>    <br><br></p><br><p><br>    ——————————————————————————————————————————————————————————————<br></p><br><p><br>    —————————————————————————— <span style="background-color:#000000;color:#E53333;">伟大的分割线</span>—————————————————————————————-<br></p><br><p><br>    ——————————————————————————————————————————————————————————————<br></p><br>Jetty服务器的启动、初始化、事件触发、组件消息传送、Handler处理就说到这儿。<br><p><br>    <br><br></p><br><p><br>    以上内容是Jetty的核心部分，其他的附加组件如ajp、annotations、deploy、等都是从这个基础上扩展而来的。<br></p><br><p><br>    大家如果有深入学习Jetty的需要，最好直接翻看代码，比看文档要好懂的多。<br></p></div><script type="text/javascript" src="/js/share.js?v=0.0.0" async></script><a data-url="https://kanmars.github.io/2015/07/26/2015-07-25-JETTY_SERVER_V_8.17/" data-id="ciwjetzko007p48vqgd81hs7p" class="article-share-link">Aktie</a><div class="tags"><a href="/tags/server/">server</a><a href="/tags/java/">java</a><a href="/tags/linux/">linux</a><a href="/tags/jetty/">jetty</a></div><div class="post-nav"><a href="/2015/07/26/2015-07-26-JETTY_SERVER_UML_V_8.17/" class="pre">[KANMARS原创] - JETTY服务器组件UML图</a><a href="/2015/07/20/2015-07-20-Spring_IOC_INIT/" class="next">[KANMARS原创] - DEBUG分析SPRING IOC容器启动过程</a></div><div data-thread-key="2015/07/26/2015-07-25-JETTY_SERVER_V_8.17/" data-title="[KANMARS原创] - JETTY服务器源码全解析：从Jetty的组件结构，到Jetty是如何运行的" data-url="https://kanmars.github.io/2015/07/26/2015-07-25-JETTY_SERVER_V_8.17/" class="ds-share flat"><div class="ds-share-inline"><ul class="ds-share-icons-16"><li data-toggle="ds-share-icons-more"><a href="javascript:void(0);" class="ds-more">分享到：</a></li><li><a href="javascript:void(0);" data-service="weibo" class="ds-weibo">微博</a></li><li><a href="javascript:void(0);" data-service="qzone" class="ds-qzone">QQ空间</a></li><li><a href="javascript:void(0);" data-service="qqt" class="ds-qqt">腾讯微博</a></li><li><a href="javascript:void(0);" data-service="wechat" class="ds-wechat">微信</a></li></ul><div class="ds-share-icons-more"></div></div></div><div data-thread-key="2015/07/26/2015-07-25-JETTY_SERVER_V_8.17/" data-title="[KANMARS原创] - JETTY服务器源码全解析：从Jetty的组件结构，到Jetty是如何运行的" data-url="https://kanmars.github.io/2015/07/26/2015-07-25-JETTY_SERVER_V_8.17/" data-author-key="1" class="ds-thread"></div></div></div></div><div class="pure-u-1-4 hidden_mid_and_down"><div id="sidebar"><div class="widget"><form action="//www.baidu.com/baidu" method="get" accept-charset="utf-8" target="_blank" class="search-form"><input type="search" name="word" maxlength="20" placeholder="Search"/><input type="hidden" name="si" value="https://kanmars.github.io"/><input name="tn" type="hidden" value="bds"/><input name="cl" type="hidden" value="3"/><input name="ct" type="hidden" value="2097152"/><input name="s" type="hidden" value="on"/></form></div><div class="widget"><div class="widget-title"><i class="fa fa-folder-o"> Kategorien</i></div></div><div class="widget"><div class="widget-title"><i class="fa fa-star-o"> Tags</i></div><div class="tagcloud"><a href="/tags/jetty/" style="font-size: 15px;">jetty</a> <a href="/tags/it/" style="font-size: 15px;">it</a> <a href="/tags/architecture/" style="font-size: 15px;">architecture</a> <a href="/tags/itlife/" style="font-size: 15px;">itlife</a> <a href="/tags/rsa/" style="font-size: 15px;">rsa</a> <a href="/tags/tb/" style="font-size: 15px;">tb</a> <a href="/tags/drawline/" style="font-size: 15px;">drawline</a> <a href="/tags/life/" style="font-size: 15px;">life</a> <a href="/tags/strategy/" style="font-size: 15px;">strategy</a> <a href="/tags/tblife/" style="font-size: 15px;">tblife</a> <a href="/tags/java/" style="font-size: 15px;">java</a> <a href="/tags/linux/" style="font-size: 15px;">linux</a> <a href="/tags/spring/" style="font-size: 15px;">spring</a> <a href="/tags/server/" style="font-size: 15px;">server</a> <a href="/tags/c/" style="font-size: 15px;">c</a> <a href="/tags/c/" style="font-size: 15px;">c++</a> <a href="/tags/lua/" style="font-size: 15px;">lua</a> <a href="/tags/android/" style="font-size: 15px;">android</a> <a href="/tags/javascript/" style="font-size: 15px;">javascript</a> <a href="/tags/neuralnetwork/" style="font-size: 15px;">neuralnetwork</a> <a href="/tags/cpu/" style="font-size: 15px;">cpu</a> <a href="/tags/disk/" style="font-size: 15px;">disk</a> <a href="/tags/fidsk/" style="font-size: 15px;">fidsk</a> <a href="/tags/fstab/" style="font-size: 15px;">fstab</a> <a href="/tags/lvm/" style="font-size: 15px;">lvm</a> <a href="/tags/aix/" style="font-size: 15px;">aix</a></div></div><div class="widget"><div class="widget-title"><i class="fa fa-file-o"> Letzte</i></div><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/2016/11/18/2016-11-18-springmvc_source_004_viewresolver/">[KANMARS原创]-SpringMVC源码解析(4) - 视图处理器</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/11/18/2016-11-18-springmvc_source_003_requestprocess/">[KANMARS原创]-SpringMVC源码解析(3) - 请求处理过程</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/11/17/2016-11-17-springmvc_source_002_start/">[KANMARS原创]-SpringMVC源码解析(2) - 启动过程</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/11/17/2016-11-17-springmvc_source_001_introduce/">[KANMARS原创]-SpringMVC源码解析(1) - 简介</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/11/04/2016-11-04-SomeThingAndNothing/">SomeThingAndNothing</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/10/25/2016-10-25-news-LongRoad/">news It's a Long Road</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/10/19/2016-10-19-Scale-Services/">On Designing and Deploying Internet-Scale Services</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/10/18/2016-10-18-dubbo_source_006_summarize/">[KANMARS原创]-DUBBO源码解析(6)-summarize</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/10/18/2016-10-18-dubbo_source_005_consumerCall/">[KANMARS原创]-DUBBO源码解析(5)-consumerCall</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/09/19/2016-09-08-dubbo_source_004_referenceBean/">[KANMARS原创]-DUBBO源码解析(4)-referenceBean</a></li></ul></div><div class="widget"><div class="comments-title"><i class="fa fa-comment-o"> Letzte Kommentare</i></div><div data-num-items="5" data-show-avatars="0" data-show-time="1" data-show-admin="0" data-excerpt-length="32" data-show-title="1" class="ds-recent-comments"></div></div><div class="widget"><div class="widget-title"><i class="fa fa-external-link"> Blogroll</i></div><ul></ul><a href="http://www.linux.cn" title="Linux-CN" target="_blank">Linux-CN</a><ul></ul><a href="http://www.gome.com.cn" title="国美互联网" target="_blank">国美互联网</a><ul></ul><a href="http://jr.gome.com.cn" title="国美金融" target="_blank">国美金融</a></div></div></div><div class="pure-u-1 pure-u-md-3-4"><div id="footer">© <a href="/." rel="nofollow">KANMARS的博客.</a> Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a><a rel="nofollow" target="_blank" href="https://github.com/tufu9441/maupassant-hexo"> Theme</a> by<a rel="nofollow" target="_blank" href="https://github.com/pagecho"> Cho.</a></div></div></div><a id="rocket" href="#top" class="show"></a><script type="text/javascript" src="/js/totop.js?v=0.0.0" async></script><script type="text/javascript" src="//cdn.bootcss.com/fancybox/2.1.5/jquery.fancybox.pack.js" async></script><script type="text/javascript" src="/js/fancybox.js?v=0.0.0" async></script><link rel="stylesheet" type="text/css" href="/css/jquery.fancybox.css?v=0.0.0"><script>var duoshuoQuery = {short_name:'kanmars'};
(function() {
    var ds = document.createElement('script');
    ds.type = 'text/javascript';ds.async = true;
    ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
    ds.charset = 'UTF-8';
    (document.getElementsByTagName('head')[0]
        || document.getElementsByTagName('body')[0]).appendChild(ds);
})();
</script><script type="text/javascript" src="/js/codeblock-resizer.js?v=0.0.0"></script><script type="text/javascript" src="/js/smartresize.js?v=0.0.0"></script></div></body></html>